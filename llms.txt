This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.cursor/
  rules/
    batch-processing-architecture.mdc
    pdf-rendering-pipeline.mdc
    scaling-algorithms.mdc
.giga/
  specifications.json
.github/
  ISSUE_TEMPLATE/
    bug_report.md
    feature_request.md
  workflows/
    build.yml
    release.yml
  FUNDING.yml
.specstory/
  .gitignore
archive/
  objc/
    pdf22png-objc/
      scripts/
        test-objc.sh
      src/
        errors.h
        pdf22png.h
        pdf22png.m
        utils.h
        utils.m
      Tests/
        test_runner.m
      llms.txt
      Makefile
  swift-spm/
    pdf22png-swift/
      Sources/
        TestFile.swift
      Tests/
        pdf22pngTests/
          pdf22pngTests.swift
      Makefile
      Package.swift
docs/
  API.md
  EXAMPLES.md
  pdf22png.1
  USAGE.md
homebrew/
  pdf22png.rb
scripts/
  install.sh
  uninstall.sh
src/
  CLI/
    ArgumentParser.swift
    OutputFormatter.swift
  Core/
    BatchProcessor.swift
    ImageRenderer.swift
    MemoryManager.swift
    PDFProcessor.swift
    ResourceManager.swift
    SignalHandler.swift
  Models/
    Errors.swift
    ProcessingOptions.swift
    Results.swift
    ScaleSpecification.swift
  Utilities/
    InputValidator.swift
    ProgressReporter.swift
  llms.txt
  main.swift
  Makefile
Tests/
  CLITests/
    ArgumentParserTests.swift
  CoreTests/
    ImageRendererTests.swift
    MemoryManagerTests.swift
    PDFProcessorTests.swift
  UtilitiesTests/
    InputValidatorTests.swift
  test-framework.swift
.cursorrules
.editorconfig
.gitattributes
.gitignore
CHANGELOG.md
CLAUDE.md
LICENSE
Makefile
Package.swift
PLAN.md
README.html
README.md
TODO.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".cursor/rules/batch-processing-architecture.mdc">
---
description: Documents the parallel processing architecture for PDF batch conversions using Grand Central Dispatch
globs: src/pdf22png.m,src/utils.m
alwaysApply: false
---


# batch-processing-architecture

## Parallel Processing Implementation

The batch processing architecture utilizes Grand Central Dispatch (GCD) to parallelize PDF page conversions:

### Core Components

1. **Batch Mode Dispatcher**
- Located in: `src/pdf22png.m`
- Manages concurrent page processing using GCD dispatch queues
- Handles thread synchronization for batch operations

2. **Worker Thread Management**
- Distributes page conversion tasks across multiple threads
- Maintains thread-safe status updates for conversion progress
- Implements autorelease pools for memory management during batch operations

3. **Output Coordination**
- Manages concurrent file writing for multiple page outputs
- Generates sequential output filenames based on page numbers
- Coordinates directory access for batch output files

### Batch Processing Workflow

1. **Initialization Phase**
```
Input PDF -> Page Count Analysis -> Worker Thread Pool Creation
```

2. **Distribution Phase**
```
Page Tasks -> GCD Dispatch Queue -> Worker Threads
```

3. **Synchronization Phase**
```
Worker Results -> Status Aggregation -> Final Output
```

### Critical Business Rules

1. **Page Processing Order**
- Pages can be processed in any order
- Output filenames maintain sequential numbering regardless of completion order
- Each page conversion is atomic and independent

2. **Resource Management**
- Worker threads utilize independent autorelease pools
- Memory allocation is managed per-page rather than globally
- PDF document remains open for shared access across threads

3. **Error Handling**
- Individual page failures don't halt batch processing
- Success/failure status tracked independently per page
- Aggregate status reported after all pages complete

4. **Output Coordination**
- Thread-safe file naming pattern generation
- Directory management for multiple output files
- Status tracking for completed conversions

$END$

 If you're using this file in context, clearly say in italics in one small line that "Context added by Giga batch-processing-architecture".
</file>

<file path=".cursor/rules/pdf-rendering-pipeline.mdc">
---
description: Documentation and analysis of PDF to PNG rendering pipeline including page extraction, CoreGraphics rendering, and image compression
globs: src/pdf22png.m,src/utils.m,src/*.h
alwaysApply: false
---


# pdf-rendering-pipeline 

## Core Rendering Components

### PDF Page Extraction (Importance: 95)
- Extracts individual PDF pages using Core Graphics
- Handles both single page and batch extraction modes
- Validates page numbers against document bounds
- Manages PDF document context and page references

### CoreGraphics Rendering (Importance: 90)
- Creates bitmap contexts sized to target dimensions
- Applies transformation matrix for scaling/positioning
- Renders PDF content through CoreGraphics drawing
- Handles different color spaces and bit depths
- Preserves vector quality during rasterization

### Transparency Handling (Importance: 85)
- Supports transparent backgrounds through alpha channel
- Creates RGBA bitmap contexts when transparency enabled
- Maintains PDF transparency groups during rendering
- Properly blends transparent elements

### PNG Compression Pipeline (Importance: 80)
- Configurable compression levels (0-9)
- Converts rendered bitmap to PNG format
- Handles color space conversion for output
- Manages PNG metadata and color profiles
- Supports both file and stream-based output

### Scale Management (Importance: 75)
- Calculates render dimensions from scale specifications
- Supports percentage, DPI, and fixed dimension scaling
- Maintains aspect ratios during scaling
- Applies appropriate transform matrices

File paths:
- src/pdf22png.m: Main rendering pipeline implementation
- src/utils.m: Scale calculation and image processing utilities
- src/pdf22png.h: Rendering pipeline interfaces

$END$

 If you're using this file in context, clearly say in italics in one small line that "Context added by Giga pdf-rendering-pipeline".
</file>

<file path=".cursor/rules/scaling-algorithms.mdc">
---
description: Specification for PDF scaling algorithms including resolution control, dimension fitting, and aspect ratio preservation
globs: src/utils.m,src/pdf22png.m,*.h
alwaysApply: false
---


# scaling-algorithms

## Core Scaling Logic

### Scale Specification Parsing (Importance: 95)
- Parses user scaling inputs into standardized formats:
  - Percentage scaling (e.g. "150%")
  - Resolution-based (DPI) scaling
  - Fixed dimension scaling (width/height)
  - Aspect ratio preservation
- Located in `src/utils.m:parseScaleSpec()`

### Scale Factor Calculation (Importance: 90)
- Converts parsed scale specs into concrete scaling factors:
  - Percentage to decimal multiplier
  - DPI to PDF-native 72 DPI ratio
  - Dimension constraints to appropriate scale values
- Maintains aspect ratio when scaling to fixed dimensions
- Located in `src/utils.m:calculateScaleFactor()`

### Resolution Control (Importance: 85)
- Handles DPI-based scaling calculations
- Default resolution: 144 DPI 
- Converts between DPI specifications and internal scale factors
- Located in `src/pdf22png.m`

### Dimension Fitting (Importance: 80)
- Supports multiple dimension specification formats:
  - Fixed width (800x)
  - Fixed height (x600) 
  - Bounded box (800x600)
- Calculates appropriate scaling while preserving aspect ratio
- Located in `src/utils.m`

### Aspect Ratio Preservation (Importance: 75)
- Maintains original PDF page proportions during scaling
- Implements "fit within" logic for bounded scaling
- Calculates maximum scale factor that satisfies both dimensions
- Located in `src/utils.m:calculateScaleFactor()`

## Scale Application

### Render Context Scaling (Importance: 70)
- Applies calculated scale factors to Core Graphics render context
- Handles coordinate system transformations
- Located in `src/utils.m:renderPDFPageToImage()`

### Multi-page Scaling (Importance: 65)
- Applies consistent scaling across all pages in batch mode
- Maintains uniform dimensions across output files
- Located in `src/pdf22png.m`

$END$

 If you're using this file in context, clearly say in italics in one small line that "Context added by Giga scaling-algorithms".
</file>

<file path=".giga/specifications.json">
[
  {
    "fileName": "main-overview.mdc",
    "description": "Complete system overview including core architecture, key components, and high-level data flow between PDF processing and PNG generation components"
  },
  {
    "fileName": "scaling-algorithms.mdc",
    "description": "Detailed documentation of the PDF scaling algorithms, including percentage scaling, DPI calculations, dimension fitting, and aspect ratio preservation logic"
  },
  {
    "fileName": "pdf-rendering-pipeline.mdc",
    "description": "Complete documentation of the PDF rendering pipeline, including page extraction, CoreGraphics rendering, transparency handling, and PNG compression workflow"
  },
  {
    "fileName": "batch-processing-architecture.mdc",
    "description": "Documentation of the parallel processing architecture for batch conversions, including Grand Central Dispatch implementation and thread management"
  }
]
</file>

<file path=".github/ISSUE_TEMPLATE/bug_report.md">
---
name: Bug Report
about: Create a report to help us improve pdf22png
title: "[BUG] Brief description of bug"
labels: bug
assignees: ''

---

**Describe the bug**
A clear and concise description of what the bug is.

**To Reproduce**
Steps to reproduce the behavior:
1. Command-line used: `pdf22png ...`
2. Input PDF details (e.g., version, source, a link to a sample if possible and not confidential).
3. `pdf22png --version` (if available, or commit hash)
4. macOS version:

**Expected behavior**
A clear and concise description of what you expected to happen.

**Actual behavior**
A clear and concise description of what actually happened. Include any error messages.

**Screenshots or Output PNGs**
If applicable, add screenshots or the problematic output PNGs to help explain your problem.
If the input PDF is not confidential and can be shared, please attach it or link to it.

**Additional context**
Add any other context about the problem here. For example:
- Specific PDF features that might be involved (e.g., layers, transparency, forms, annotations).
- Any relevant console output if run with `-v` (verbose).
</file>

<file path=".github/ISSUE_TEMPLATE/feature_request.md">
---
name: Feature Request
about: Suggest an idea for pdf22png
title: "[FEAT] Brief description of feature"
labels: enhancement
assignees: ''

---

**Is your feature request related to a problem? Please describe.**
A clear and concise description of what the problem is. Ex. "I'm always frustrated when..."

**Describe the solution you'd like**
A clear and concise description of what you want to happen.

**Describe alternatives you've considered**
A clear and concise description of any alternative solutions or features you've considered.

**Additional context**
Add any other context or screenshots about the feature request here.
- Why would this feature be useful?
- How would it improve `pdf22png`?
- Are there similar features in other tools that could serve as inspiration?
</file>

<file path=".github/FUNDING.yml">
# These are supported funding model platforms

github: [twardoch] # Replace with your GitHub username or organization
patreon: # Replace with your Patreon username
open_collective: # Replace with your Open Collective username
ko_fi: # Replace with your Ko-fi username
tidelift: # Replace with your Tidelift platform-name/package-name e.g., npm/babel
community_bridge: # Replace with your Community Bridge project-name e.g., cloud-foundry
liberapay: # Replace with your Liberapay username
issuehunt: # Replace with your IssueHunt username
otechie: # Replace with your Otechie username
custom: # Replace with up to 4 custom sponsorship URLs e.g., ['link1', 'link2']
</file>

<file path=".specstory/.gitignore">
# SpecStory explanation file
/.what-is-this.md
</file>

<file path="archive/objc/pdf22png-objc/scripts/test-objc.sh">
#!/bin/bash
# Test script for Objective-C version of pdf22png

set -e

echo "Testing pdf22png Objective-C implementation..."

# Create a simple test PDF using PostScript
cat > test.ps << 'EOF'
%!PS-Adobe-3.0
%%BoundingBox: 0 0 612 792
%%Pages: 2
%%EndComments

%%Page: 1 1
/Helvetica findfont 40 scalefont setfont
100 400 moveto
(Test Page 1) show
showpage

%%Page: 2 2  
/Helvetica findfont 40 scalefont setfont
100 400 moveto
(Test Page 2) show
showpage

%%EOF
EOF

# Convert PS to PDF
ps2pdf test.ps test.pdf

# Build if not already built
if [ ! -f ./build/pdf22png-objc ]; then
    echo "Building Objective-C version..."
    make objc
fi

echo ""
echo "Running tests..."
echo "==============="

# Test 1: Basic conversion
echo "Test 1: Basic single page conversion"
./build/pdf22png-objc test.pdf test-output.png
if [ -f test-output.png ]; then
    echo "✓ Basic conversion successful"
    rm test-output.png
else
    echo "✗ Basic conversion failed"
fi

# Test 2: Specific page
echo ""
echo "Test 2: Convert page 2"
./build/pdf22png-objc -p 2 test.pdf test-page2.png
if [ -f test-page2.png ]; then
    echo "✓ Page selection successful"
    rm test-page2.png
else
    echo "✗ Page selection failed"
fi

# Test 3: Scaling
echo ""
echo "Test 3: Scale to 200%"
./build/pdf22png-objc -s 200% test.pdf test-scaled.png
if [ -f test-scaled.png ]; then
    echo "✓ Scaling successful"
    rm test-scaled.png
else
    echo "✗ Scaling failed"
fi

# Test 4: DPI setting
echo ""
echo "Test 4: Convert at 300 DPI"
./build/pdf22png-objc -r 300 test.pdf test-300dpi.png
if [ -f test-300dpi.png ]; then
    echo "✓ DPI setting successful"
    rm test-300dpi.png
else
    echo "✗ DPI setting failed"
fi

# Test 5: Batch mode
echo ""
echo "Test 5: Batch conversion"
mkdir -p test-batch
./build/pdf22png-objc -a -d test-batch test.pdf
if [ -f test-batch/test-001.png ] && [ -f test-batch/test-002.png ]; then
    echo "✓ Batch conversion successful"
    rm -rf test-batch
else
    echo "✗ Batch conversion failed"
fi

# Test 6: Dry run
echo ""
echo "Test 6: Dry run mode"
./build/pdf22png-objc -D test.pdf test-dryrun.png > /dev/null 2>&1
if [ ! -f test-dryrun.png ]; then
    echo "✓ Dry run successful (no file created)"
else
    echo "✗ Dry run failed (file was created)"
    rm test-dryrun.png
fi

# Test 7: stdin/stdout
echo ""
echo "Test 7: stdin to stdout"
cat test.pdf | ./build/pdf22png-objc - - > test-stdio.png 2>/dev/null
if [ -f test-stdio.png ] && [ -s test-stdio.png ]; then
    echo "✓ stdin/stdout successful"
    rm test-stdio.png
else
    echo "✗ stdin/stdout failed"
fi

# Test 8: Help
echo ""
echo "Test 8: Help message"
if ./build/pdf22png-objc -h 2>&1 | grep -q "Usage:"; then
    echo "✓ Help message displayed"
else
    echo "✗ Help message failed"
fi

# Cleanup
rm -f test.ps test.pdf

echo ""
echo "==============="
echo "Tests complete!"
</file>

<file path="archive/objc/pdf22png-objc/src/errors.h">
#ifndef PDF22PNG_ERRORS_H
#define PDF22PNG_ERRORS_H

// Error codes for pdf22png
typedef enum {
    PDF22PNG_SUCCESS = 0,
    PDF22PNG_ERROR_GENERAL = 1,
    PDF22PNG_ERROR_INVALID_ARGS = 2,
    PDF22PNG_ERROR_FILE_NOT_FOUND = 3,
    PDF22PNG_ERROR_FILE_READ = 4,
    PDF22PNG_ERROR_FILE_WRITE = 5,
    PDF22PNG_ERROR_NO_INPUT = 6,
    PDF22PNG_ERROR_INVALID_PDF = 7,
    PDF22PNG_ERROR_ENCRYPTED_PDF = 8,
    PDF22PNG_ERROR_EMPTY_PDF = 9,
    PDF22PNG_ERROR_PAGE_NOT_FOUND = 10,
    PDF22PNG_ERROR_RENDER_FAILED = 11,
    PDF22PNG_ERROR_MEMORY = 12,
    PDF22PNG_ERROR_OUTPUT_DIR = 13,
    PDF22PNG_ERROR_INVALID_SCALE = 14,
    PDF22PNG_ERROR_BATCH_FAILED = 15
} PDF22PNGError;

// Error messages
static const char* PDF22PNG_ERROR_MESSAGES[] = {
    "Success",
    "General error",
    "Invalid command line arguments",
    "Input file not found",
    "Failed to read input file",
    "Failed to write output file",
    "No input data received",
    "Invalid PDF document",
    "PDF document is encrypted (password-protected PDFs not supported)",
    "PDF document has no pages",
    "Requested page does not exist",
    "Failed to render PDF page",
    "Memory allocation failed",
    "Failed to create output directory",
    "Invalid scale specification",
    "Batch processing failed"
};

// Function to get error message
static inline const char* pdf22png_error_string(PDF22PNGError error) {
    if (error >= 0 && error <= PDF22PNG_ERROR_BATCH_FAILED) {
        return PDF22PNG_ERROR_MESSAGES[error];
    }
    return "Unknown error";
}

// Macro for error reporting with file and line info
#define PDF22PNG_ERROR(code, ...) do { \
    fprintf(stderr, "Error: %s\n", pdf22png_error_string(code)); \
    if (##__VA_ARGS__) { \
        fprintf(stderr, "Details: "); \
        fprintf(stderr, ##__VA_ARGS__); \
        fprintf(stderr, "\n"); \
    } \
} while(0)

#endif // PDF22PNG_ERRORS_H
</file>

<file path="archive/objc/pdf22png-objc/src/pdf22png.h">
#import <Foundation/Foundation.h>
#import <Quartz/Quartz.h>
#import <ImageIO/ImageIO.h>
#import "errors.h"

// Structures from pdf22png.m
typedef struct {
    CGFloat scaleFactor;
    CGFloat maxWidth;
    CGFloat maxHeight;
    CGFloat dpi;
    BOOL isPercentage;
    BOOL isDPI;
    BOOL hasWidth;
    BOOL hasHeight;
} ScaleSpec;

typedef struct {
    ScaleSpec scale;
    NSInteger pageNumber;
    NSString *inputPath;
    NSString *outputPath;
    NSString *outputDirectory;
    BOOL batchMode;
    // Recommended additions for new features from README
    BOOL transparentBackground;
    int pngQuality; // 0-9
    BOOL verbose;
    BOOL includeText; // Include extracted text in filename
    NSString *pageRange; // Page range specification (e.g., "1-5,10,15-20")
    BOOL dryRun; // Preview operations without writing files
    NSString *namingPattern; // Custom naming pattern with placeholders
    BOOL forceOverwrite; // Force overwrite without prompting
} Options;

// Function prototypes from pdf22png.m that should remain in main logic
void printUsage(const char *programName);
Options parseArguments(int argc, const char *argv[]);
BOOL processSinglePage(CGPDFDocumentRef pdfDocument, Options *options);
BOOL processBatchMode(CGPDFDocumentRef pdfDocument, Options *options);

// Potentially new functions based on README advanced options
// These would be implemented in pdf22png.m
// void handleTransparency(CGContextRef context, Options* options); // Example if needed
// void setPNGCompression(CGImageDestinationRef dest, Options* options); // Example if needed

// Main function declaration (though it's standard)
int main(int argc, const char *argv[]);
</file>

<file path="archive/objc/pdf22png-objc/src/pdf22png.m">
#import "pdf22png.h"
#import "utils.h"
#import <getopt.h>
#import <signal.h>

// Global variable for signal handling
static volatile sig_atomic_t g_shouldTerminate = 0;

// Signal handler for graceful shutdown
void signalHandler(int sig) {
    g_shouldTerminate = 1;
    fprintf(stderr, "\nReceived signal %d, finishing current operations...\n", sig);
}

// Define long options for getopt_long
static struct option long_options[] = {
    {"page", required_argument, 0, 'p'},
    {"all", no_argument, 0, 'a'}, // New: for batch mode without needing -d
    {"resolution", required_argument, 0, 'r'}, // Maps to -s Ndpi
    {"scale", required_argument, 0, 's'},
    {"transparent", no_argument, 0, 't'},
    {"quality", required_argument, 0, 'q'},
    {"verbose", no_argument, 0, 'v'},
    {"name", no_argument, 0, 'n'}, // Include text in filename
    {"pattern", required_argument, 0, 'P'}, // Custom naming pattern
    {"dry-run", no_argument, 0, 'D'}, // Preview operations without writing
    {"force", no_argument, 0, 'f'}, // Force overwrite without prompting
    {"help", no_argument, 0, 'h'},
    {"output", required_argument, 0, 'o'}, // For consistency with other tools
    {"directory", required_argument, 0, 'd'}, // For batch output directory
    {0, 0, 0, 0}
};

void printUsage(const char *programName) {
    fprintf(stderr, "Usage: %s [OPTIONS] <input.pdf> [output.png | output_%%03d.png]\n", programName);
    fprintf(stderr, "Converts PDF documents to PNG images.\n\n");
    fprintf(stderr, "Options:\n");
    fprintf(stderr, "  -p, --page <spec>       Page(s) to convert. Single page, range, or comma-separated.\n");
    fprintf(stderr, "                          Examples: 1 | 1-5 | 1,3,5-10 (default: 1)\n");
    fprintf(stderr, "                          In batch mode, only specified pages are converted.\n");
    fprintf(stderr, "  -a, --all               Convert all pages. If -d is not given, uses input filename as prefix.\n");
    fprintf(stderr, "                          Output files named <prefix>-<page_num>.png.\n");
    fprintf(stderr, "  -r, --resolution <dpi>  Set output DPI (e.g., 150dpi). Overrides -s if both used with numbers.\n");
    fprintf(stderr, "  -s, --scale <spec>      Scaling specification (default: 100%% or 1.0).\n");
    fprintf(stderr, "                            NNN%%: percentage (e.g., 150%%)\n");
    fprintf(stderr, "                            N.N:  scale factor (e.g., 1.5)\n");
    fprintf(stderr, "                            WxH:  fit to WxH pixels (e.g., 800x600)\n");
    fprintf(stderr, "                            Wx:   fit to width W pixels (e.g., 1024x)\n");
    fprintf(stderr, "                            xH:   fit to height H pixels (e.g., x768)\n");
    // fprintf(stderr, "                            Ndpi: dots per inch (e.g., 300dpi) - use -r for this\n");
    fprintf(stderr, "  -t, --transparent       Preserve transparency (default: white background).\n");
    fprintf(stderr, "  -q, --quality <n>       PNG compression quality (0-9, default: 6). Currently informational.\n");
    fprintf(stderr, "  -o, --output <path>     Output PNG file or prefix for batch mode.\n");
    fprintf(stderr, "                          If '-', output to stdout (single page mode only).\n");
    fprintf(stderr, "  -d, --directory <dir>   Output directory for batch mode (converts all pages).\n");
    fprintf(stderr, "                          If used, -o specifies filename prefix inside this directory.\n");
    fprintf(stderr, "  -v, --verbose           Verbose output.\n");
    fprintf(stderr, "  -n, --name              Include extracted text in output filename (batch mode only).\n");
    fprintf(stderr, "  -P, --pattern <pat>     Custom naming pattern for batch mode. Placeholders:\n");
    fprintf(stderr, "                          {basename} - Input filename without extension\n");
    fprintf(stderr, "                          {page} - Page number (auto-padded)\n");
    fprintf(stderr, "                          {page:03d} - Page with custom padding\n");
    fprintf(stderr, "                          {text} - Extracted text (requires -n)\n");
    fprintf(stderr, "                          {date} - Current date (YYYYMMDD)\n");
    fprintf(stderr, "                          {time} - Current time (HHMMSS)\n");
    fprintf(stderr, "                          {total} - Total page count\n");
    fprintf(stderr, "                          Example: '{basename}_p{page:04d}_of_{total}'\n");
    fprintf(stderr, "  -D, --dry-run           Preview operations without writing files.\n");
    fprintf(stderr, "  -f, --force             Force overwrite existing files without prompting.\n");
    fprintf(stderr, "  -h, --help              Show this help message and exit.\n\n");
    fprintf(stderr, "Arguments:\n");
    fprintf(stderr, "  <input.pdf>             Input PDF file. If '-', reads from stdin.\n");
    fprintf(stderr, "  [output.png]            Output PNG file. Required if not using -o or -d.\n");
    fprintf(stderr, "                          If input is stdin and output is not specified, output goes to stdout.\n");
    fprintf(stderr, "                          In batch mode (-a or -d), this is used as a prefix if -o is not set.\n");
}

Options parseArguments(int argc, const char *argv[]) {
    Options options = {
        .scale = {.scaleFactor = 1.0, .isPercentage = YES, .dpi = 144}, // Default DPI is 144 from README
        .pageNumber = 1,
        .inputPath = nil,
        .outputPath = nil,
        .outputDirectory = nil,
        .batchMode = NO,
        .transparentBackground = NO,
        .pngQuality = 6, // Default PNG quality
        .verbose = NO,
        .includeText = NO,
        .pageRange = nil,
        .dryRun = NO,
        .namingPattern = nil,
        .forceOverwrite = NO
    };

    int opt;
    int option_index = 0;
    BOOL scale_explicitly_set = NO;
    BOOL resolution_explicitly_set = NO;

    // Suppress getopt's default error messages
    // opterr = 0;

    while ((opt = getopt_long(argc, (char *const *)argv, "p:ar:s:tq:o:d:vnP:Dfh", long_options, &option_index)) != -1) {
        switch (opt) {
            case 'p': {
                options.pageRange = [NSString stringWithUTF8String:optarg];
                // For single page mode compatibility, try to parse as simple number
                NSScanner *scanner = [NSScanner scannerWithString:options.pageRange];
                NSInteger singlePage;
                if ([scanner scanInteger:&singlePage] && [scanner isAtEnd]) {
                    options.pageNumber = singlePage;
                    if (options.pageNumber < 1) {
                        fprintf(stderr, "Error: Invalid page number: %s. Must be >= 1.\n", optarg);
                        exit(1);
                    }
                } else {
                    // It's a range or list, will be parsed later
                    options.pageNumber = 0; // Indicates range mode
                }
                break;
            }
            case 'a':
                options.batchMode = YES;
                break;
            case 'r': {
                NSString* resStr = [NSString stringWithUTF8String:optarg];
                if (![resStr hasSuffix:@"dpi"]) { // Ensure it's passed as Ndpi, or assume dpi
                    resStr = [resStr stringByAppendingString:@"dpi"];
                }
                if (!parseScaleSpec([resStr UTF8String], &options.scale)) {
                    fprintf(stderr, "Error: Invalid resolution specification: %s\n", optarg);
                    printUsage(argv[0]);
                    exit(1);
                }
                resolution_explicitly_set = YES;
                break;
            }
            case 's':
                if (!parseScaleSpec(optarg, &options.scale)) {
                    reportError([NSString stringWithFormat:@"Invalid scale specification: %s", optarg],
                               getTroubleshootingHint(@"scale format"));
                    printUsage(argv[0]);
                    exit(1);
                }
                scale_explicitly_set = YES;
                break;
            case 't':
                options.transparentBackground = YES;
                break;
            case 'q':
                options.pngQuality = atoi(optarg);
                if (options.pngQuality < 0 || options.pngQuality > 9) {
                    fprintf(stderr, "Error: Invalid PNG quality: %s. Must be between 0 and 9.\n", optarg);
                    exit(1);
                }
                break;
            case 'o':
                options.outputPath = [NSString stringWithUTF8String:optarg];
                break;
            case 'd':
                options.outputDirectory = [NSString stringWithUTF8String:optarg];
                options.batchMode = YES; // -d implies batch mode
                break;
            case 'v':
                options.verbose = YES;
                break;
            case 'n':
                options.includeText = YES;
                break;
            case 'P':
                options.namingPattern = [NSString stringWithUTF8String:optarg];
                break;
            case 'D':
                options.dryRun = YES;
                break;
            case 'f':
                options.forceOverwrite = YES;
                break;
            case 'h':
                printUsage(argv[0]);
                exit(0);
            case '?': // Unknown option or missing argument
                // getopt_long already prints an error message if opterr is not 0
                // fprintf(stderr, "Error: Unknown option or missing argument.\n");
                printUsage(argv[0]);
                exit(1);
            default:
                // Should not happen
                abort();
        }
    }

    logMessage(options.verbose, @"Finished parsing options.");

    // Handle conflicting scale/resolution. Resolution (-r) takes precedence.
    if (resolution_explicitly_set && scale_explicitly_set && !options.scale.isDPI) {
        // If -r was set, options.scale is already DPI based.
        // If -s was also set but not as DPI, -r (DPI) wins.
        // If -s was also set as DPI, the last one parsed wins, which is fine.
        logMessage(options.verbose, @"Both -r (resolution) and -s (scale) were specified. Using resolution (-r %fdpi).", options.scale.dpi);
    } else if (!resolution_explicitly_set && !scale_explicitly_set) {
        // Neither -r nor -s set, use default DPI of 144
        logMessage(options.verbose, @"No scale or resolution specified, using default %fdpi.", options.scale.dpi);
        // Ensure scale is set to DPI based for default
        char defaultDpiStr[16];
        snprintf(defaultDpiStr, sizeof(defaultDpiStr), "%ddpi", (int)options.scale.dpi);
        parseScaleSpec(defaultDpiStr, &options.scale);
    }


    // Handle positional arguments (input and output files)
    int num_remaining_args = argc - optind;
    logMessage(options.verbose, @"Number of remaining arguments: %d", num_remaining_args);

    if (num_remaining_args == 0 && isatty(fileno(stdin))) {
         fprintf(stderr, "Error: Input PDF file required, or pipe from stdin.\n");
         printUsage(argv[0]);
         exit(1);
    }

    // Input file
    if (num_remaining_args > 0) {
        NSString* first_arg = [NSString stringWithUTF8String:argv[optind]];
        if ([first_arg isEqualToString:@"-"]) {
            options.inputPath = nil; // stdin
            logMessage(options.verbose, @"Input PDF: stdin");
        } else {
            options.inputPath = first_arg;
            logMessage(options.verbose, @"Input PDF: %@", options.inputPath);
        }
        optind++;
        num_remaining_args--;
    } else { // No positional args, input must be stdin
        options.inputPath = nil; // stdin
        logMessage(options.verbose, @"Input PDF: stdin (implied)");
    }


    // Output file / prefix
    if (options.outputPath == nil) { // if -o was not used
        if (num_remaining_args > 0) {
            options.outputPath = [NSString stringWithUTF8String:argv[optind]];
            logMessage(options.verbose, @"Output path (from argument): %@", options.outputPath);
            optind++;
            num_remaining_args--;
        } else {
            // No -o and no second positional argument
            if (options.inputPath == nil && !options.batchMode) { // Input is stdin, not batch mode
                options.outputPath = @"-"; // Default to stdout
                logMessage(options.verbose, @"Output path: stdout (implied for stdin input)");
            } else if (options.batchMode && options.outputDirectory == nil) {
                // Batch mode, no -d, no -o, no output arg. Use input filename as prefix.
                // This case is handled by getOutputPrefix if options.outputPath is nil.
                logMessage(options.verbose, @"Batch mode: Output prefix will be derived from input filename or default to 'page'.");
            } else if (!options.batchMode && options.inputPath != nil) {
                 fprintf(stderr, "Error: Output PNG file required when input is a file and not in batch mode.\n");
                 printUsage(argv[0]);
                 exit(1);
            }
        }
    } else {
        logMessage(options.verbose, @"Output path (from -o): %@", options.outputPath);
    }

    if (num_remaining_args > 0) {
        fprintf(stderr, "Error: Too many arguments.\n");
        printUsage(argv[0]);
        exit(1);
    }

    // Final checks for batch mode
    if (options.batchMode) {
        if ([options.outputPath isEqualToString:@"-"]) {
            fprintf(stderr, "Error: Cannot output to stdout in batch mode.\n");
            exit(1);
        }
        if (options.outputDirectory == nil) {
            // If -d is not specified, output to current directory
            options.outputDirectory = @".";
            logMessage(options.verbose, @"Batch mode: Output directory not specified, using current directory '.'");
        }
        // If outputPath was not set by -o or positional arg, getOutputPrefix will use input name or "page"
        // If outputPath was set, it's the prefix.
    } else { // Single page mode
        if (options.outputDirectory != nil) {
            fprintf(stderr, "Error: -d/--directory is only for batch mode (-a/--all).\n");
            exit(1);
        }
    }

    logMessage(options.verbose, @"Final Options: pageNumber=%ld, batchMode=%s, transparent=%s, quality=%d, verbose=%s",
        (long)options.pageNumber, options.batchMode?"YES":"NO",
        options.transparentBackground?"YES":"NO", options.pngQuality, options.verbose?"YES":"NO");
    logMessage(options.verbose, @"ScaleSpec: factor=%.2f, dpi=%.2f, w=%.0f, h=%.0f, %%=%s, dpi_set=%s, w_set=%s, h_set=%s",
        options.scale.scaleFactor, options.scale.dpi, options.scale.maxWidth, options.scale.maxHeight,
        options.scale.isPercentage?"YES":"NO", options.scale.isDPI?"YES":"NO",
        options.scale.hasWidth?"YES":"NO", options.scale.hasHeight?"YES":"NO");


    return options;
}


BOOL processSinglePage(CGPDFDocumentRef pdfDocument, Options *options) {
    @autoreleasepool {
        logMessage(options->verbose, @"Processing single page: %ld", (long)options->pageNumber);

        size_t pageCount = CGPDFDocumentGetNumberOfPages(pdfDocument);
        if (options->pageNumber < 1 || options->pageNumber > (NSInteger)pageCount) {
            fprintf(stderr, "Error: Page %ld does not exist (document has %zu pages).\n",
                    (long)options->pageNumber, pageCount);
            return NO;
        }

        CGPDFPageRef pdfPage = CGPDFDocumentGetPage(pdfDocument, options->pageNumber);
        if (!pdfPage) {
            fprintf(stderr, "Error: Failed to get page %ld.\n", (long)options->pageNumber);
            return NO;
        }

        CGRect pageRect = CGPDFPageGetBoxRect(pdfPage, kCGPDFMediaBox);
        CGFloat scaleFactor = calculateScaleFactor(&options->scale, pageRect);
        logMessage(options->verbose, @"Calculated scale factor for page %ld: %.2f", (long)options->pageNumber, scaleFactor);

        CGImageRef image = renderPDFPageToImage(pdfPage, scaleFactor, options->transparentBackground, options->verbose);
        if (!image) {
            fprintf(stderr, "Error: Failed to render PDF page %ld.\n", (long)options->pageNumber);
            return NO;
        }

        BOOL success;
        if (options->outputPath && [options->outputPath isEqualToString:@"-"]) {
            if (options->dryRun) {
                size_t width = CGImageGetWidth(image);
                size_t height = CGImageGetHeight(image);
                fprintf(stdout, "[DRY-RUN] Would write PNG to stdout\n");
                fprintf(stdout, "          Page: %ld, Dimensions: %zux%zu\n", (long)options->pageNumber, width, height);
                success = YES;
            } else {
                logMessage(options->verbose, @"Writing image to stdout.");
                NSFileHandle *stdoutHandle = [NSFileHandle fileHandleWithStandardOutput];
                success = writeImageAsPNG(image, stdoutHandle, options->pngQuality, options->verbose);
            }
        } else if (options->outputPath) {
            logMessage(options->verbose, @"Writing image to file: %@", options->outputPath);
            success = writeImageToFile(image, options->outputPath, options->pngQuality, options->verbose, options->dryRun, options->forceOverwrite);
        } else {
            // This case should ideally be caught by argument parsing, means no output specified
            fprintf(stderr, "Error: Output path not specified for single page mode.\n");
            success = NO;
        }

        CGImageRelease(image);
        return success;
    }
}

BOOL processBatchMode(CGPDFDocumentRef pdfDocument, Options *options) {
    logMessage(options->verbose, @"Processing in batch mode. Output directory: %@", options->outputDirectory);

    if (options->dryRun) {
        fprintf(stdout, "[DRY-RUN] Would create directory: %s\n", [options->outputDirectory UTF8String]);
    } else {
        NSFileManager *fileManager = [NSFileManager defaultManager];
        NSError *error = nil;
        if (![fileManager createDirectoryAtPath:options->outputDirectory
                    withIntermediateDirectories:YES
                                     attributes:nil
                                          error:&error]) {
            fprintf(stderr, "Error: Failed to create output directory '%s': %s\n",
                    [options->outputDirectory UTF8String],
                    [[error localizedDescription] UTF8String]);
            return NO;
        }
    }

    size_t totalPageCount = CGPDFDocumentGetNumberOfPages(pdfDocument);
    NSString *prefix = getOutputPrefix(options); // Handles nil outputPath for prefix generation
    logMessage(options->verbose, @"Using output prefix: %@", prefix);

    // Determine which pages to process
    NSArray<NSNumber *> *pagesToProcess;
    if (options->pageRange) {
        pagesToProcess = parsePageRange(options->pageRange, totalPageCount);
        if (!pagesToProcess || pagesToProcess.count == 0) {
            reportError([NSString stringWithFormat:@"Invalid page range specification: %@", options->pageRange],
                       getTroubleshootingHint(@"page range"));
            return NO;
        }
        logMessage(options->verbose, @"Processing %lu pages from range: %@",
                   (unsigned long)pagesToProcess.count, options->pageRange);
    } else {
        // Process all pages
        NSMutableArray *allPages = [NSMutableArray arrayWithCapacity:totalPageCount];
        for (size_t i = 1; i <= totalPageCount; i++) {
            [allPages addObject:@(i)];
        }
        pagesToProcess = allPages;
        logMessage(options->verbose, @"Processing all %zu pages", totalPageCount);
    }

    __block volatile NSInteger successCount = 0;
    __block volatile NSInteger failCount = 0;
    __block volatile NSInteger processedCount = 0;
    NSObject *lock = [[NSObject alloc] init]; // For thread-safe modification of counters

    logMessage(options->verbose, @"Starting batch conversion of %lu pages...",
               (unsigned long)pagesToProcess.count);

    dispatch_apply(pagesToProcess.count, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^(size_t i) {
        // Check for termination signal
        if (g_shouldTerminate) {
            return;
        }

        // Continue processing even if other pages fail
        size_t pageNum = [pagesToProcess[i] unsignedIntegerValue];
        logMessage(options->verbose, @"Starting processing for page %zu...", pageNum);

        @autoreleasepool {
            CGPDFPageRef pdfPage = CGPDFDocumentGetPage(pdfDocument, pageNum);
            if (!pdfPage) {
                fprintf(stderr, "Warning: Failed to get page %zu, skipping.\n", pageNum);
                @synchronized(lock) {
                    failCount++;
                    processedCount++;
                }
                return;
            }

            CGRect pageRect = CGPDFPageGetBoxRect(pdfPage, kCGPDFMediaBox);
            CGFloat scaleFactor = calculateScaleFactor(&options->scale, pageRect);
            logMessage(options->verbose, @"Calculated scale factor for page %zu: %.2f", pageNum, scaleFactor);

            CGImageRef image = renderPDFPageToImage(pdfPage, scaleFactor, options->transparentBackground, options->verbose);
            if (!image) {
                fprintf(stderr, "Warning: Failed to render page %zu, skipping.\n", pageNum);
                @synchronized(lock) {
                    failCount++;
                    processedCount++;
                }
                return;
            }

            NSString *filename;
            NSString *extractedText = nil;

            // Extract text if needed (for -n flag or {text} placeholder)
            if (options->includeText || (options->namingPattern && [options->namingPattern containsString:@"{text}"])) {
                // Extract text from PDF page first
                NSString *pageText = extractTextFromPDFPage(pdfPage);

                // If no text found, try OCR
                if (!pageText || pageText.length == 0) {
                    logMessage(options->verbose, @"No text extracted from PDF, attempting OCR for page %zu", pageNum);
                    pageText = performOCROnImage(image);
                }

                // Slugify the text if found
                if (pageText && pageText.length > 0) {
                    extractedText = slugifyText(pageText, 30);
                    logMessage(options->verbose, @"Extracted text for page %zu: %@", pageNum, extractedText);
                } else {
                    logMessage(options->verbose, @"No text found for page %zu", pageNum);
                }
            }

            // Generate filename using pattern or default format
            if (options->namingPattern) {
                filename = formatFilenameWithPattern(options->namingPattern, prefix, pageNum, totalPageCount, extractedText);
                filename = [filename stringByAppendingString:@".png"];
            } else {
                filename = formatFilenameWithPattern(nil, prefix, pageNum, totalPageCount,
                                                   options->includeText ? extractedText : nil);
                filename = [filename stringByAppendingString:@".png"];
            }

            NSString *outputPath = [options->outputDirectory stringByAppendingPathComponent:filename];
            logMessage(options->verbose, @"Writing image for page %zu to file: %@", pageNum, outputPath);

            if (!writeImageToFile(image, outputPath, options->pngQuality, options->verbose, options->dryRun, options->forceOverwrite)) {
                fprintf(stderr, "Warning: Failed to write page %zu to '%s', skipping.\n", pageNum, [outputPath UTF8String]);
                @synchronized(lock) {
                    failCount++;
                    processedCount++;
                }
            } else {
                @synchronized(lock) {
                    successCount++;
                    processedCount++;
                }
            }

            CGImageRelease(image);

            // Progress reporting
            @synchronized(lock) {
                if (!options->verbose && processedCount % 10 == 0) {
                    fprintf(stderr, "\rProgress: %ld/%lu pages processed",
                            (long)processedCount, (unsigned long)pagesToProcess.count);
                    fflush(stderr);
                }
            }

            logMessage(options->verbose, @"Finished processing for page %zu.", pageNum);
        }
    });

    // Clear progress line if not in verbose mode
    if (!options->verbose) {
        fprintf(stderr, "\r%*s\r", 50, ""); // Clear the progress line
    }

    // Report results
    if (options->dryRun) {
        fprintf(stdout, "\n[DRY-RUN] Would convert %lu pages to PNG files\n",
                (unsigned long)pagesToProcess.count);
    } else if (g_shouldTerminate) {
        fprintf(stderr, "Batch processing interrupted: %ld pages converted before interruption, %ld pages failed.\n",
                (long)successCount, (long)failCount);
    } else {
        fprintf(stderr, "Batch processing complete: %ld pages converted successfully, %ld pages failed.\n",
                (long)successCount, (long)failCount);
    }

    // Return success only if at least one page was converted
    return successCount > 0;
}

int main(int argc, const char *argv[]) {
    @autoreleasepool {
        // Install signal handlers
        signal(SIGINT, signalHandler);
        signal(SIGTERM, signalHandler);

        Options options = parseArguments(argc, argv);

        logMessage(options.verbose, @"Starting pdf22png tool.");

        NSData *pdfData = readPDFData(options.inputPath, options.verbose);
        if (!pdfData || [pdfData length] == 0) {
            fprintf(stderr, "Error: No PDF data received or PDF data is empty.\n");
            return 1;
        }

        CGDataProviderRef provider = CGDataProviderCreateWithCFData((__bridge CFDataRef)pdfData);
        if (!provider) {
            fprintf(stderr, "Error: Failed to create PDF data provider.\n");
            return 1;
        }
        CGPDFDocumentRef pdfDocument = CGPDFDocumentCreateWithProvider(provider);
        CGDataProviderRelease(provider);

        if (!pdfDocument) {
            fprintf(stderr, "Error: Failed to create PDF document. Ensure the input is a valid PDF.\n");
            return 1;
        }

        // Validate PDF document
        if (CGPDFDocumentIsEncrypted(pdfDocument)) {
            reportError(@"PDF document is encrypted. Password-protected PDFs are not currently supported.",
                       getTroubleshootingHint(@"pdf encrypted password"));
            CGPDFDocumentRelease(pdfDocument);
            return 1;
        }

        size_t pageCount = CGPDFDocumentGetNumberOfPages(pdfDocument);
        if (pageCount == 0) {
            reportError(@"PDF document has no pages.",
                       getTroubleshootingHint(@"pdf empty no pages"));
            CGPDFDocumentRelease(pdfDocument);
            return 1;
        }

        logMessage(options.verbose, @"PDF document loaded successfully. Total pages: %zu", pageCount);

        BOOL success;
        if (options.batchMode) {
            success = processBatchMode(pdfDocument, &options);
        } else {
            success = processSinglePage(pdfDocument, &options);
        }

        CGPDFDocumentRelease(pdfDocument);
        logMessage(options.verbose, @"Processing finished. Success: %s", success ? "YES" : "NO");

        return success ? 0 : 1;
    }
}
</file>

<file path="archive/objc/pdf22png-objc/src/utils.h">
#ifndef UTILS_H
#define UTILS_H

#import <Foundation/Foundation.h>
#import <Quartz/Quartz.h>
#import "pdf22png.h" // For ScaleSpec and Options structs
#import "errors.h" // For error codes and handling

// Function prototypes for utility functions
BOOL parseScaleSpec(const char *spec, ScaleSpec *scale);
NSData *readDataFromStdin(void);
NSData *readPDFData(NSString *inputPath, BOOL verbose); // Added verbose
CGFloat calculateScaleFactor(ScaleSpec *scale, CGRect pageRect);
CGImageRef renderPDFPageToImage(CGPDFPageRef pdfPage, CGFloat scaleFactor, BOOL transparentBackground, BOOL verbose); // Added transparentBackground and verbose
BOOL writeImageAsPNG(CGImageRef image, NSFileHandle *output, int pngQuality, BOOL verbose); // Added pngQuality and verbose
BOOL writeImageToFile(CGImageRef image, NSString *outputPath, int pngQuality, BOOL verbose, BOOL dryRun, BOOL forceOverwrite); // Added pngQuality, verbose, dryRun and forceOverwrite
NSString *getOutputPrefix(Options *options);
void logMessage(BOOL verbose, NSString *format, ...);

// Text extraction and processing
NSString *extractTextFromPDFPage(CGPDFPageRef page);
NSString *performOCROnImage(CGImageRef image);
NSString *slugifyText(NSString *text, NSUInteger maxLength);

// Page range parsing
NSArray<NSNumber *> *parsePageRange(NSString *rangeSpec, NSUInteger totalPages);

// Naming pattern processing
NSString *formatFilenameWithPattern(NSString *pattern, NSString *basename, NSUInteger pageNum,
                                   NSUInteger totalPages, NSString *extractedText);

// File overwrite protection
BOOL fileExists(NSString *path);
BOOL shouldOverwriteFile(NSString *path, BOOL interactive);
BOOL promptUserForOverwrite(NSString *path);

// Enhanced error reporting
void reportError(NSString *message, NSString *troubleshootingHint);
void reportWarning(NSString *message, NSString *troubleshootingHint);
NSString *getTroubleshootingHint(NSString *errorContext);

#endif /* UTILS_H */
</file>

<file path="archive/objc/pdf22png-objc/src/utils.m">
#import "utils.h"
#import <Vision/Vision.h>

void logMessage(BOOL verbose, NSString *format, ...) {
    if (verbose) {
        va_list args;
        va_start(args, format);
        NSString *message = [[NSString alloc] initWithFormat:format arguments:args];
        va_end(args);
        fprintf(stderr, "%s\n", [message UTF8String]);
    }
}

BOOL parseScaleSpec(const char *spec, ScaleSpec *scale) {
    if (!spec || !scale) return NO;

    // Initialize scale
    memset(scale, 0, sizeof(ScaleSpec));
    scale->scaleFactor = 1.0; // Default to 100% if not specified otherwise

    NSString *specStr = [NSString stringWithUTF8String:spec];

    // Check for percentage (NNN%)
    if ([specStr hasSuffix:@"%"]) {
        NSString *numStr = [specStr substringToIndex:[specStr length] - 1];
        scale->scaleFactor = [numStr doubleValue] / 100.0;
        scale->isPercentage = YES;
        if (scale->scaleFactor <= 0) {
            reportError(@"Scale percentage must be positive.",
                       getTroubleshootingHint(@"scale format"));
            return NO;
        }
        return YES;
    }

    // Check for DPI (AAAdpi)
    if ([specStr hasSuffix:@"dpi"]) {
        NSString *numStr = [specStr substringToIndex:[specStr length] - 3];
        scale->dpi = [numStr doubleValue];
        scale->isDPI = YES;
        if (scale->dpi <= 0) {
            reportError(@"DPI value must be positive.",
                       getTroubleshootingHint(@"scale format"));
            return NO;
        }
        return YES;
    }

    // Check for dimensions (HHHxWWW, HHHx, xWWW)
    NSRange xRange = [specStr rangeOfString:@"x" options:NSCaseInsensitiveSearch]; // Case insensitive 'x'
    if (xRange.location != NSNotFound) {
        NSString *heightStr = @"";
        if (xRange.location > 0) {
            heightStr = [specStr substringToIndex:xRange.location];
        }
        NSString *widthStr = @"";
        if (xRange.location < [specStr length] - 1) {
            widthStr = [specStr substringFromIndex:xRange.location + 1];
        }

        if ([heightStr length] > 0) {
            scale->maxHeight = [heightStr doubleValue];
            if (scale->maxHeight <= 0) {
                fprintf(stderr, "Error: Height dimension must be positive.\n");
                return NO;
            }
            scale->hasHeight = YES;
        }

        if ([widthStr length] > 0) {
            scale->maxWidth = [widthStr doubleValue];
            if (scale->maxWidth <= 0) {
                fprintf(stderr, "Error: Width dimension must be positive.\n");
                return NO;
            }
            scale->hasWidth = YES;
        }

        return scale->hasHeight || scale->hasWidth;
    }

    // If no known suffix or 'x' separator, try to parse as a simple number (scale factor)
    // This makes "-s 2.0" work as scale factor 2.0
    NSScanner *scanner = [NSScanner scannerWithString:specStr];
    double factor;
    if ([scanner scanDouble:&factor] && [scanner isAtEnd]) {
        if (factor <= 0) {
            fprintf(stderr, "Error: Scale factor must be positive.\n");
            return NO;
        }
        scale->scaleFactor = factor;
        scale->isPercentage = NO; // Explicitly not a percentage
        scale->isDPI = NO;
        scale->hasWidth = NO;
        scale->hasHeight = NO;
        return YES;
    }

    fprintf(stderr, "Error: Invalid scale specification format: %s\n", spec);
    return NO;
}

NSData *readDataFromStdin(void) {
    NSMutableData *data = [NSMutableData data];
    char buffer[4096];
    size_t bytesRead;

    while ((bytesRead = fread(buffer, 1, sizeof(buffer), stdin)) > 0) {
        [data appendBytes:buffer length:bytesRead];
    }

    if (ferror(stdin)) {
        fprintf(stderr, "Error reading from stdin\n");
        return nil;
    }

    return data;
}

NSData *readPDFData(NSString *inputPath, BOOL verbose) {
    logMessage(verbose, @"Reading PDF data from: %@", inputPath ? inputPath : @"stdin");
    if (inputPath) {
        NSError *error = nil;
        NSData *data = [NSData dataWithContentsOfFile:inputPath options:0 error:&error];
        if (!data) {
            fprintf(stderr, "Error reading file %s: %s\n",
                    [inputPath UTF8String],
                    [[error localizedDescription] UTF8String]);
        }
        return data;
    } else {
        return readDataFromStdin();
    }
}

CGFloat calculateScaleFactor(ScaleSpec *scale, CGRect pageRect) {
    if (scale->isPercentage) {
        return scale->scaleFactor;
    }

    if (scale->isDPI) {
        // PDF points are 72 DPI by default
        return scale->dpi / 72.0;
    }

    // If only scaleFactor is set (e.g. from "-s 2.0")
    if (!scale->hasWidth && !scale->hasHeight && scale->scaleFactor > 0) {
        return scale->scaleFactor;
    }

    CGFloat scaleX = 1.0, scaleY = 1.0;

    if (scale->hasWidth && pageRect.size.width > 0) {
        scaleX = scale->maxWidth / pageRect.size.width;
    }

    if (scale->hasHeight && pageRect.size.height > 0) {
        scaleY = scale->maxHeight / pageRect.size.height;
    }

    if (scale->hasWidth && scale->hasHeight) { // HHHxWWW, fit to smallest
        return fmin(scaleX, scaleY);
    } else if (scale->hasWidth) { // xWWW
        return scaleX;
    } else if (scale->hasHeight) { // HHHx
        return scaleY;
    }

    return 1.0; // Default, should ideally be covered by isPercentage or direct scaleFactor
}

CGImageRef renderPDFPageToImage(CGPDFPageRef pdfPage, CGFloat scaleFactor, BOOL transparentBackground, BOOL verbose) {
    if (!pdfPage) return NULL;

    __block CGImageRef image = NULL;

    @autoreleasepool {
        logMessage(verbose, @"Rendering PDF page with scale factor: %.2f", scaleFactor);

        // Get page dimensions
        CGRect pageRect = CGPDFPageGetBoxRect(pdfPage, kCGPDFMediaBox);
        size_t width = (size_t)round(pageRect.size.width * scaleFactor);
        size_t height = (size_t)round(pageRect.size.height * scaleFactor);

        if (width == 0 || height == 0) {
            fprintf(stderr, "Error: Calculated image dimensions are zero (width: %zu, height: %zu). Check scale factor and PDF page size.\n", width, height);
            return NULL;
        }

        // Create bitmap context
        CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
        CGContextRef context = CGBitmapContextCreate(NULL, width, height, 8, 0, colorSpace,
                                                    kCGImageAlphaPremultipliedLast); // Changed to PremultipliedLast for better transparency handling
        CGColorSpaceRelease(colorSpace);

        if (!context) {
            fprintf(stderr, "Failed to create bitmap context\n");
            return NULL;
        }

        // Set background
        if (!transparentBackground) {
            CGContextSetRGBFillColor(context, 1.0, 1.0, 1.0, 1.0); // White
            CGContextFillRect(context, CGRectMake(0, 0, width, height));
        } else {
            CGContextClearRect(context, CGRectMake(0, 0, width, height)); // Transparent
        }

        // Save context state
        CGContextSaveGState(context);

        // Scale and translate for PDF rendering
        CGContextScaleCTM(context, scaleFactor, scaleFactor);
        // CGContextTranslateCTM(context, -pageRect.origin.x, -pageRect.origin.y); // This might be needed if cropbox/mediabox origin is not 0,0

        // Draw PDF page
        CGContextDrawPDFPage(context, pdfPage);

        // Restore context state
        CGContextRestoreGState(context);

        // Create image from context
        image = CGBitmapContextCreateImage(context);
        CGContextRelease(context);

        logMessage(verbose, @"Page rendered to CGImageRef successfully.");
    }

    return image;
}

BOOL writeImageAsPNG(CGImageRef image, NSFileHandle *output, int pngQuality, BOOL verbose) {
    if (!image || !output) return NO;

    logMessage(verbose, @"Writing image as PNG to stdout with quality: %d", pngQuality);

    NSMutableData *imageData = [NSMutableData data];
    CGImageDestinationRef destination = CGImageDestinationCreateWithData((__bridge CFMutableDataRef)imageData,
                                                                        kUTTypePNG, 1, NULL);
    if (!destination) {
        fprintf(stderr, "Failed to create image destination for stdout\n");
        return NO;
    }

    // PNG Quality/Compression
    // ImageIO uses a float from 0.0 (max compression) to 1.0 (lossless)
    // We need to map our 0-9 to this. Let's say 0 is max compression (0.0), 9 is min compression (0.9 for example)
    // Or, more simply, use kCGImageCompressionQuality which is what the quality parameter implies
    // For PNG, it's typically lossless, but some libraries might offer control over filter strategies or zlib level.
    // For now, let's assume higher 'pngQuality' means less compression effort (faster) if applicable,
    // or map to kCGImageDestinationLossyCompressionQuality if we were doing lossy.
    // Since PNG is lossless, this 'quality' might map to compression effort/speed.
    // The default is usually a good balance. Let's make it explicit if quality is not default (6).
    NSDictionary *props = nil;
    if (pngQuality >= 0 && pngQuality <= 9) { // Assuming 0-9, map to 0.0-1.0 for kCGImageDestinationLossyCompressionQuality if it were lossy
                                          // For PNG, this specific key might not do much, but let's keep it for future.
                                          // A value closer to 1.0 means less compression.
        // float compressionValue = (float)pngQuality / 9.0f;
        // props = @{(__bridge NSString *)kCGImageDestinationLossyCompressionQuality: @(compressionValue)};
        // For PNG, there isn't a direct "quality" setting like JPEG.
        // It's lossless. We can control things like interlace, filters, or zlib compression level,
        // but CGImageDestination doesn't expose these directly for PNGs.
        // So, pngQuality might be ignored here or we can log a message.
        logMessage(verbose, @"PNG quality setting (%d) is noted, but CoreGraphics offers limited control for PNG compression levels.", pngQuality);
    }


    CGImageDestinationAddImage(destination, image, (__bridge CFDictionaryRef)props);

    if (!CGImageDestinationFinalize(destination)) {
        fprintf(stderr, "Failed to finalize image for stdout\n");
        CFRelease(destination);
        return NO;
    }
    CFRelease(destination);

    @try {
        [output writeData:imageData];
    } @catch (NSException *exception) {
        fprintf(stderr, "Error writing PNG data to stdout: %s\n", [[exception reason] UTF8String]);
        return NO;
    }

    logMessage(verbose, @"Image written to stdout successfully.");
    return YES;
}

BOOL writeImageToFile(CGImageRef image, NSString *outputPath, int pngQuality, BOOL verbose, BOOL dryRun, BOOL forceOverwrite) {
    if (!image || !outputPath) return NO;

    if (dryRun) {
        // In dry-run mode, just report what would be created
        BOOL exists = fileExists(outputPath);
        fprintf(stdout, "[DRY-RUN] Would create: %s%s\n", [outputPath UTF8String],
                exists ? " (overwrites existing)" : "");

        // Calculate approximate file size for the image
        size_t width = CGImageGetWidth(image);
        size_t height = CGImageGetHeight(image);
        size_t bitsPerPixel = CGImageGetBitsPerPixel(image);
        size_t estimatedSize = (width * height * bitsPerPixel) / 8 / 1024; // KB

        fprintf(stdout, "          Dimensions: %zux%zu, Estimated size: ~%zu KB\n", width, height, estimatedSize);
        return YES;
    }

    // Check for overwrite protection
    if (!forceOverwrite && !shouldOverwriteFile(outputPath, YES)) {
        logMessage(verbose, @"Skipping %@ - file exists and overwrite denied", outputPath);
        return NO;
    }

    logMessage(verbose, @"Writing image as PNG to file: %@ with quality: %d", outputPath, pngQuality);

    NSURL *url = [NSURL fileURLWithPath:outputPath];
    CGImageDestinationRef destination = CGImageDestinationCreateWithURL((__bridge CFURLRef)url,
                                                                       kUTTypePNG, 1, NULL);
    if (!destination) {
        fprintf(stderr, "Failed to create image destination for file: %s\n", [outputPath UTF8String]);
        return NO;
    }

    NSDictionary *props = nil;
     if (pngQuality >= 0 && pngQuality <= 9) {
        logMessage(verbose, @"PNG quality setting (%d) is noted, but CoreGraphics offers limited control for PNG compression levels.", pngQuality);
    }

    CGImageDestinationAddImage(destination, image, (__bridge CFDictionaryRef)props);

    BOOL success = CGImageDestinationFinalize(destination);
    if (!success) {
        fprintf(stderr, "Failed to write image to file: %s\n", [outputPath UTF8String]);
    }

    CFRelease(destination);
    logMessage(verbose, @"Image written to file %@ %s.", outputPath, success ? "successfully" : "failed");
    return success;
}

NSString *getOutputPrefix(Options *options) {
    if (options->outputPath && ![options->outputPath isEqualToString:@"-"]) { // Treat "-" as stdout for prefix
        // If output path is a full filename (e.g., "image.png"), use "image"
        // If it's just a prefix (e.g., "img_"), use it as is.
        // For batch mode, -o is always a prefix.
        return [[options->outputPath lastPathComponent] stringByDeletingPathExtension];
    } else if (options->inputPath) {
        // Use basename of input file
        NSString *basename = [[options->inputPath lastPathComponent] stringByDeletingPathExtension];
        return basename;
    } else {
        return @"page"; // Default prefix if input is stdin and no output path
    }
}

// PDF operator callbacks (forward declarations)
static void pdf_Tj(CGPDFScannerRef scanner, void *info);
static void pdf_TJ(CGPDFScannerRef scanner, void *info);
static void pdf_Quote(CGPDFScannerRef scanner, void *info);
static void pdf_DoubleQuote(CGPDFScannerRef scanner, void *info);

NSString *extractTextFromPDFPage(CGPDFPageRef page) {
    if (!page) return nil;

    NSMutableString *pageText = [NSMutableString string];

    // Create a PDF Scanner
    CGPDFScannerRef scanner = NULL;
    CGPDFContentStreamRef contentStream = CGPDFContentStreamCreateWithPage(page);
    if (contentStream) {
        CGPDFOperatorTableRef operatorTable = CGPDFOperatorTableCreate();

        // Set up operator callbacks for text extraction
        CGPDFOperatorTableSetCallback(operatorTable, "Tj", &pdf_Tj);
        CGPDFOperatorTableSetCallback(operatorTable, "TJ", &pdf_TJ);
        CGPDFOperatorTableSetCallback(operatorTable, "'", &pdf_Quote);
        CGPDFOperatorTableSetCallback(operatorTable, "\"", &pdf_DoubleQuote);

        scanner = CGPDFScannerCreate(contentStream, operatorTable, (__bridge void *)pageText);
        if (scanner) {
            CGPDFScannerScan(scanner);
            CGPDFScannerRelease(scanner);
        }

        CGPDFOperatorTableRelease(operatorTable);
        CGPDFContentStreamRelease(contentStream);
    }

    // Clean up the text
    NSString *cleanedText = [pageText stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
    cleanedText = [cleanedText stringByReplacingOccurrencesOfString:@"\\s+" withString:@" "
                                                           options:NSRegularExpressionSearch
                                                             range:NSMakeRange(0, cleanedText.length)];

    return cleanedText.length > 0 ? cleanedText : nil;
}

// PDF operator callbacks
static void pdf_Tj(CGPDFScannerRef scanner, void *info) {
    CGPDFStringRef pdfString = NULL;
    if (CGPDFScannerPopString(scanner, &pdfString)) {
        NSString *string = (__bridge_transfer NSString *)CGPDFStringCopyTextString(pdfString);
        if (string) {
            NSMutableString *pageText = (__bridge NSMutableString *)info;
            [pageText appendString:string];
            [pageText appendString:@" "];
        }
    }
}

static void pdf_TJ(CGPDFScannerRef scanner, void *info) {
    CGPDFArrayRef array = NULL;
    if (CGPDFScannerPopArray(scanner, &array)) {
        size_t count = CGPDFArrayGetCount(array);
        NSMutableString *pageText = (__bridge NSMutableString *)info;

        for (size_t i = 0; i < count; i++) {
            CGPDFObjectRef object = NULL;
            if (CGPDFArrayGetObject(array, i, &object)) {
                CGPDFObjectType type = CGPDFObjectGetType(object);
                if (type == kCGPDFObjectTypeString) {
                    CGPDFStringRef pdfString = NULL;
                    if (CGPDFObjectGetValue(object, kCGPDFObjectTypeString, &pdfString)) {
                        NSString *string = (__bridge_transfer NSString *)CGPDFStringCopyTextString(pdfString);
                        if (string) {
                            [pageText appendString:string];
                        }
                    }
                }
            }
        }
        [pageText appendString:@" "];
    }
}

static void pdf_Quote(CGPDFScannerRef scanner, void *info) {
    pdf_Tj(scanner, info);
}

static void pdf_DoubleQuote(CGPDFScannerRef scanner, void *info) {
    // Skip the two numeric parameters
    CGPDFReal tc, tw;
    CGPDFScannerPopNumber(scanner, &tc);
    CGPDFScannerPopNumber(scanner, &tw);
    pdf_Tj(scanner, info);
}

NSString *performOCROnImage(CGImageRef image) {
    if (!image) return nil;

    __block NSString *recognizedText = nil;
    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);

    @autoreleasepool {
        // Create Vision request
        VNRecognizeTextRequest *request = [[VNRecognizeTextRequest alloc] initWithCompletionHandler:^(VNRequest *request, NSError *error) {
            if (error) {
                NSLog(@"OCR Error: %@", error.localizedDescription);
                dispatch_semaphore_signal(semaphore);
                return;
            }

            NSMutableString *fullText = [NSMutableString string];
            for (VNRecognizedTextObservation *observation in request.results) {
                VNRecognizedText *topCandidate = [observation topCandidates:1].firstObject;
                if (topCandidate) {
                    [fullText appendString:topCandidate.string];
                    [fullText appendString:@" "];
                }
            }

            recognizedText = [fullText stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
            dispatch_semaphore_signal(semaphore);
        }];

        request.recognitionLevel = VNRequestTextRecognitionLevelAccurate;
        request.recognitionLanguages = @[@"en-US"]; // Add more languages as needed
        request.usesLanguageCorrection = YES;

        // Create handler and perform request
        VNImageRequestHandler *handler = [[VNImageRequestHandler alloc] initWithCGImage:image options:@{}];
        NSError *error = nil;
        [handler performRequests:@[request] error:&error];

        if (error) {
            NSLog(@"Failed to perform OCR: %@", error.localizedDescription);
            dispatch_semaphore_signal(semaphore);
        }
    }

    // Wait for OCR to complete (with timeout)
    dispatch_semaphore_wait(semaphore, dispatch_time(DISPATCH_TIME_NOW, 5 * NSEC_PER_SEC));

    return recognizedText;
}

NSString *slugifyText(NSString *text, NSUInteger maxLength) {
    if (!text || text.length == 0) return @"";

    // Convert to lowercase
    NSString *lowercased = [text lowercaseString];

    // Replace non-alphanumeric characters with hyphens
    NSMutableString *slugified = [NSMutableString string];
    NSCharacterSet *alphanumeric = [NSCharacterSet alphanumericCharacterSet];

    BOOL lastWasHyphen = NO;
    for (NSUInteger i = 0; i < lowercased.length && slugified.length < maxLength; i++) {
        unichar ch = [lowercased characterAtIndex:i];

        if ([alphanumeric characterIsMember:ch]) {
            [slugified appendFormat:@"%C", ch];
            lastWasHyphen = NO;
        } else if (!lastWasHyphen && slugified.length > 0) {
            [slugified appendString:@"-"];
            lastWasHyphen = YES;
        }
    }

    // Remove trailing hyphen if present
    if ([slugified hasSuffix:@"-"]) {
        [slugified deleteCharactersInRange:NSMakeRange(slugified.length - 1, 1)];
    }

    // Truncate to maxLength
    if (slugified.length > maxLength) {
        NSString *truncated = [slugified substringToIndex:maxLength];
        // Remove partial word at end
        NSRange lastHyphen = [truncated rangeOfString:@"-" options:NSBackwardsSearch];
        if (lastHyphen.location != NSNotFound && lastHyphen.location > maxLength * 0.7) {
            truncated = [truncated substringToIndex:lastHyphen.location];
        }
        return truncated;
    }

    return slugified;
}

NSArray<NSNumber *> *parsePageRange(NSString *rangeSpec, NSUInteger totalPages) {
    if (!rangeSpec || rangeSpec.length == 0) {
        return nil;
    }

    NSMutableSet *pageSet = [NSMutableSet set];
    NSArray *parts = [rangeSpec componentsSeparatedByString:@","];

    for (NSString *part in parts) {
        NSString *trimmedPart = [part stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];

        // Check if it's a range (contains hyphen)
        NSRange hyphenRange = [trimmedPart rangeOfString:@"-"];
        if (hyphenRange.location != NSNotFound) {
            // Split range into start and end
            NSArray *rangeParts = [trimmedPart componentsSeparatedByString:@"-"];
            if (rangeParts.count == 2) {
                NSInteger start = [rangeParts[0] integerValue];
                NSInteger end = [rangeParts[1] integerValue];

                // Validate range
                if (start < 1) start = 1;
                if (end > (NSInteger)totalPages) end = (NSInteger)totalPages;

                if (start <= end) {
                    for (NSInteger i = start; i <= end; i++) {
                        [pageSet addObject:@(i)];
                    }
                }
            }
        } else {
            // Single page number
            NSInteger pageNum = [trimmedPart integerValue];
            if (pageNum >= 1 && pageNum <= (NSInteger)totalPages) {
                [pageSet addObject:@(pageNum)];
            }
        }
    }

    // Convert set to sorted array
    NSArray *sortedPages = [[pageSet allObjects] sortedArrayUsingComparator:^NSComparisonResult(NSNumber *obj1, NSNumber *obj2) {
        return [obj1 compare:obj2];
    }];

    return sortedPages;
}

NSString *formatFilenameWithPattern(NSString *pattern, NSString *basename, NSUInteger pageNum,
                                   NSUInteger totalPages, NSString *extractedText) {
    if (!pattern || pattern.length == 0) {
        // Default pattern if none specified
        if (extractedText && extractedText.length > 0) {
            return [NSString stringWithFormat:@"%@-%03zu--%@", basename, pageNum, extractedText];
        } else {
            return [NSString stringWithFormat:@"%@-%03zu", basename, pageNum];
        }
    }

    NSMutableString *result = [NSMutableString stringWithString:pattern];

    // Replace {basename} or {name}
    [result replaceOccurrencesOfString:@"{basename}" withString:basename
                              options:0 range:NSMakeRange(0, result.length)];
    [result replaceOccurrencesOfString:@"{name}" withString:basename
                              options:0 range:NSMakeRange(0, result.length)];

    // Replace {page} with zero-padded page number
    NSUInteger digits = (NSUInteger)log10(totalPages > 0 ? totalPages : 1) + 1;
    if (digits < 3) digits = 3; // Minimum 3 digits
    NSString *pageStr = [NSString stringWithFormat:@"%0*zu", (int)digits, pageNum];
    [result replaceOccurrencesOfString:@"{page}" withString:pageStr
                              options:0 range:NSMakeRange(0, result.length)];

    // Replace {page:03d} style formatting
    NSRegularExpression *pageFormatRegex = [NSRegularExpression regularExpressionWithPattern:@"\\{page:0?(\\d+)d\\}"
                                                                                    options:0 error:nil];
    NSArray *matches = [pageFormatRegex matchesInString:result options:0
                                               range:NSMakeRange(0, result.length)];

    // Process matches in reverse order to avoid index shifting
    for (NSTextCheckingResult *match in [matches reverseObjectEnumerator]) {
        NSRange digitRange = [match rangeAtIndex:1];
        NSString *digitStr = [result substringWithRange:digitRange];
        int formatDigits = [digitStr intValue];
        NSString *formattedPage = [NSString stringWithFormat:@"%0*zu", formatDigits, pageNum];
        [result replaceCharactersInRange:match.range withString:formattedPage];
    }

    // Replace {text} with extracted text (if available)
    if (extractedText && extractedText.length > 0) {
        [result replaceOccurrencesOfString:@"{text}" withString:extractedText
                                  options:0 range:NSMakeRange(0, result.length)];
    } else {
        [result replaceOccurrencesOfString:@"{text}" withString:@""
                                  options:0 range:NSMakeRange(0, result.length)];
    }

    // Replace {date} with current date in YYYYMMDD format
    NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];
    [dateFormatter setDateFormat:@"yyyyMMdd"];
    NSString *dateStr = [dateFormatter stringFromDate:[NSDate date]];
    [result replaceOccurrencesOfString:@"{date}" withString:dateStr
                              options:0 range:NSMakeRange(0, result.length)];

    // Replace {time} with current time in HHMMSS format
    [dateFormatter setDateFormat:@"HHmmss"];
    NSString *timeStr = [dateFormatter stringFromDate:[NSDate date]];
    [result replaceOccurrencesOfString:@"{time}" withString:timeStr
                              options:0 range:NSMakeRange(0, result.length)];

    // Replace {total} with total page count
    [result replaceOccurrencesOfString:@"{total}" withString:[NSString stringWithFormat:@"%zu", totalPages]
                              options:0 range:NSMakeRange(0, result.length)];

    return result;
}

// File overwrite protection functions
BOOL fileExists(NSString *path) {
    return [[NSFileManager defaultManager] fileExistsAtPath:path];
}

BOOL shouldOverwriteFile(NSString *path, BOOL interactive) {
    if (!fileExists(path)) {
        return YES; // File doesn't exist, safe to write
    }

    if (!interactive) {
        return NO; // Non-interactive mode, don't overwrite
    }

    return promptUserForOverwrite(path);
}

BOOL promptUserForOverwrite(NSString *path) {
    fprintf(stderr, "File '%s' already exists. Overwrite? (y/N): ", [path UTF8String]);
    fflush(stderr);

    char response[10];
    if (fgets(response, sizeof(response), stdin) == NULL) {
        return NO; // No input, default to no
    }

    // Check first character, case insensitive
    char first = response[0];
    return (first == 'y' || first == 'Y');
}

// Enhanced error reporting functions
void reportError(NSString *message, NSString *troubleshootingHint) {
    fprintf(stderr, "Error: %s\n", [message UTF8String]);
    if (troubleshootingHint) {
        fprintf(stderr, "Hint:  %s\n", [troubleshootingHint UTF8String]);
    }
}

void reportWarning(NSString *message, NSString *troubleshootingHint) {
    fprintf(stderr, "Warning: %s\n", [message UTF8String]);
    if (troubleshootingHint) {
        fprintf(stderr, "Hint:    %s\n", [troubleshootingHint UTF8String]);
    }
}

NSString *getTroubleshootingHint(NSString *errorContext) {
    if (!errorContext) return nil;

    NSString *context = [errorContext lowercaseString];

    // PDF-related errors
    if ([context containsString:@"pdf"] || [context containsString:@"document"]) {
        if ([context containsString:@"encrypted"] || [context containsString:@"password"]) {
            return @"PDF is password-protected. Try removing the password first using Preview or pdftk.";
        }
        if ([context containsString:@"corrupt"] || [context containsString:@"invalid"]) {
            return @"PDF file may be corrupted. Try opening it in Preview to verify it's readable.";
        }
        if ([context containsString:@"empty"] || [context containsString:@"no pages"]) {
            return @"PDF appears to be empty or has no pages to convert.";
        }
        return @"Verify the PDF file is valid and readable in Preview or other PDF viewers.";
    }

    // File I/O errors
    if ([context containsString:@"permission"] || [context containsString:@"denied"]) {
        return @"Check file permissions. You may need to use 'sudo' or change file ownership.";
    }
    if ([context containsString:@"not found"] || [context containsString:@"no such file"]) {
        return @"Verify the file path is correct and the file exists. Use absolute paths to avoid confusion.";
    }
    if ([context containsString:@"disk"] || [context containsString:@"space"]) {
        return @"Check available disk space. Large PDFs can require significant storage for conversion.";
    }

    // Memory errors
    if ([context containsString:@"memory"] || [context containsString:@"allocation"]) {
        return @"Try processing fewer pages at once or use a smaller scale factor to reduce memory usage.";
    }

    // Image/rendering errors
    if ([context containsString:@"image"] || [context containsString:@"render"]) {
        return @"Try using a smaller scale factor or lower DPI setting to reduce image complexity.";
    }

    // Scale/format errors
    if ([context containsString:@"scale"] || [context containsString:@"format"]) {
        return @"Use formats like '150%', '2.0', '800x600', or '300dpi'. See --help for examples.";
    }

    // Page range errors
    if ([context containsString:@"page"] || [context containsString:@"range"]) {
        return @"Use formats like '5' (single page), '1-10' (range), or '1,3,5-10' (list). Pages start at 1.";
    }

    return @"Run with -v/--verbose flag for more detailed information, or check --help for usage examples.";
}
</file>

<file path="archive/objc/pdf22png-objc/Tests/test_runner.m">
#import <Foundation/Foundation.h>
#import "../src/utils.h"
#import "../src/pdf22png.h"

// Simple test framework macros
#define TEST_ASSERT(condition, message) \
    if (!(condition)) { \
        NSLog(@"FAIL: %s - %@", __FUNCTION__, message); \
        return NO; \
    }

#define TEST_ASSERT_EQUAL(actual, expected, message) \
    if ((actual) != (expected)) { \
        NSLog(@"FAIL: %s - %@. Expected: %@, Actual: %@", __FUNCTION__, message, @(expected), @(actual)); \
        return NO; \
    }

#define TEST_ASSERT_EQUAL_FLOAT(actual, expected, accuracy, message) \
    if (fabs((actual) - (expected)) > (accuracy)) { \
        NSLog(@"FAIL: %s - %@. Expected: %f, Actual: %f", __FUNCTION__, message, (expected), (actual)); \
        return NO; \
    }

// Test function declarations
BOOL testParseScaleSpec_percentage(void);
BOOL testParseScaleSpec_factor(void);
BOOL testParseScaleSpec_dpi(void);
BOOL testParseScaleSpec_dimensions(void);
BOOL testParseScaleSpec_invalid(void);
BOOL testParsePageRange(void);
BOOL testExtractTextFromPDFPage(void);
BOOL testFileExists(void);
BOOL testShouldOverwriteFile(void);

// Test implementations
BOOL testParseScaleSpec_percentage(void) {
    ScaleSpec scale;
    BOOL result = parseScaleSpec("150%", &scale);
    TEST_ASSERT(result, @"Parsing '150%' should succeed");
    TEST_ASSERT(scale.isPercentage, @"Scale should be percentage");
    TEST_ASSERT_EQUAL_FLOAT(scale.scaleFactor, 1.5, 0.001, @"Scale factor should be 1.5");
    TEST_ASSERT(!scale.isDPI, @"Scale should not be DPI");
    return YES;
}

BOOL testParseScaleSpec_factor(void) {
    ScaleSpec scale;
    BOOL result = parseScaleSpec("2.0", &scale);
    TEST_ASSERT(result, @"Parsing '2.0' should succeed");
    TEST_ASSERT(!scale.isPercentage, @"Scale should not be percentage");
    TEST_ASSERT_EQUAL_FLOAT(scale.scaleFactor, 2.0, 0.001, @"Scale factor should be 2.0");
    return YES;
}

BOOL testParseScaleSpec_dpi(void) {
    ScaleSpec scale;
    BOOL result = parseScaleSpec("300dpi", &scale);
    TEST_ASSERT(result, @"Parsing '300dpi' should succeed");
    TEST_ASSERT(scale.isDPI, @"Scale should be DPI");
    TEST_ASSERT_EQUAL_FLOAT(scale.dpi, 300.0, 0.001, @"DPI should be 300");
    return YES;
}

BOOL testParseScaleSpec_dimensions(void) {
    ScaleSpec scale;

    // Test height only (pattern: "heightx")
    BOOL result = parseScaleSpec("800x", &scale);
    TEST_ASSERT(result, @"Parsing '800x' should succeed");
    TEST_ASSERT(!scale.hasWidth, @"Should not have width");
    TEST_ASSERT(scale.hasHeight, @"Should have height");
    TEST_ASSERT_EQUAL_FLOAT(scale.maxHeight, 800.0, 0.001, @"Height should be 800");

    // Test width only (pattern: "xwidth")
    result = parseScaleSpec("x600", &scale);
    TEST_ASSERT(result, @"Parsing 'x600' should succeed");
    TEST_ASSERT(scale.hasWidth, @"Should have width");
    TEST_ASSERT(!scale.hasHeight, @"Should not have height");
    TEST_ASSERT_EQUAL_FLOAT(scale.maxWidth, 600.0, 0.001, @"Width should be 600");

    // Test both dimensions (pattern: "heightxwidth")
    result = parseScaleSpec("800x600", &scale);
    TEST_ASSERT(result, @"Parsing '800x600' should succeed");
    TEST_ASSERT(scale.hasWidth, @"Should have width");
    TEST_ASSERT(scale.hasHeight, @"Should have height");
    TEST_ASSERT_EQUAL_FLOAT(scale.maxHeight, 800.0, 0.001, @"Height should be 800");
    TEST_ASSERT_EQUAL_FLOAT(scale.maxWidth, 600.0, 0.001, @"Width should be 600");

    return YES;
}

BOOL testParseScaleSpec_invalid(void) {
    ScaleSpec scale;
    BOOL result = parseScaleSpec("invalid", &scale);
    TEST_ASSERT(!result, @"Parsing 'invalid' should fail");
    return YES;
}

BOOL testParsePageRange(void) {
    // Test simple single page
    NSArray *pages = parsePageRange(@"5", 10);
    TEST_ASSERT(pages != nil, @"parsePageRange should return array");
    TEST_ASSERT_EQUAL(pages.count, 1, @"Should have 1 page");
    TEST_ASSERT_EQUAL([pages[0] integerValue], 5, @"Page should be 5");

    // Test range
    pages = parsePageRange(@"1-3", 10);
    TEST_ASSERT(pages != nil, @"parsePageRange should return array");
    TEST_ASSERT_EQUAL(pages.count, 3, @"Should have 3 pages");
    TEST_ASSERT_EQUAL([pages[0] integerValue], 1, @"First page should be 1");
    TEST_ASSERT_EQUAL([pages[2] integerValue], 3, @"Last page should be 3");

    // Test comma separated
    pages = parsePageRange(@"1,3,5", 10);
    TEST_ASSERT(pages != nil, @"parsePageRange should return array");
    TEST_ASSERT_EQUAL(pages.count, 3, @"Should have 3 pages");
    TEST_ASSERT_EQUAL([pages[1] integerValue], 3, @"Second page should be 3");

    // Test complex
    pages = parsePageRange(@"1-3,5,7-9", 10);
    TEST_ASSERT(pages != nil, @"parsePageRange should return array");
    TEST_ASSERT_EQUAL(pages.count, 7, @"Should have 7 pages");

    return YES;
}

BOOL testExtractTextFromPDFPage(void) {
    // This test would require a real PDF, so we'll just verify the function exists
    NSString *result = extractTextFromPDFPage(nil);
    TEST_ASSERT(result == nil, @"Should return nil for nil page");
    return YES;
}

BOOL testFileExists(void) {
    // Test with non-existent file
    TEST_ASSERT(!fileExists(@"/path/that/does/not/exist"), @"Should return NO for non-existent file");

    // Test with a file that should exist (create a temp file)
    NSString *tempPath = [NSTemporaryDirectory() stringByAppendingPathComponent:@"test_file.txt"];
    [@"test" writeToFile:tempPath atomically:YES encoding:NSUTF8StringEncoding error:nil];
    TEST_ASSERT(fileExists(tempPath), @"Should return YES for existing temp file");
    [[NSFileManager defaultManager] removeItemAtPath:tempPath error:nil];

    return YES;
}

BOOL testShouldOverwriteFile(void) {
    // Test with non-existent file
    TEST_ASSERT(shouldOverwriteFile(@"/path/that/does/not/exist", NO), @"Should allow writing to non-existent file");
    TEST_ASSERT(shouldOverwriteFile(@"/path/that/does/not/exist", YES), @"Should allow writing to non-existent file");

    // Test with existing file in non-interactive mode
    NSString *tempPath = [NSTemporaryDirectory() stringByAppendingPathComponent:@"test_file2.txt"];
    [@"test" writeToFile:tempPath atomically:YES encoding:NSUTF8StringEncoding error:nil];
    TEST_ASSERT(!shouldOverwriteFile(tempPath, NO), @"Should not overwrite existing file in non-interactive mode");
    [[NSFileManager defaultManager] removeItemAtPath:tempPath error:nil];

    return YES;
}

// Main test runner
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        NSLog(@"Running pdf22png tests...");

        int passed = 0;
        int failed = 0;

        // Define test cases
        typedef BOOL (*TestFunction)(void);
        typedef struct {
            const char *name;
            TestFunction func;
        } TestCase;

        TestCase tests[] = {
            {"testParseScaleSpec_percentage", testParseScaleSpec_percentage},
            {"testParseScaleSpec_factor", testParseScaleSpec_factor},
            {"testParseScaleSpec_dpi", testParseScaleSpec_dpi},
            {"testParseScaleSpec_dimensions", testParseScaleSpec_dimensions},
            {"testParseScaleSpec_invalid", testParseScaleSpec_invalid},
            {"testParsePageRange", testParsePageRange},
            {"testExtractTextFromPDFPage", testExtractTextFromPDFPage},
            {"testFileExists", testFileExists},
            {"testShouldOverwriteFile", testShouldOverwriteFile},
        };

        int numTests = sizeof(tests) / sizeof(tests[0]);

        for (int i = 0; i < numTests; i++) {
            NSLog(@"Running %s...", tests[i].name);
            if (tests[i].func()) {
                NSLog(@"PASS: %s", tests[i].name);
                passed++;
            } else {
                failed++;
            }
        }

        NSLog(@"\n====================");
        NSLog(@"Test Results:");
        NSLog(@"  Passed: %d", passed);
        NSLog(@"  Failed: %d", failed);
        NSLog(@"  Total:  %d", passed + failed);
        NSLog(@"====================");

        return failed > 0 ? 1 : 0;
    }
}
</file>

<file path="archive/objc/pdf22png-objc/llms.txt">
This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
scripts/
  test-objc.sh
src/
  errors.h
  pdf22png.h
  pdf22png.m
  utils.h
  utils.m
Tests/
  test_runner.m
Makefile
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="scripts/test-objc.sh">
#!/bin/bash
# Test script for Objective-C version of pdf22png

set -e

echo "Testing pdf22png Objective-C implementation..."

# Create a simple test PDF using PostScript
cat > test.ps << 'EOF'
%!PS-Adobe-3.0
%%BoundingBox: 0 0 612 792
%%Pages: 2
%%EndComments

%%Page: 1 1
/Helvetica findfont 40 scalefont setfont
100 400 moveto
(Test Page 1) show
showpage

%%Page: 2 2  
/Helvetica findfont 40 scalefont setfont
100 400 moveto
(Test Page 2) show
showpage

%%EOF
EOF

# Convert PS to PDF
ps2pdf test.ps test.pdf

# Build if not already built
if [ ! -f ./build/pdf22png-objc ]; then
    echo "Building Objective-C version..."
    make objc
fi

echo ""
echo "Running tests..."
echo "==============="

# Test 1: Basic conversion
echo "Test 1: Basic single page conversion"
./build/pdf22png-objc test.pdf test-output.png
if [ -f test-output.png ]; then
    echo "✓ Basic conversion successful"
    rm test-output.png
else
    echo "✗ Basic conversion failed"
fi

# Test 2: Specific page
echo ""
echo "Test 2: Convert page 2"
./build/pdf22png-objc -p 2 test.pdf test-page2.png
if [ -f test-page2.png ]; then
    echo "✓ Page selection successful"
    rm test-page2.png
else
    echo "✗ Page selection failed"
fi

# Test 3: Scaling
echo ""
echo "Test 3: Scale to 200%"
./build/pdf22png-objc -s 200% test.pdf test-scaled.png
if [ -f test-scaled.png ]; then
    echo "✓ Scaling successful"
    rm test-scaled.png
else
    echo "✗ Scaling failed"
fi

# Test 4: DPI setting
echo ""
echo "Test 4: Convert at 300 DPI"
./build/pdf22png-objc -r 300 test.pdf test-300dpi.png
if [ -f test-300dpi.png ]; then
    echo "✓ DPI setting successful"
    rm test-300dpi.png
else
    echo "✗ DPI setting failed"
fi

# Test 5: Batch mode
echo ""
echo "Test 5: Batch conversion"
mkdir -p test-batch
./build/pdf22png-objc -a -d test-batch test.pdf
if [ -f test-batch/test-001.png ] && [ -f test-batch/test-002.png ]; then
    echo "✓ Batch conversion successful"
    rm -rf test-batch
else
    echo "✗ Batch conversion failed"
fi

# Test 6: Dry run
echo ""
echo "Test 6: Dry run mode"
./build/pdf22png-objc -D test.pdf test-dryrun.png > /dev/null 2>&1
if [ ! -f test-dryrun.png ]; then
    echo "✓ Dry run successful (no file created)"
else
    echo "✗ Dry run failed (file was created)"
    rm test-dryrun.png
fi

# Test 7: stdin/stdout
echo ""
echo "Test 7: stdin to stdout"
cat test.pdf | ./build/pdf22png-objc - - > test-stdio.png 2>/dev/null
if [ -f test-stdio.png ] && [ -s test-stdio.png ]; then
    echo "✓ stdin/stdout successful"
    rm test-stdio.png
else
    echo "✗ stdin/stdout failed"
fi

# Test 8: Help
echo ""
echo "Test 8: Help message"
if ./build/pdf22png-objc -h 2>&1 | grep -q "Usage:"; then
    echo "✓ Help message displayed"
else
    echo "✗ Help message failed"
fi

# Cleanup
rm -f test.ps test.pdf

echo ""
echo "==============="
echo "Tests complete!"
</file>

<file path="src/errors.h">
#ifndef PDF22PNG_ERRORS_H
#define PDF22PNG_ERRORS_H

// Error codes for pdf22png
typedef enum {
    PDF22PNG_SUCCESS = 0,
    PDF22PNG_ERROR_GENERAL = 1,
    PDF22PNG_ERROR_INVALID_ARGS = 2,
    PDF22PNG_ERROR_FILE_NOT_FOUND = 3,
    PDF22PNG_ERROR_FILE_READ = 4,
    PDF22PNG_ERROR_FILE_WRITE = 5,
    PDF22PNG_ERROR_NO_INPUT = 6,
    PDF22PNG_ERROR_INVALID_PDF = 7,
    PDF22PNG_ERROR_ENCRYPTED_PDF = 8,
    PDF22PNG_ERROR_EMPTY_PDF = 9,
    PDF22PNG_ERROR_PAGE_NOT_FOUND = 10,
    PDF22PNG_ERROR_RENDER_FAILED = 11,
    PDF22PNG_ERROR_MEMORY = 12,
    PDF22PNG_ERROR_OUTPUT_DIR = 13,
    PDF22PNG_ERROR_INVALID_SCALE = 14,
    PDF22PNG_ERROR_BATCH_FAILED = 15
} PDF22PNGError;

// Error messages
static const char* PDF22PNG_ERROR_MESSAGES[] = {
    "Success",
    "General error",
    "Invalid command line arguments",
    "Input file not found",
    "Failed to read input file",
    "Failed to write output file",
    "No input data received",
    "Invalid PDF document",
    "PDF document is encrypted (password-protected PDFs not supported)",
    "PDF document has no pages",
    "Requested page does not exist",
    "Failed to render PDF page",
    "Memory allocation failed",
    "Failed to create output directory",
    "Invalid scale specification",
    "Batch processing failed"
};

// Function to get error message
static inline const char* pdf22png_error_string(PDF22PNGError error) {
    if (error >= 0 && error <= PDF22PNG_ERROR_BATCH_FAILED) {
        return PDF22PNG_ERROR_MESSAGES[error];
    }
    return "Unknown error";
}

// Macro for error reporting with file and line info
#define PDF22PNG_ERROR(code, ...) do { \
    fprintf(stderr, "Error: %s\n", pdf22png_error_string(code)); \
    if (##__VA_ARGS__) { \
        fprintf(stderr, "Details: "); \
        fprintf(stderr, ##__VA_ARGS__); \
        fprintf(stderr, "\n"); \
    } \
} while(0)

#endif // PDF22PNG_ERRORS_H
</file>

<file path="src/pdf22png.h">
#import <Foundation/Foundation.h>
#import <Quartz/Quartz.h>
#import <ImageIO/ImageIO.h>
#import "errors.h"

// Structures from pdf22png.m
typedef struct {
    CGFloat scaleFactor;
    CGFloat maxWidth;
    CGFloat maxHeight;
    CGFloat dpi;
    BOOL isPercentage;
    BOOL isDPI;
    BOOL hasWidth;
    BOOL hasHeight;
} ScaleSpec;

typedef struct {
    ScaleSpec scale;
    NSInteger pageNumber;
    NSString *inputPath;
    NSString *outputPath;
    NSString *outputDirectory;
    BOOL batchMode;
    // Recommended additions for new features from README
    BOOL transparentBackground;
    int pngQuality; // 0-9
    BOOL verbose;
    BOOL includeText; // Include extracted text in filename
    NSString *pageRange; // Page range specification (e.g., "1-5,10,15-20")
    BOOL dryRun; // Preview operations without writing files
    NSString *namingPattern; // Custom naming pattern with placeholders
    BOOL forceOverwrite; // Force overwrite without prompting
} Options;

// Function prototypes from pdf22png.m that should remain in main logic
void printUsage(const char *programName);
Options parseArguments(int argc, const char *argv[]);
BOOL processSinglePage(CGPDFDocumentRef pdfDocument, Options *options);
BOOL processBatchMode(CGPDFDocumentRef pdfDocument, Options *options);

// Potentially new functions based on README advanced options
// These would be implemented in pdf22png.m
// void handleTransparency(CGContextRef context, Options* options); // Example if needed
// void setPNGCompression(CGImageDestinationRef dest, Options* options); // Example if needed

// Main function declaration (though it's standard)
int main(int argc, const char *argv[]);
</file>

<file path="src/pdf22png.m">
#import "pdf22png.h"
#import "utils.h"
#import <getopt.h>
#import <signal.h>

// Global variable for signal handling
static volatile sig_atomic_t g_shouldTerminate = 0;

// Signal handler for graceful shutdown
void signalHandler(int sig) {
    g_shouldTerminate = 1;
    fprintf(stderr, "\nReceived signal %d, finishing current operations...\n", sig);
}

// Define long options for getopt_long
static struct option long_options[] = {
    {"page", required_argument, 0, 'p'},
    {"all", no_argument, 0, 'a'}, // New: for batch mode without needing -d
    {"resolution", required_argument, 0, 'r'}, // Maps to -s Ndpi
    {"scale", required_argument, 0, 's'},
    {"transparent", no_argument, 0, 't'},
    {"quality", required_argument, 0, 'q'},
    {"verbose", no_argument, 0, 'v'},
    {"name", no_argument, 0, 'n'}, // Include text in filename
    {"pattern", required_argument, 0, 'P'}, // Custom naming pattern
    {"dry-run", no_argument, 0, 'D'}, // Preview operations without writing
    {"force", no_argument, 0, 'f'}, // Force overwrite without prompting
    {"help", no_argument, 0, 'h'},
    {"output", required_argument, 0, 'o'}, // For consistency with other tools
    {"directory", required_argument, 0, 'd'}, // For batch output directory
    {0, 0, 0, 0}
};

void printUsage(const char *programName) {
    fprintf(stderr, "Usage: %s [OPTIONS] <input.pdf> [output.png | output_%%03d.png]\n", programName);
    fprintf(stderr, "Converts PDF documents to PNG images.\n\n");
    fprintf(stderr, "Options:\n");
    fprintf(stderr, "  -p, --page <spec>       Page(s) to convert. Single page, range, or comma-separated.\n");
    fprintf(stderr, "                          Examples: 1 | 1-5 | 1,3,5-10 (default: 1)\n");
    fprintf(stderr, "                          In batch mode, only specified pages are converted.\n");
    fprintf(stderr, "  -a, --all               Convert all pages. If -d is not given, uses input filename as prefix.\n");
    fprintf(stderr, "                          Output files named <prefix>-<page_num>.png.\n");
    fprintf(stderr, "  -r, --resolution <dpi>  Set output DPI (e.g., 150dpi). Overrides -s if both used with numbers.\n");
    fprintf(stderr, "  -s, --scale <spec>      Scaling specification (default: 100%% or 1.0).\n");
    fprintf(stderr, "                            NNN%%: percentage (e.g., 150%%)\n");
    fprintf(stderr, "                            N.N:  scale factor (e.g., 1.5)\n");
    fprintf(stderr, "                            WxH:  fit to WxH pixels (e.g., 800x600)\n");
    fprintf(stderr, "                            Wx:   fit to width W pixels (e.g., 1024x)\n");
    fprintf(stderr, "                            xH:   fit to height H pixels (e.g., x768)\n");
    // fprintf(stderr, "                            Ndpi: dots per inch (e.g., 300dpi) - use -r for this\n");
    fprintf(stderr, "  -t, --transparent       Preserve transparency (default: white background).\n");
    fprintf(stderr, "  -q, --quality <n>       PNG compression quality (0-9, default: 6). Currently informational.\n");
    fprintf(stderr, "  -o, --output <path>     Output PNG file or prefix for batch mode.\n");
    fprintf(stderr, "                          If '-', output to stdout (single page mode only).\n");
    fprintf(stderr, "  -d, --directory <dir>   Output directory for batch mode (converts all pages).\n");
    fprintf(stderr, "                          If used, -o specifies filename prefix inside this directory.\n");
    fprintf(stderr, "  -v, --verbose           Verbose output.\n");
    fprintf(stderr, "  -n, --name              Include extracted text in output filename (batch mode only).\n");
    fprintf(stderr, "  -P, --pattern <pat>     Custom naming pattern for batch mode. Placeholders:\n");
    fprintf(stderr, "                          {basename} - Input filename without extension\n");
    fprintf(stderr, "                          {page} - Page number (auto-padded)\n");
    fprintf(stderr, "                          {page:03d} - Page with custom padding\n");
    fprintf(stderr, "                          {text} - Extracted text (requires -n)\n");
    fprintf(stderr, "                          {date} - Current date (YYYYMMDD)\n");
    fprintf(stderr, "                          {time} - Current time (HHMMSS)\n");
    fprintf(stderr, "                          {total} - Total page count\n");
    fprintf(stderr, "                          Example: '{basename}_p{page:04d}_of_{total}'\n");
    fprintf(stderr, "  -D, --dry-run           Preview operations without writing files.\n");
    fprintf(stderr, "  -f, --force             Force overwrite existing files without prompting.\n");
    fprintf(stderr, "  -h, --help              Show this help message and exit.\n\n");
    fprintf(stderr, "Arguments:\n");
    fprintf(stderr, "  <input.pdf>             Input PDF file. If '-', reads from stdin.\n");
    fprintf(stderr, "  [output.png]            Output PNG file. Required if not using -o or -d.\n");
    fprintf(stderr, "                          If input is stdin and output is not specified, output goes to stdout.\n");
    fprintf(stderr, "                          In batch mode (-a or -d), this is used as a prefix if -o is not set.\n");
}

Options parseArguments(int argc, const char *argv[]) {
    Options options = {
        .scale = {.scaleFactor = 1.0, .isPercentage = YES, .dpi = 144}, // Default DPI is 144 from README
        .pageNumber = 1,
        .inputPath = nil,
        .outputPath = nil,
        .outputDirectory = nil,
        .batchMode = NO,
        .transparentBackground = NO,
        .pngQuality = 6, // Default PNG quality
        .verbose = NO,
        .includeText = NO,
        .pageRange = nil,
        .dryRun = NO,
        .namingPattern = nil,
        .forceOverwrite = NO
    };

    int opt;
    int option_index = 0;
    BOOL scale_explicitly_set = NO;
    BOOL resolution_explicitly_set = NO;

    // Suppress getopt's default error messages
    // opterr = 0;

    while ((opt = getopt_long(argc, (char *const *)argv, "p:ar:s:tq:o:d:vnP:Dfh", long_options, &option_index)) != -1) {
        switch (opt) {
            case 'p': {
                options.pageRange = [NSString stringWithUTF8String:optarg];
                // For single page mode compatibility, try to parse as simple number
                NSScanner *scanner = [NSScanner scannerWithString:options.pageRange];
                NSInteger singlePage;
                if ([scanner scanInteger:&singlePage] && [scanner isAtEnd]) {
                    options.pageNumber = singlePage;
                    if (options.pageNumber < 1) {
                        fprintf(stderr, "Error: Invalid page number: %s. Must be >= 1.\n", optarg);
                        exit(1);
                    }
                } else {
                    // It's a range or list, will be parsed later
                    options.pageNumber = 0; // Indicates range mode
                }
                break;
            }
            case 'a':
                options.batchMode = YES;
                break;
            case 'r': {
                NSString* resStr = [NSString stringWithUTF8String:optarg];
                if (![resStr hasSuffix:@"dpi"]) { // Ensure it's passed as Ndpi, or assume dpi
                    resStr = [resStr stringByAppendingString:@"dpi"];
                }
                if (!parseScaleSpec([resStr UTF8String], &options.scale)) {
                    fprintf(stderr, "Error: Invalid resolution specification: %s\n", optarg);
                    printUsage(argv[0]);
                    exit(1);
                }
                resolution_explicitly_set = YES;
                break;
            }
            case 's':
                if (!parseScaleSpec(optarg, &options.scale)) {
                    reportError([NSString stringWithFormat:@"Invalid scale specification: %s", optarg],
                               getTroubleshootingHint(@"scale format"));
                    printUsage(argv[0]);
                    exit(1);
                }
                scale_explicitly_set = YES;
                break;
            case 't':
                options.transparentBackground = YES;
                break;
            case 'q':
                options.pngQuality = atoi(optarg);
                if (options.pngQuality < 0 || options.pngQuality > 9) {
                    fprintf(stderr, "Error: Invalid PNG quality: %s. Must be between 0 and 9.\n", optarg);
                    exit(1);
                }
                break;
            case 'o':
                options.outputPath = [NSString stringWithUTF8String:optarg];
                break;
            case 'd':
                options.outputDirectory = [NSString stringWithUTF8String:optarg];
                options.batchMode = YES; // -d implies batch mode
                break;
            case 'v':
                options.verbose = YES;
                break;
            case 'n':
                options.includeText = YES;
                break;
            case 'P':
                options.namingPattern = [NSString stringWithUTF8String:optarg];
                break;
            case 'D':
                options.dryRun = YES;
                break;
            case 'f':
                options.forceOverwrite = YES;
                break;
            case 'h':
                printUsage(argv[0]);
                exit(0);
            case '?': // Unknown option or missing argument
                // getopt_long already prints an error message if opterr is not 0
                // fprintf(stderr, "Error: Unknown option or missing argument.\n");
                printUsage(argv[0]);
                exit(1);
            default:
                // Should not happen
                abort();
        }
    }

    logMessage(options.verbose, @"Finished parsing options.");

    // Handle conflicting scale/resolution. Resolution (-r) takes precedence.
    if (resolution_explicitly_set && scale_explicitly_set && !options.scale.isDPI) {
        // If -r was set, options.scale is already DPI based.
        // If -s was also set but not as DPI, -r (DPI) wins.
        // If -s was also set as DPI, the last one parsed wins, which is fine.
        logMessage(options.verbose, @"Both -r (resolution) and -s (scale) were specified. Using resolution (-r %fdpi).", options.scale.dpi);
    } else if (!resolution_explicitly_set && !scale_explicitly_set) {
        // Neither -r nor -s set, use default DPI of 144
        logMessage(options.verbose, @"No scale or resolution specified, using default %fdpi.", options.scale.dpi);
        // Ensure scale is set to DPI based for default
        char defaultDpiStr[16];
        snprintf(defaultDpiStr, sizeof(defaultDpiStr), "%ddpi", (int)options.scale.dpi);
        parseScaleSpec(defaultDpiStr, &options.scale);
    }


    // Handle positional arguments (input and output files)
    int num_remaining_args = argc - optind;
    logMessage(options.verbose, @"Number of remaining arguments: %d", num_remaining_args);

    if (num_remaining_args == 0 && isatty(fileno(stdin))) {
         fprintf(stderr, "Error: Input PDF file required, or pipe from stdin.\n");
         printUsage(argv[0]);
         exit(1);
    }

    // Input file
    if (num_remaining_args > 0) {
        NSString* first_arg = [NSString stringWithUTF8String:argv[optind]];
        if ([first_arg isEqualToString:@"-"]) {
            options.inputPath = nil; // stdin
            logMessage(options.verbose, @"Input PDF: stdin");
        } else {
            options.inputPath = first_arg;
            logMessage(options.verbose, @"Input PDF: %@", options.inputPath);
        }
        optind++;
        num_remaining_args--;
    } else { // No positional args, input must be stdin
        options.inputPath = nil; // stdin
        logMessage(options.verbose, @"Input PDF: stdin (implied)");
    }


    // Output file / prefix
    if (options.outputPath == nil) { // if -o was not used
        if (num_remaining_args > 0) {
            options.outputPath = [NSString stringWithUTF8String:argv[optind]];
            logMessage(options.verbose, @"Output path (from argument): %@", options.outputPath);
            optind++;
            num_remaining_args--;
        } else {
            // No -o and no second positional argument
            if (options.inputPath == nil && !options.batchMode) { // Input is stdin, not batch mode
                options.outputPath = @"-"; // Default to stdout
                logMessage(options.verbose, @"Output path: stdout (implied for stdin input)");
            } else if (options.batchMode && options.outputDirectory == nil) {
                // Batch mode, no -d, no -o, no output arg. Use input filename as prefix.
                // This case is handled by getOutputPrefix if options.outputPath is nil.
                logMessage(options.verbose, @"Batch mode: Output prefix will be derived from input filename or default to 'page'.");
            } else if (!options.batchMode && options.inputPath != nil) {
                 fprintf(stderr, "Error: Output PNG file required when input is a file and not in batch mode.\n");
                 printUsage(argv[0]);
                 exit(1);
            }
        }
    } else {
        logMessage(options.verbose, @"Output path (from -o): %@", options.outputPath);
    }

    if (num_remaining_args > 0) {
        fprintf(stderr, "Error: Too many arguments.\n");
        printUsage(argv[0]);
        exit(1);
    }

    // Final checks for batch mode
    if (options.batchMode) {
        if ([options.outputPath isEqualToString:@"-"]) {
            fprintf(stderr, "Error: Cannot output to stdout in batch mode.\n");
            exit(1);
        }
        if (options.outputDirectory == nil) {
            // If -d is not specified, output to current directory
            options.outputDirectory = @".";
            logMessage(options.verbose, @"Batch mode: Output directory not specified, using current directory '.'");
        }
        // If outputPath was not set by -o or positional arg, getOutputPrefix will use input name or "page"
        // If outputPath was set, it's the prefix.
    } else { // Single page mode
        if (options.outputDirectory != nil) {
            fprintf(stderr, "Error: -d/--directory is only for batch mode (-a/--all).\n");
            exit(1);
        }
    }

    logMessage(options.verbose, @"Final Options: pageNumber=%ld, batchMode=%s, transparent=%s, quality=%d, verbose=%s",
        (long)options.pageNumber, options.batchMode?"YES":"NO",
        options.transparentBackground?"YES":"NO", options.pngQuality, options.verbose?"YES":"NO");
    logMessage(options.verbose, @"ScaleSpec: factor=%.2f, dpi=%.2f, w=%.0f, h=%.0f, %%=%s, dpi_set=%s, w_set=%s, h_set=%s",
        options.scale.scaleFactor, options.scale.dpi, options.scale.maxWidth, options.scale.maxHeight,
        options.scale.isPercentage?"YES":"NO", options.scale.isDPI?"YES":"NO",
        options.scale.hasWidth?"YES":"NO", options.scale.hasHeight?"YES":"NO");


    return options;
}


BOOL processSinglePage(CGPDFDocumentRef pdfDocument, Options *options) {
    @autoreleasepool {
        logMessage(options->verbose, @"Processing single page: %ld", (long)options->pageNumber);

        size_t pageCount = CGPDFDocumentGetNumberOfPages(pdfDocument);
        if (options->pageNumber < 1 || options->pageNumber > (NSInteger)pageCount) {
            fprintf(stderr, "Error: Page %ld does not exist (document has %zu pages).\n",
                    (long)options->pageNumber, pageCount);
            return NO;
        }

        CGPDFPageRef pdfPage = CGPDFDocumentGetPage(pdfDocument, options->pageNumber);
        if (!pdfPage) {
            fprintf(stderr, "Error: Failed to get page %ld.\n", (long)options->pageNumber);
            return NO;
        }

        CGRect pageRect = CGPDFPageGetBoxRect(pdfPage, kCGPDFMediaBox);
        CGFloat scaleFactor = calculateScaleFactor(&options->scale, pageRect);
        logMessage(options->verbose, @"Calculated scale factor for page %ld: %.2f", (long)options->pageNumber, scaleFactor);

        CGImageRef image = renderPDFPageToImage(pdfPage, scaleFactor, options->transparentBackground, options->verbose);
        if (!image) {
            fprintf(stderr, "Error: Failed to render PDF page %ld.\n", (long)options->pageNumber);
            return NO;
        }

        BOOL success;
        if (options->outputPath && [options->outputPath isEqualToString:@"-"]) {
            if (options->dryRun) {
                size_t width = CGImageGetWidth(image);
                size_t height = CGImageGetHeight(image);
                fprintf(stdout, "[DRY-RUN] Would write PNG to stdout\n");
                fprintf(stdout, "          Page: %ld, Dimensions: %zux%zu\n", (long)options->pageNumber, width, height);
                success = YES;
            } else {
                logMessage(options->verbose, @"Writing image to stdout.");
                NSFileHandle *stdoutHandle = [NSFileHandle fileHandleWithStandardOutput];
                success = writeImageAsPNG(image, stdoutHandle, options->pngQuality, options->verbose);
            }
        } else if (options->outputPath) {
            logMessage(options->verbose, @"Writing image to file: %@", options->outputPath);
            success = writeImageToFile(image, options->outputPath, options->pngQuality, options->verbose, options->dryRun, options->forceOverwrite);
        } else {
            // This case should ideally be caught by argument parsing, means no output specified
            fprintf(stderr, "Error: Output path not specified for single page mode.\n");
            success = NO;
        }

        CGImageRelease(image);
        return success;
    }
}

BOOL processBatchMode(CGPDFDocumentRef pdfDocument, Options *options) {
    logMessage(options->verbose, @"Processing in batch mode. Output directory: %@", options->outputDirectory);

    if (options->dryRun) {
        fprintf(stdout, "[DRY-RUN] Would create directory: %s\n", [options->outputDirectory UTF8String]);
    } else {
        NSFileManager *fileManager = [NSFileManager defaultManager];
        NSError *error = nil;
        if (![fileManager createDirectoryAtPath:options->outputDirectory
                    withIntermediateDirectories:YES
                                     attributes:nil
                                          error:&error]) {
            fprintf(stderr, "Error: Failed to create output directory '%s': %s\n",
                    [options->outputDirectory UTF8String],
                    [[error localizedDescription] UTF8String]);
            return NO;
        }
    }

    size_t totalPageCount = CGPDFDocumentGetNumberOfPages(pdfDocument);
    NSString *prefix = getOutputPrefix(options); // Handles nil outputPath for prefix generation
    logMessage(options->verbose, @"Using output prefix: %@", prefix);

    // Determine which pages to process
    NSArray<NSNumber *> *pagesToProcess;
    if (options->pageRange) {
        pagesToProcess = parsePageRange(options->pageRange, totalPageCount);
        if (!pagesToProcess || pagesToProcess.count == 0) {
            reportError([NSString stringWithFormat:@"Invalid page range specification: %@", options->pageRange],
                       getTroubleshootingHint(@"page range"));
            return NO;
        }
        logMessage(options->verbose, @"Processing %lu pages from range: %@",
                   (unsigned long)pagesToProcess.count, options->pageRange);
    } else {
        // Process all pages
        NSMutableArray *allPages = [NSMutableArray arrayWithCapacity:totalPageCount];
        for (size_t i = 1; i <= totalPageCount; i++) {
            [allPages addObject:@(i)];
        }
        pagesToProcess = allPages;
        logMessage(options->verbose, @"Processing all %zu pages", totalPageCount);
    }

    __block volatile NSInteger successCount = 0;
    __block volatile NSInteger failCount = 0;
    __block volatile NSInteger processedCount = 0;
    NSObject *lock = [[NSObject alloc] init]; // For thread-safe modification of counters

    logMessage(options->verbose, @"Starting batch conversion of %lu pages...",
               (unsigned long)pagesToProcess.count);

    dispatch_apply(pagesToProcess.count, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^(size_t i) {
        // Check for termination signal
        if (g_shouldTerminate) {
            return;
        }

        // Continue processing even if other pages fail
        size_t pageNum = [pagesToProcess[i] unsignedIntegerValue];
        logMessage(options->verbose, @"Starting processing for page %zu...", pageNum);

        @autoreleasepool {
            CGPDFPageRef pdfPage = CGPDFDocumentGetPage(pdfDocument, pageNum);
            if (!pdfPage) {
                fprintf(stderr, "Warning: Failed to get page %zu, skipping.\n", pageNum);
                @synchronized(lock) {
                    failCount++;
                    processedCount++;
                }
                return;
            }

            CGRect pageRect = CGPDFPageGetBoxRect(pdfPage, kCGPDFMediaBox);
            CGFloat scaleFactor = calculateScaleFactor(&options->scale, pageRect);
            logMessage(options->verbose, @"Calculated scale factor for page %zu: %.2f", pageNum, scaleFactor);

            CGImageRef image = renderPDFPageToImage(pdfPage, scaleFactor, options->transparentBackground, options->verbose);
            if (!image) {
                fprintf(stderr, "Warning: Failed to render page %zu, skipping.\n", pageNum);
                @synchronized(lock) {
                    failCount++;
                    processedCount++;
                }
                return;
            }

            NSString *filename;
            NSString *extractedText = nil;

            // Extract text if needed (for -n flag or {text} placeholder)
            if (options->includeText || (options->namingPattern && [options->namingPattern containsString:@"{text}"])) {
                // Extract text from PDF page first
                NSString *pageText = extractTextFromPDFPage(pdfPage);

                // If no text found, try OCR
                if (!pageText || pageText.length == 0) {
                    logMessage(options->verbose, @"No text extracted from PDF, attempting OCR for page %zu", pageNum);
                    pageText = performOCROnImage(image);
                }

                // Slugify the text if found
                if (pageText && pageText.length > 0) {
                    extractedText = slugifyText(pageText, 30);
                    logMessage(options->verbose, @"Extracted text for page %zu: %@", pageNum, extractedText);
                } else {
                    logMessage(options->verbose, @"No text found for page %zu", pageNum);
                }
            }

            // Generate filename using pattern or default format
            if (options->namingPattern) {
                filename = formatFilenameWithPattern(options->namingPattern, prefix, pageNum, totalPageCount, extractedText);
                filename = [filename stringByAppendingString:@".png"];
            } else {
                filename = formatFilenameWithPattern(nil, prefix, pageNum, totalPageCount,
                                                   options->includeText ? extractedText : nil);
                filename = [filename stringByAppendingString:@".png"];
            }

            NSString *outputPath = [options->outputDirectory stringByAppendingPathComponent:filename];
            logMessage(options->verbose, @"Writing image for page %zu to file: %@", pageNum, outputPath);

            if (!writeImageToFile(image, outputPath, options->pngQuality, options->verbose, options->dryRun, options->forceOverwrite)) {
                fprintf(stderr, "Warning: Failed to write page %zu to '%s', skipping.\n", pageNum, [outputPath UTF8String]);
                @synchronized(lock) {
                    failCount++;
                    processedCount++;
                }
            } else {
                @synchronized(lock) {
                    successCount++;
                    processedCount++;
                }
            }

            CGImageRelease(image);

            // Progress reporting
            @synchronized(lock) {
                if (!options->verbose && processedCount % 10 == 0) {
                    fprintf(stderr, "\rProgress: %ld/%lu pages processed",
                            (long)processedCount, (unsigned long)pagesToProcess.count);
                    fflush(stderr);
                }
            }

            logMessage(options->verbose, @"Finished processing for page %zu.", pageNum);
        }
    });

    // Clear progress line if not in verbose mode
    if (!options->verbose) {
        fprintf(stderr, "\r%*s\r", 50, ""); // Clear the progress line
    }

    // Report results
    if (options->dryRun) {
        fprintf(stdout, "\n[DRY-RUN] Would convert %lu pages to PNG files\n",
                (unsigned long)pagesToProcess.count);
    } else if (g_shouldTerminate) {
        fprintf(stderr, "Batch processing interrupted: %ld pages converted before interruption, %ld pages failed.\n",
                (long)successCount, (long)failCount);
    } else {
        fprintf(stderr, "Batch processing complete: %ld pages converted successfully, %ld pages failed.\n",
                (long)successCount, (long)failCount);
    }

    // Return success only if at least one page was converted
    return successCount > 0;
}

int main(int argc, const char *argv[]) {
    @autoreleasepool {
        // Install signal handlers
        signal(SIGINT, signalHandler);
        signal(SIGTERM, signalHandler);

        Options options = parseArguments(argc, argv);

        logMessage(options.verbose, @"Starting pdf22png tool.");

        NSData *pdfData = readPDFData(options.inputPath, options.verbose);
        if (!pdfData || [pdfData length] == 0) {
            fprintf(stderr, "Error: No PDF data received or PDF data is empty.\n");
            return 1;
        }

        CGDataProviderRef provider = CGDataProviderCreateWithCFData((__bridge CFDataRef)pdfData);
        if (!provider) {
            fprintf(stderr, "Error: Failed to create PDF data provider.\n");
            return 1;
        }
        CGPDFDocumentRef pdfDocument = CGPDFDocumentCreateWithProvider(provider);
        CGDataProviderRelease(provider);

        if (!pdfDocument) {
            fprintf(stderr, "Error: Failed to create PDF document. Ensure the input is a valid PDF.\n");
            return 1;
        }

        // Validate PDF document
        if (CGPDFDocumentIsEncrypted(pdfDocument)) {
            reportError(@"PDF document is encrypted. Password-protected PDFs are not currently supported.",
                       getTroubleshootingHint(@"pdf encrypted password"));
            CGPDFDocumentRelease(pdfDocument);
            return 1;
        }

        size_t pageCount = CGPDFDocumentGetNumberOfPages(pdfDocument);
        if (pageCount == 0) {
            reportError(@"PDF document has no pages.",
                       getTroubleshootingHint(@"pdf empty no pages"));
            CGPDFDocumentRelease(pdfDocument);
            return 1;
        }

        logMessage(options.verbose, @"PDF document loaded successfully. Total pages: %zu", pageCount);

        BOOL success;
        if (options.batchMode) {
            success = processBatchMode(pdfDocument, &options);
        } else {
            success = processSinglePage(pdfDocument, &options);
        }

        CGPDFDocumentRelease(pdfDocument);
        logMessage(options.verbose, @"Processing finished. Success: %s", success ? "YES" : "NO");

        return success ? 0 : 1;
    }
}
</file>

<file path="src/utils.h">
#ifndef UTILS_H
#define UTILS_H

#import <Foundation/Foundation.h>
#import <Quartz/Quartz.h>
#import "pdf22png.h" // For ScaleSpec and Options structs
#import "errors.h" // For error codes and handling

// Function prototypes for utility functions
BOOL parseScaleSpec(const char *spec, ScaleSpec *scale);
NSData *readDataFromStdin(void);
NSData *readPDFData(NSString *inputPath, BOOL verbose); // Added verbose
CGFloat calculateScaleFactor(ScaleSpec *scale, CGRect pageRect);
CGImageRef renderPDFPageToImage(CGPDFPageRef pdfPage, CGFloat scaleFactor, BOOL transparentBackground, BOOL verbose); // Added transparentBackground and verbose
BOOL writeImageAsPNG(CGImageRef image, NSFileHandle *output, int pngQuality, BOOL verbose); // Added pngQuality and verbose
BOOL writeImageToFile(CGImageRef image, NSString *outputPath, int pngQuality, BOOL verbose, BOOL dryRun, BOOL forceOverwrite); // Added pngQuality, verbose, dryRun and forceOverwrite
NSString *getOutputPrefix(Options *options);
void logMessage(BOOL verbose, NSString *format, ...);

// Text extraction and processing
NSString *extractTextFromPDFPage(CGPDFPageRef page);
NSString *performOCROnImage(CGImageRef image);
NSString *slugifyText(NSString *text, NSUInteger maxLength);

// Page range parsing
NSArray<NSNumber *> *parsePageRange(NSString *rangeSpec, NSUInteger totalPages);

// Naming pattern processing
NSString *formatFilenameWithPattern(NSString *pattern, NSString *basename, NSUInteger pageNum,
                                   NSUInteger totalPages, NSString *extractedText);

// File overwrite protection
BOOL fileExists(NSString *path);
BOOL shouldOverwriteFile(NSString *path, BOOL interactive);
BOOL promptUserForOverwrite(NSString *path);

// Enhanced error reporting
void reportError(NSString *message, NSString *troubleshootingHint);
void reportWarning(NSString *message, NSString *troubleshootingHint);
NSString *getTroubleshootingHint(NSString *errorContext);

#endif /* UTILS_H */
</file>

<file path="src/utils.m">
#import "utils.h"
#import <Vision/Vision.h>

void logMessage(BOOL verbose, NSString *format, ...) {
    if (verbose) {
        va_list args;
        va_start(args, format);
        NSString *message = [[NSString alloc] initWithFormat:format arguments:args];
        va_end(args);
        fprintf(stderr, "%s\n", [message UTF8String]);
    }
}

BOOL parseScaleSpec(const char *spec, ScaleSpec *scale) {
    if (!spec || !scale) return NO;

    // Initialize scale
    memset(scale, 0, sizeof(ScaleSpec));
    scale->scaleFactor = 1.0; // Default to 100% if not specified otherwise

    NSString *specStr = [NSString stringWithUTF8String:spec];

    // Check for percentage (NNN%)
    if ([specStr hasSuffix:@"%"]) {
        NSString *numStr = [specStr substringToIndex:[specStr length] - 1];
        scale->scaleFactor = [numStr doubleValue] / 100.0;
        scale->isPercentage = YES;
        if (scale->scaleFactor <= 0) {
            reportError(@"Scale percentage must be positive.",
                       getTroubleshootingHint(@"scale format"));
            return NO;
        }
        return YES;
    }

    // Check for DPI (AAAdpi)
    if ([specStr hasSuffix:@"dpi"]) {
        NSString *numStr = [specStr substringToIndex:[specStr length] - 3];
        scale->dpi = [numStr doubleValue];
        scale->isDPI = YES;
        if (scale->dpi <= 0) {
            reportError(@"DPI value must be positive.",
                       getTroubleshootingHint(@"scale format"));
            return NO;
        }
        return YES;
    }

    // Check for dimensions (HHHxWWW, HHHx, xWWW)
    NSRange xRange = [specStr rangeOfString:@"x" options:NSCaseInsensitiveSearch]; // Case insensitive 'x'
    if (xRange.location != NSNotFound) {
        NSString *heightStr = @"";
        if (xRange.location > 0) {
            heightStr = [specStr substringToIndex:xRange.location];
        }
        NSString *widthStr = @"";
        if (xRange.location < [specStr length] - 1) {
            widthStr = [specStr substringFromIndex:xRange.location + 1];
        }

        if ([heightStr length] > 0) {
            scale->maxHeight = [heightStr doubleValue];
            if (scale->maxHeight <= 0) {
                fprintf(stderr, "Error: Height dimension must be positive.\n");
                return NO;
            }
            scale->hasHeight = YES;
        }

        if ([widthStr length] > 0) {
            scale->maxWidth = [widthStr doubleValue];
            if (scale->maxWidth <= 0) {
                fprintf(stderr, "Error: Width dimension must be positive.\n");
                return NO;
            }
            scale->hasWidth = YES;
        }

        return scale->hasHeight || scale->hasWidth;
    }

    // If no known suffix or 'x' separator, try to parse as a simple number (scale factor)
    // This makes "-s 2.0" work as scale factor 2.0
    NSScanner *scanner = [NSScanner scannerWithString:specStr];
    double factor;
    if ([scanner scanDouble:&factor] && [scanner isAtEnd]) {
        if (factor <= 0) {
            fprintf(stderr, "Error: Scale factor must be positive.\n");
            return NO;
        }
        scale->scaleFactor = factor;
        scale->isPercentage = NO; // Explicitly not a percentage
        scale->isDPI = NO;
        scale->hasWidth = NO;
        scale->hasHeight = NO;
        return YES;
    }

    fprintf(stderr, "Error: Invalid scale specification format: %s\n", spec);
    return NO;
}

NSData *readDataFromStdin(void) {
    NSMutableData *data = [NSMutableData data];
    char buffer[4096];
    size_t bytesRead;

    while ((bytesRead = fread(buffer, 1, sizeof(buffer), stdin)) > 0) {
        [data appendBytes:buffer length:bytesRead];
    }

    if (ferror(stdin)) {
        fprintf(stderr, "Error reading from stdin\n");
        return nil;
    }

    return data;
}

NSData *readPDFData(NSString *inputPath, BOOL verbose) {
    logMessage(verbose, @"Reading PDF data from: %@", inputPath ? inputPath : @"stdin");
    if (inputPath) {
        NSError *error = nil;
        NSData *data = [NSData dataWithContentsOfFile:inputPath options:0 error:&error];
        if (!data) {
            fprintf(stderr, "Error reading file %s: %s\n",
                    [inputPath UTF8String],
                    [[error localizedDescription] UTF8String]);
        }
        return data;
    } else {
        return readDataFromStdin();
    }
}

CGFloat calculateScaleFactor(ScaleSpec *scale, CGRect pageRect) {
    if (scale->isPercentage) {
        return scale->scaleFactor;
    }

    if (scale->isDPI) {
        // PDF points are 72 DPI by default
        return scale->dpi / 72.0;
    }

    // If only scaleFactor is set (e.g. from "-s 2.0")
    if (!scale->hasWidth && !scale->hasHeight && scale->scaleFactor > 0) {
        return scale->scaleFactor;
    }

    CGFloat scaleX = 1.0, scaleY = 1.0;

    if (scale->hasWidth && pageRect.size.width > 0) {
        scaleX = scale->maxWidth / pageRect.size.width;
    }

    if (scale->hasHeight && pageRect.size.height > 0) {
        scaleY = scale->maxHeight / pageRect.size.height;
    }

    if (scale->hasWidth && scale->hasHeight) { // HHHxWWW, fit to smallest
        return fmin(scaleX, scaleY);
    } else if (scale->hasWidth) { // xWWW
        return scaleX;
    } else if (scale->hasHeight) { // HHHx
        return scaleY;
    }

    return 1.0; // Default, should ideally be covered by isPercentage or direct scaleFactor
}

CGImageRef renderPDFPageToImage(CGPDFPageRef pdfPage, CGFloat scaleFactor, BOOL transparentBackground, BOOL verbose) {
    if (!pdfPage) return NULL;

    __block CGImageRef image = NULL;

    @autoreleasepool {
        logMessage(verbose, @"Rendering PDF page with scale factor: %.2f", scaleFactor);

        // Get page dimensions
        CGRect pageRect = CGPDFPageGetBoxRect(pdfPage, kCGPDFMediaBox);
        size_t width = (size_t)round(pageRect.size.width * scaleFactor);
        size_t height = (size_t)round(pageRect.size.height * scaleFactor);

        if (width == 0 || height == 0) {
            fprintf(stderr, "Error: Calculated image dimensions are zero (width: %zu, height: %zu). Check scale factor and PDF page size.\n", width, height);
            return NULL;
        }

        // Create bitmap context
        CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
        CGContextRef context = CGBitmapContextCreate(NULL, width, height, 8, 0, colorSpace,
                                                    kCGImageAlphaPremultipliedLast); // Changed to PremultipliedLast for better transparency handling
        CGColorSpaceRelease(colorSpace);

        if (!context) {
            fprintf(stderr, "Failed to create bitmap context\n");
            return NULL;
        }

        // Set background
        if (!transparentBackground) {
            CGContextSetRGBFillColor(context, 1.0, 1.0, 1.0, 1.0); // White
            CGContextFillRect(context, CGRectMake(0, 0, width, height));
        } else {
            CGContextClearRect(context, CGRectMake(0, 0, width, height)); // Transparent
        }

        // Save context state
        CGContextSaveGState(context);

        // Scale and translate for PDF rendering
        CGContextScaleCTM(context, scaleFactor, scaleFactor);
        // CGContextTranslateCTM(context, -pageRect.origin.x, -pageRect.origin.y); // This might be needed if cropbox/mediabox origin is not 0,0

        // Draw PDF page
        CGContextDrawPDFPage(context, pdfPage);

        // Restore context state
        CGContextRestoreGState(context);

        // Create image from context
        image = CGBitmapContextCreateImage(context);
        CGContextRelease(context);

        logMessage(verbose, @"Page rendered to CGImageRef successfully.");
    }

    return image;
}

BOOL writeImageAsPNG(CGImageRef image, NSFileHandle *output, int pngQuality, BOOL verbose) {
    if (!image || !output) return NO;

    logMessage(verbose, @"Writing image as PNG to stdout with quality: %d", pngQuality);

    NSMutableData *imageData = [NSMutableData data];
    CGImageDestinationRef destination = CGImageDestinationCreateWithData((__bridge CFMutableDataRef)imageData,
                                                                        kUTTypePNG, 1, NULL);
    if (!destination) {
        fprintf(stderr, "Failed to create image destination for stdout\n");
        return NO;
    }

    // PNG Quality/Compression
    // ImageIO uses a float from 0.0 (max compression) to 1.0 (lossless)
    // We need to map our 0-9 to this. Let's say 0 is max compression (0.0), 9 is min compression (0.9 for example)
    // Or, more simply, use kCGImageCompressionQuality which is what the quality parameter implies
    // For PNG, it's typically lossless, but some libraries might offer control over filter strategies or zlib level.
    // For now, let's assume higher 'pngQuality' means less compression effort (faster) if applicable,
    // or map to kCGImageDestinationLossyCompressionQuality if we were doing lossy.
    // Since PNG is lossless, this 'quality' might map to compression effort/speed.
    // The default is usually a good balance. Let's make it explicit if quality is not default (6).
    NSDictionary *props = nil;
    if (pngQuality >= 0 && pngQuality <= 9) { // Assuming 0-9, map to 0.0-1.0 for kCGImageDestinationLossyCompressionQuality if it were lossy
                                          // For PNG, this specific key might not do much, but let's keep it for future.
                                          // A value closer to 1.0 means less compression.
        // float compressionValue = (float)pngQuality / 9.0f;
        // props = @{(__bridge NSString *)kCGImageDestinationLossyCompressionQuality: @(compressionValue)};
        // For PNG, there isn't a direct "quality" setting like JPEG.
        // It's lossless. We can control things like interlace, filters, or zlib compression level,
        // but CGImageDestination doesn't expose these directly for PNGs.
        // So, pngQuality might be ignored here or we can log a message.
        logMessage(verbose, @"PNG quality setting (%d) is noted, but CoreGraphics offers limited control for PNG compression levels.", pngQuality);
    }


    CGImageDestinationAddImage(destination, image, (__bridge CFDictionaryRef)props);

    if (!CGImageDestinationFinalize(destination)) {
        fprintf(stderr, "Failed to finalize image for stdout\n");
        CFRelease(destination);
        return NO;
    }
    CFRelease(destination);

    @try {
        [output writeData:imageData];
    } @catch (NSException *exception) {
        fprintf(stderr, "Error writing PNG data to stdout: %s\n", [[exception reason] UTF8String]);
        return NO;
    }

    logMessage(verbose, @"Image written to stdout successfully.");
    return YES;
}

BOOL writeImageToFile(CGImageRef image, NSString *outputPath, int pngQuality, BOOL verbose, BOOL dryRun, BOOL forceOverwrite) {
    if (!image || !outputPath) return NO;

    if (dryRun) {
        // In dry-run mode, just report what would be created
        BOOL exists = fileExists(outputPath);
        fprintf(stdout, "[DRY-RUN] Would create: %s%s\n", [outputPath UTF8String],
                exists ? " (overwrites existing)" : "");

        // Calculate approximate file size for the image
        size_t width = CGImageGetWidth(image);
        size_t height = CGImageGetHeight(image);
        size_t bitsPerPixel = CGImageGetBitsPerPixel(image);
        size_t estimatedSize = (width * height * bitsPerPixel) / 8 / 1024; // KB

        fprintf(stdout, "          Dimensions: %zux%zu, Estimated size: ~%zu KB\n", width, height, estimatedSize);
        return YES;
    }

    // Check for overwrite protection
    if (!forceOverwrite && !shouldOverwriteFile(outputPath, YES)) {
        logMessage(verbose, @"Skipping %@ - file exists and overwrite denied", outputPath);
        return NO;
    }

    logMessage(verbose, @"Writing image as PNG to file: %@ with quality: %d", outputPath, pngQuality);

    NSURL *url = [NSURL fileURLWithPath:outputPath];
    CGImageDestinationRef destination = CGImageDestinationCreateWithURL((__bridge CFURLRef)url,
                                                                       kUTTypePNG, 1, NULL);
    if (!destination) {
        fprintf(stderr, "Failed to create image destination for file: %s\n", [outputPath UTF8String]);
        return NO;
    }

    NSDictionary *props = nil;
     if (pngQuality >= 0 && pngQuality <= 9) {
        logMessage(verbose, @"PNG quality setting (%d) is noted, but CoreGraphics offers limited control for PNG compression levels.", pngQuality);
    }

    CGImageDestinationAddImage(destination, image, (__bridge CFDictionaryRef)props);

    BOOL success = CGImageDestinationFinalize(destination);
    if (!success) {
        fprintf(stderr, "Failed to write image to file: %s\n", [outputPath UTF8String]);
    }

    CFRelease(destination);
    logMessage(verbose, @"Image written to file %@ %s.", outputPath, success ? "successfully" : "failed");
    return success;
}

NSString *getOutputPrefix(Options *options) {
    if (options->outputPath && ![options->outputPath isEqualToString:@"-"]) { // Treat "-" as stdout for prefix
        // If output path is a full filename (e.g., "image.png"), use "image"
        // If it's just a prefix (e.g., "img_"), use it as is.
        // For batch mode, -o is always a prefix.
        return [[options->outputPath lastPathComponent] stringByDeletingPathExtension];
    } else if (options->inputPath) {
        // Use basename of input file
        NSString *basename = [[options->inputPath lastPathComponent] stringByDeletingPathExtension];
        return basename;
    } else {
        return @"page"; // Default prefix if input is stdin and no output path
    }
}

// PDF operator callbacks (forward declarations)
static void pdf_Tj(CGPDFScannerRef scanner, void *info);
static void pdf_TJ(CGPDFScannerRef scanner, void *info);
static void pdf_Quote(CGPDFScannerRef scanner, void *info);
static void pdf_DoubleQuote(CGPDFScannerRef scanner, void *info);

NSString *extractTextFromPDFPage(CGPDFPageRef page) {
    if (!page) return nil;

    NSMutableString *pageText = [NSMutableString string];

    // Create a PDF Scanner
    CGPDFScannerRef scanner = NULL;
    CGPDFContentStreamRef contentStream = CGPDFContentStreamCreateWithPage(page);
    if (contentStream) {
        CGPDFOperatorTableRef operatorTable = CGPDFOperatorTableCreate();

        // Set up operator callbacks for text extraction
        CGPDFOperatorTableSetCallback(operatorTable, "Tj", &pdf_Tj);
        CGPDFOperatorTableSetCallback(operatorTable, "TJ", &pdf_TJ);
        CGPDFOperatorTableSetCallback(operatorTable, "'", &pdf_Quote);
        CGPDFOperatorTableSetCallback(operatorTable, "\"", &pdf_DoubleQuote);

        scanner = CGPDFScannerCreate(contentStream, operatorTable, (__bridge void *)pageText);
        if (scanner) {
            CGPDFScannerScan(scanner);
            CGPDFScannerRelease(scanner);
        }

        CGPDFOperatorTableRelease(operatorTable);
        CGPDFContentStreamRelease(contentStream);
    }

    // Clean up the text
    NSString *cleanedText = [pageText stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
    cleanedText = [cleanedText stringByReplacingOccurrencesOfString:@"\\s+" withString:@" "
                                                           options:NSRegularExpressionSearch
                                                             range:NSMakeRange(0, cleanedText.length)];

    return cleanedText.length > 0 ? cleanedText : nil;
}

// PDF operator callbacks
static void pdf_Tj(CGPDFScannerRef scanner, void *info) {
    CGPDFStringRef pdfString = NULL;
    if (CGPDFScannerPopString(scanner, &pdfString)) {
        NSString *string = (__bridge_transfer NSString *)CGPDFStringCopyTextString(pdfString);
        if (string) {
            NSMutableString *pageText = (__bridge NSMutableString *)info;
            [pageText appendString:string];
            [pageText appendString:@" "];
        }
    }
}

static void pdf_TJ(CGPDFScannerRef scanner, void *info) {
    CGPDFArrayRef array = NULL;
    if (CGPDFScannerPopArray(scanner, &array)) {
        size_t count = CGPDFArrayGetCount(array);
        NSMutableString *pageText = (__bridge NSMutableString *)info;

        for (size_t i = 0; i < count; i++) {
            CGPDFObjectRef object = NULL;
            if (CGPDFArrayGetObject(array, i, &object)) {
                CGPDFObjectType type = CGPDFObjectGetType(object);
                if (type == kCGPDFObjectTypeString) {
                    CGPDFStringRef pdfString = NULL;
                    if (CGPDFObjectGetValue(object, kCGPDFObjectTypeString, &pdfString)) {
                        NSString *string = (__bridge_transfer NSString *)CGPDFStringCopyTextString(pdfString);
                        if (string) {
                            [pageText appendString:string];
                        }
                    }
                }
            }
        }
        [pageText appendString:@" "];
    }
}

static void pdf_Quote(CGPDFScannerRef scanner, void *info) {
    pdf_Tj(scanner, info);
}

static void pdf_DoubleQuote(CGPDFScannerRef scanner, void *info) {
    // Skip the two numeric parameters
    CGPDFReal tc, tw;
    CGPDFScannerPopNumber(scanner, &tc);
    CGPDFScannerPopNumber(scanner, &tw);
    pdf_Tj(scanner, info);
}

NSString *performOCROnImage(CGImageRef image) {
    if (!image) return nil;

    __block NSString *recognizedText = nil;
    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);

    @autoreleasepool {
        // Create Vision request
        VNRecognizeTextRequest *request = [[VNRecognizeTextRequest alloc] initWithCompletionHandler:^(VNRequest *request, NSError *error) {
            if (error) {
                NSLog(@"OCR Error: %@", error.localizedDescription);
                dispatch_semaphore_signal(semaphore);
                return;
            }

            NSMutableString *fullText = [NSMutableString string];
            for (VNRecognizedTextObservation *observation in request.results) {
                VNRecognizedText *topCandidate = [observation topCandidates:1].firstObject;
                if (topCandidate) {
                    [fullText appendString:topCandidate.string];
                    [fullText appendString:@" "];
                }
            }

            recognizedText = [fullText stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
            dispatch_semaphore_signal(semaphore);
        }];

        request.recognitionLevel = VNRequestTextRecognitionLevelAccurate;
        request.recognitionLanguages = @[@"en-US"]; // Add more languages as needed
        request.usesLanguageCorrection = YES;

        // Create handler and perform request
        VNImageRequestHandler *handler = [[VNImageRequestHandler alloc] initWithCGImage:image options:@{}];
        NSError *error = nil;
        [handler performRequests:@[request] error:&error];

        if (error) {
            NSLog(@"Failed to perform OCR: %@", error.localizedDescription);
            dispatch_semaphore_signal(semaphore);
        }
    }

    // Wait for OCR to complete (with timeout)
    dispatch_semaphore_wait(semaphore, dispatch_time(DISPATCH_TIME_NOW, 5 * NSEC_PER_SEC));

    return recognizedText;
}

NSString *slugifyText(NSString *text, NSUInteger maxLength) {
    if (!text || text.length == 0) return @"";

    // Convert to lowercase
    NSString *lowercased = [text lowercaseString];

    // Replace non-alphanumeric characters with hyphens
    NSMutableString *slugified = [NSMutableString string];
    NSCharacterSet *alphanumeric = [NSCharacterSet alphanumericCharacterSet];

    BOOL lastWasHyphen = NO;
    for (NSUInteger i = 0; i < lowercased.length && slugified.length < maxLength; i++) {
        unichar ch = [lowercased characterAtIndex:i];

        if ([alphanumeric characterIsMember:ch]) {
            [slugified appendFormat:@"%C", ch];
            lastWasHyphen = NO;
        } else if (!lastWasHyphen && slugified.length > 0) {
            [slugified appendString:@"-"];
            lastWasHyphen = YES;
        }
    }

    // Remove trailing hyphen if present
    if ([slugified hasSuffix:@"-"]) {
        [slugified deleteCharactersInRange:NSMakeRange(slugified.length - 1, 1)];
    }

    // Truncate to maxLength
    if (slugified.length > maxLength) {
        NSString *truncated = [slugified substringToIndex:maxLength];
        // Remove partial word at end
        NSRange lastHyphen = [truncated rangeOfString:@"-" options:NSBackwardsSearch];
        if (lastHyphen.location != NSNotFound && lastHyphen.location > maxLength * 0.7) {
            truncated = [truncated substringToIndex:lastHyphen.location];
        }
        return truncated;
    }

    return slugified;
}

NSArray<NSNumber *> *parsePageRange(NSString *rangeSpec, NSUInteger totalPages) {
    if (!rangeSpec || rangeSpec.length == 0) {
        return nil;
    }

    NSMutableSet *pageSet = [NSMutableSet set];
    NSArray *parts = [rangeSpec componentsSeparatedByString:@","];

    for (NSString *part in parts) {
        NSString *trimmedPart = [part stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];

        // Check if it's a range (contains hyphen)
        NSRange hyphenRange = [trimmedPart rangeOfString:@"-"];
        if (hyphenRange.location != NSNotFound) {
            // Split range into start and end
            NSArray *rangeParts = [trimmedPart componentsSeparatedByString:@"-"];
            if (rangeParts.count == 2) {
                NSInteger start = [rangeParts[0] integerValue];
                NSInteger end = [rangeParts[1] integerValue];

                // Validate range
                if (start < 1) start = 1;
                if (end > (NSInteger)totalPages) end = (NSInteger)totalPages;

                if (start <= end) {
                    for (NSInteger i = start; i <= end; i++) {
                        [pageSet addObject:@(i)];
                    }
                }
            }
        } else {
            // Single page number
            NSInteger pageNum = [trimmedPart integerValue];
            if (pageNum >= 1 && pageNum <= (NSInteger)totalPages) {
                [pageSet addObject:@(pageNum)];
            }
        }
    }

    // Convert set to sorted array
    NSArray *sortedPages = [[pageSet allObjects] sortedArrayUsingComparator:^NSComparisonResult(NSNumber *obj1, NSNumber *obj2) {
        return [obj1 compare:obj2];
    }];

    return sortedPages;
}

NSString *formatFilenameWithPattern(NSString *pattern, NSString *basename, NSUInteger pageNum,
                                   NSUInteger totalPages, NSString *extractedText) {
    if (!pattern || pattern.length == 0) {
        // Default pattern if none specified
        if (extractedText && extractedText.length > 0) {
            return [NSString stringWithFormat:@"%@-%03zu--%@", basename, pageNum, extractedText];
        } else {
            return [NSString stringWithFormat:@"%@-%03zu", basename, pageNum];
        }
    }

    NSMutableString *result = [NSMutableString stringWithString:pattern];

    // Replace {basename} or {name}
    [result replaceOccurrencesOfString:@"{basename}" withString:basename
                              options:0 range:NSMakeRange(0, result.length)];
    [result replaceOccurrencesOfString:@"{name}" withString:basename
                              options:0 range:NSMakeRange(0, result.length)];

    // Replace {page} with zero-padded page number
    NSUInteger digits = (NSUInteger)log10(totalPages > 0 ? totalPages : 1) + 1;
    if (digits < 3) digits = 3; // Minimum 3 digits
    NSString *pageStr = [NSString stringWithFormat:@"%0*zu", (int)digits, pageNum];
    [result replaceOccurrencesOfString:@"{page}" withString:pageStr
                              options:0 range:NSMakeRange(0, result.length)];

    // Replace {page:03d} style formatting
    NSRegularExpression *pageFormatRegex = [NSRegularExpression regularExpressionWithPattern:@"\\{page:0?(\\d+)d\\}"
                                                                                    options:0 error:nil];
    NSArray *matches = [pageFormatRegex matchesInString:result options:0
                                               range:NSMakeRange(0, result.length)];

    // Process matches in reverse order to avoid index shifting
    for (NSTextCheckingResult *match in [matches reverseObjectEnumerator]) {
        NSRange digitRange = [match rangeAtIndex:1];
        NSString *digitStr = [result substringWithRange:digitRange];
        int formatDigits = [digitStr intValue];
        NSString *formattedPage = [NSString stringWithFormat:@"%0*zu", formatDigits, pageNum];
        [result replaceCharactersInRange:match.range withString:formattedPage];
    }

    // Replace {text} with extracted text (if available)
    if (extractedText && extractedText.length > 0) {
        [result replaceOccurrencesOfString:@"{text}" withString:extractedText
                                  options:0 range:NSMakeRange(0, result.length)];
    } else {
        [result replaceOccurrencesOfString:@"{text}" withString:@""
                                  options:0 range:NSMakeRange(0, result.length)];
    }

    // Replace {date} with current date in YYYYMMDD format
    NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];
    [dateFormatter setDateFormat:@"yyyyMMdd"];
    NSString *dateStr = [dateFormatter stringFromDate:[NSDate date]];
    [result replaceOccurrencesOfString:@"{date}" withString:dateStr
                              options:0 range:NSMakeRange(0, result.length)];

    // Replace {time} with current time in HHMMSS format
    [dateFormatter setDateFormat:@"HHmmss"];
    NSString *timeStr = [dateFormatter stringFromDate:[NSDate date]];
    [result replaceOccurrencesOfString:@"{time}" withString:timeStr
                              options:0 range:NSMakeRange(0, result.length)];

    // Replace {total} with total page count
    [result replaceOccurrencesOfString:@"{total}" withString:[NSString stringWithFormat:@"%zu", totalPages]
                              options:0 range:NSMakeRange(0, result.length)];

    return result;
}

// File overwrite protection functions
BOOL fileExists(NSString *path) {
    return [[NSFileManager defaultManager] fileExistsAtPath:path];
}

BOOL shouldOverwriteFile(NSString *path, BOOL interactive) {
    if (!fileExists(path)) {
        return YES; // File doesn't exist, safe to write
    }

    if (!interactive) {
        return NO; // Non-interactive mode, don't overwrite
    }

    return promptUserForOverwrite(path);
}

BOOL promptUserForOverwrite(NSString *path) {
    fprintf(stderr, "File '%s' already exists. Overwrite? (y/N): ", [path UTF8String]);
    fflush(stderr);

    char response[10];
    if (fgets(response, sizeof(response), stdin) == NULL) {
        return NO; // No input, default to no
    }

    // Check first character, case insensitive
    char first = response[0];
    return (first == 'y' || first == 'Y');
}

// Enhanced error reporting functions
void reportError(NSString *message, NSString *troubleshootingHint) {
    fprintf(stderr, "Error: %s\n", [message UTF8String]);
    if (troubleshootingHint) {
        fprintf(stderr, "Hint:  %s\n", [troubleshootingHint UTF8String]);
    }
}

void reportWarning(NSString *message, NSString *troubleshootingHint) {
    fprintf(stderr, "Warning: %s\n", [message UTF8String]);
    if (troubleshootingHint) {
        fprintf(stderr, "Hint:    %s\n", [troubleshootingHint UTF8String]);
    }
}

NSString *getTroubleshootingHint(NSString *errorContext) {
    if (!errorContext) return nil;

    NSString *context = [errorContext lowercaseString];

    // PDF-related errors
    if ([context containsString:@"pdf"] || [context containsString:@"document"]) {
        if ([context containsString:@"encrypted"] || [context containsString:@"password"]) {
            return @"PDF is password-protected. Try removing the password first using Preview or pdftk.";
        }
        if ([context containsString:@"corrupt"] || [context containsString:@"invalid"]) {
            return @"PDF file may be corrupted. Try opening it in Preview to verify it's readable.";
        }
        if ([context containsString:@"empty"] || [context containsString:@"no pages"]) {
            return @"PDF appears to be empty or has no pages to convert.";
        }
        return @"Verify the PDF file is valid and readable in Preview or other PDF viewers.";
    }

    // File I/O errors
    if ([context containsString:@"permission"] || [context containsString:@"denied"]) {
        return @"Check file permissions. You may need to use 'sudo' or change file ownership.";
    }
    if ([context containsString:@"not found"] || [context containsString:@"no such file"]) {
        return @"Verify the file path is correct and the file exists. Use absolute paths to avoid confusion.";
    }
    if ([context containsString:@"disk"] || [context containsString:@"space"]) {
        return @"Check available disk space. Large PDFs can require significant storage for conversion.";
    }

    // Memory errors
    if ([context containsString:@"memory"] || [context containsString:@"allocation"]) {
        return @"Try processing fewer pages at once or use a smaller scale factor to reduce memory usage.";
    }

    // Image/rendering errors
    if ([context containsString:@"image"] || [context containsString:@"render"]) {
        return @"Try using a smaller scale factor or lower DPI setting to reduce image complexity.";
    }

    // Scale/format errors
    if ([context containsString:@"scale"] || [context containsString:@"format"]) {
        return @"Use formats like '150%', '2.0', '800x600', or '300dpi'. See --help for examples.";
    }

    // Page range errors
    if ([context containsString:@"page"] || [context containsString:@"range"]) {
        return @"Use formats like '5' (single page), '1-10' (range), or '1,3,5-10' (list). Pages start at 1.";
    }

    return @"Run with -v/--verbose flag for more detailed information, or check --help for usage examples.";
}
</file>

<file path="Tests/test_runner.m">
#import <Foundation/Foundation.h>
#import "../src/utils.h"
#import "../src/pdf22png.h"

// Simple test framework macros
#define TEST_ASSERT(condition, message) \
    if (!(condition)) { \
        NSLog(@"FAIL: %s - %@", __FUNCTION__, message); \
        return NO; \
    }

#define TEST_ASSERT_EQUAL(actual, expected, message) \
    if ((actual) != (expected)) { \
        NSLog(@"FAIL: %s - %@. Expected: %@, Actual: %@", __FUNCTION__, message, @(expected), @(actual)); \
        return NO; \
    }

#define TEST_ASSERT_EQUAL_FLOAT(actual, expected, accuracy, message) \
    if (fabs((actual) - (expected)) > (accuracy)) { \
        NSLog(@"FAIL: %s - %@. Expected: %f, Actual: %f", __FUNCTION__, message, (expected), (actual)); \
        return NO; \
    }

// Test function declarations
BOOL testParseScaleSpec_percentage(void);
BOOL testParseScaleSpec_factor(void);
BOOL testParseScaleSpec_dpi(void);
BOOL testParseScaleSpec_dimensions(void);
BOOL testParseScaleSpec_invalid(void);
BOOL testParsePageRange(void);
BOOL testExtractTextFromPDFPage(void);
BOOL testFileExists(void);
BOOL testShouldOverwriteFile(void);

// Test implementations
BOOL testParseScaleSpec_percentage(void) {
    ScaleSpec scale;
    BOOL result = parseScaleSpec("150%", &scale);
    TEST_ASSERT(result, @"Parsing '150%' should succeed");
    TEST_ASSERT(scale.isPercentage, @"Scale should be percentage");
    TEST_ASSERT_EQUAL_FLOAT(scale.scaleFactor, 1.5, 0.001, @"Scale factor should be 1.5");
    TEST_ASSERT(!scale.isDPI, @"Scale should not be DPI");
    return YES;
}

BOOL testParseScaleSpec_factor(void) {
    ScaleSpec scale;
    BOOL result = parseScaleSpec("2.0", &scale);
    TEST_ASSERT(result, @"Parsing '2.0' should succeed");
    TEST_ASSERT(!scale.isPercentage, @"Scale should not be percentage");
    TEST_ASSERT_EQUAL_FLOAT(scale.scaleFactor, 2.0, 0.001, @"Scale factor should be 2.0");
    return YES;
}

BOOL testParseScaleSpec_dpi(void) {
    ScaleSpec scale;
    BOOL result = parseScaleSpec("300dpi", &scale);
    TEST_ASSERT(result, @"Parsing '300dpi' should succeed");
    TEST_ASSERT(scale.isDPI, @"Scale should be DPI");
    TEST_ASSERT_EQUAL_FLOAT(scale.dpi, 300.0, 0.001, @"DPI should be 300");
    return YES;
}

BOOL testParseScaleSpec_dimensions(void) {
    ScaleSpec scale;

    // Test height only (pattern: "heightx")
    BOOL result = parseScaleSpec("800x", &scale);
    TEST_ASSERT(result, @"Parsing '800x' should succeed");
    TEST_ASSERT(!scale.hasWidth, @"Should not have width");
    TEST_ASSERT(scale.hasHeight, @"Should have height");
    TEST_ASSERT_EQUAL_FLOAT(scale.maxHeight, 800.0, 0.001, @"Height should be 800");

    // Test width only (pattern: "xwidth")
    result = parseScaleSpec("x600", &scale);
    TEST_ASSERT(result, @"Parsing 'x600' should succeed");
    TEST_ASSERT(scale.hasWidth, @"Should have width");
    TEST_ASSERT(!scale.hasHeight, @"Should not have height");
    TEST_ASSERT_EQUAL_FLOAT(scale.maxWidth, 600.0, 0.001, @"Width should be 600");

    // Test both dimensions (pattern: "heightxwidth")
    result = parseScaleSpec("800x600", &scale);
    TEST_ASSERT(result, @"Parsing '800x600' should succeed");
    TEST_ASSERT(scale.hasWidth, @"Should have width");
    TEST_ASSERT(scale.hasHeight, @"Should have height");
    TEST_ASSERT_EQUAL_FLOAT(scale.maxHeight, 800.0, 0.001, @"Height should be 800");
    TEST_ASSERT_EQUAL_FLOAT(scale.maxWidth, 600.0, 0.001, @"Width should be 600");

    return YES;
}

BOOL testParseScaleSpec_invalid(void) {
    ScaleSpec scale;
    BOOL result = parseScaleSpec("invalid", &scale);
    TEST_ASSERT(!result, @"Parsing 'invalid' should fail");
    return YES;
}

BOOL testParsePageRange(void) {
    // Test simple single page
    NSArray *pages = parsePageRange(@"5", 10);
    TEST_ASSERT(pages != nil, @"parsePageRange should return array");
    TEST_ASSERT_EQUAL(pages.count, 1, @"Should have 1 page");
    TEST_ASSERT_EQUAL([pages[0] integerValue], 5, @"Page should be 5");

    // Test range
    pages = parsePageRange(@"1-3", 10);
    TEST_ASSERT(pages != nil, @"parsePageRange should return array");
    TEST_ASSERT_EQUAL(pages.count, 3, @"Should have 3 pages");
    TEST_ASSERT_EQUAL([pages[0] integerValue], 1, @"First page should be 1");
    TEST_ASSERT_EQUAL([pages[2] integerValue], 3, @"Last page should be 3");

    // Test comma separated
    pages = parsePageRange(@"1,3,5", 10);
    TEST_ASSERT(pages != nil, @"parsePageRange should return array");
    TEST_ASSERT_EQUAL(pages.count, 3, @"Should have 3 pages");
    TEST_ASSERT_EQUAL([pages[1] integerValue], 3, @"Second page should be 3");

    // Test complex
    pages = parsePageRange(@"1-3,5,7-9", 10);
    TEST_ASSERT(pages != nil, @"parsePageRange should return array");
    TEST_ASSERT_EQUAL(pages.count, 7, @"Should have 7 pages");

    return YES;
}

BOOL testExtractTextFromPDFPage(void) {
    // This test would require a real PDF, so we'll just verify the function exists
    NSString *result = extractTextFromPDFPage(nil);
    TEST_ASSERT(result == nil, @"Should return nil for nil page");
    return YES;
}

BOOL testFileExists(void) {
    // Test with non-existent file
    TEST_ASSERT(!fileExists(@"/path/that/does/not/exist"), @"Should return NO for non-existent file");

    // Test with a file that should exist (create a temp file)
    NSString *tempPath = [NSTemporaryDirectory() stringByAppendingPathComponent:@"test_file.txt"];
    [@"test" writeToFile:tempPath atomically:YES encoding:NSUTF8StringEncoding error:nil];
    TEST_ASSERT(fileExists(tempPath), @"Should return YES for existing temp file");
    [[NSFileManager defaultManager] removeItemAtPath:tempPath error:nil];

    return YES;
}

BOOL testShouldOverwriteFile(void) {
    // Test with non-existent file
    TEST_ASSERT(shouldOverwriteFile(@"/path/that/does/not/exist", NO), @"Should allow writing to non-existent file");
    TEST_ASSERT(shouldOverwriteFile(@"/path/that/does/not/exist", YES), @"Should allow writing to non-existent file");

    // Test with existing file in non-interactive mode
    NSString *tempPath = [NSTemporaryDirectory() stringByAppendingPathComponent:@"test_file2.txt"];
    [@"test" writeToFile:tempPath atomically:YES encoding:NSUTF8StringEncoding error:nil];
    TEST_ASSERT(!shouldOverwriteFile(tempPath, NO), @"Should not overwrite existing file in non-interactive mode");
    [[NSFileManager defaultManager] removeItemAtPath:tempPath error:nil];

    return YES;
}

// Main test runner
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        NSLog(@"Running pdf22png tests...");

        int passed = 0;
        int failed = 0;

        // Define test cases
        typedef BOOL (*TestFunction)(void);
        typedef struct {
            const char *name;
            TestFunction func;
        } TestCase;

        TestCase tests[] = {
            {"testParseScaleSpec_percentage", testParseScaleSpec_percentage},
            {"testParseScaleSpec_factor", testParseScaleSpec_factor},
            {"testParseScaleSpec_dpi", testParseScaleSpec_dpi},
            {"testParseScaleSpec_dimensions", testParseScaleSpec_dimensions},
            {"testParseScaleSpec_invalid", testParseScaleSpec_invalid},
            {"testParsePageRange", testParsePageRange},
            {"testExtractTextFromPDFPage", testExtractTextFromPDFPage},
            {"testFileExists", testFileExists},
            {"testShouldOverwriteFile", testShouldOverwriteFile},
        };

        int numTests = sizeof(tests) / sizeof(tests[0]);

        for (int i = 0; i < numTests; i++) {
            NSLog(@"Running %s...", tests[i].name);
            if (tests[i].func()) {
                NSLog(@"PASS: %s", tests[i].name);
                passed++;
            } else {
                failed++;
            }
        }

        NSLog(@"\n====================");
        NSLog(@"Test Results:");
        NSLog(@"  Passed: %d", passed);
        NSLog(@"  Failed: %d", failed);
        NSLog(@"  Total:  %d", passed + failed);
        NSLog(@"====================");

        return failed > 0 ? 1 : 0;
    }
}
</file>

<file path="Makefile">
# Variables
PRODUCT_NAME = pdf22png
CC = clang
CFLAGS = -Wall -Wextra -O2 -fobjc-arc -mmacosx-version-min=10.15
LDFLAGS = -framework Foundation -framework CoreGraphics -framework AppKit -framework Vision
PREFIX = /usr/local
BINDIR = $(PREFIX)/bin
SRCDIR = src
TESTDIR = Tests
BUILDDIR = build
VERSION = $(shell git describe --tags --always --dirty)

# Source files
SOURCES = $(SRCDIR)/pdf22png.m $(SRCDIR)/utils.m
OBJECTS = $(SOURCES:.m=.o)
TEST_SOURCES = $(TESTDIR)/test_runner.m
TEST_OBJECTS = $(TEST_SOURCES:.m=.o)

# Default target
.PHONY: all clean install uninstall test universal release fmt lint

all: build

build: $(BUILDDIR)/$(PRODUCT_NAME)

$(BUILDDIR)/$(PRODUCT_NAME): $(OBJECTS) | $(BUILDDIR)
	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $^

$(BUILDDIR):
	@mkdir -p $(BUILDDIR)

%.o: %.m
	$(CC) $(CFLAGS) -c -o $@ $<

# Universal binary target
universal:
	@echo "Building universal binary (Objective-C)..."
	@$(CC) $(CFLAGS) $(LDFLAGS) -arch x86_64 -arch arm64 -o $(BUILDDIR)/$(PRODUCT_NAME)-universal $(SOURCES)
	@echo "Universal Objective-C build complete!"

# Install target
install: build
	@echo "Installing $(PRODUCT_NAME) (Objective-C) to $(BINDIR)..."
	@install -d $(BINDIR)
	@install -m 755 $(BUILDDIR)/$(PRODUCT_NAME) $(BINDIR)/$(PRODUCT_NAME)
	@echo "Installation complete!"

uninstall:
	@echo "Uninstalling $(PRODUCT_NAME)..."
	@rm -f $(BINDIR)/$(PRODUCT_NAME)
	@echo "Uninstallation complete!"

# Test target
test: build $(TEST_OBJECTS)
	@echo "Running Objective-C tests..."
	@$(CC) $(CFLAGS) $(LDFLAGS) -o $(BUILDDIR)/test_runner $(TEST_OBJECTS) $(filter-out $(SRCDIR)/pdf22png.o,$(OBJECTS))
	@$(BUILDDIR)/test_runner

# Clean target
clean:
	@rm -f $(OBJECTS) $(TEST_OBJECTS)
	@rm -rf $(BUILDDIR) *.dSYM
	@echo "Objective-C clean complete!"

fmt:
	@echo "Formatting Objective-C code..."
	@clang-format -i $(SRCDIR)/*.m $(SRCDIR)/*.h $(TESTDIR)/*.m

lint:
	@echo "Linting Objective-C code..."
	@if command -v oclint >/dev/null 2>&1; then \
		oclint $(SOURCES) -- $(CFLAGS); \
	else \
		echo "oclint not installed, skipping Objective-C linting"; \
	fi

# Release build with version info
release:
	$(MAKE) clean
	$(MAKE) build CFLAGS="$(CFLAGS) -DVERSION=\\"$(VERSION)\\""
	@echo "Objective-C release build complete: $(VERSION)"
</file>

</files>
</file>

<file path="archive/objc/pdf22png-objc/Makefile">
# Variables
PRODUCT_NAME = pdf22png
CC = clang
PREFIX = /usr/local
BINDIR = $(PREFIX)/bin
BUILDDIR = build
SRCDIR = src
VERSION = $(shell git describe --tags --always --dirty 2>/dev/null || echo "1.0.0")

# Compiler flags
CFLAGS = -Wall -Wextra -O2 -fobjc-arc -std=c99
OBJCFLAGS = -Wall -Wextra -O2 -fobjc-arc
FRAMEWORKS = -framework Foundation -framework CoreGraphics -framework Quartz -framework ImageIO -framework PDFKit
UNIVERSAL_FLAGS = -arch arm64 -arch x86_64

# Source files
OBJC_SOURCES = $(SRCDIR)/pdf22png.m $(SRCDIR)/utils.m
OBJECTS = $(OBJC_SOURCES:.m=.o)

# Default target
.PHONY: all clean install uninstall test universal release fmt lint

all: build

%.o: %.m
	@echo "Compiling $<..."
	@$(CC) $(OBJCFLAGS) -c $< -o $@ $(FRAMEWORKS)

build: $(OBJECTS)
	@echo "Building Objective-C implementation..."
	@mkdir -p $(BUILDDIR)
	@$(CC) $(OBJCFLAGS) -o $(BUILDDIR)/$(PRODUCT_NAME) $(OBJECTS) $(FRAMEWORKS)
	@echo "Objective-C build complete!"

# Universal binary target
universal:
	@echo "Building universal binary (Objective-C)..."
	@mkdir -p $(BUILDDIR)
	@$(CC) $(OBJCFLAGS) $(UNIVERSAL_FLAGS) -o $(BUILDDIR)/$(PRODUCT_NAME)-universal $(OBJC_SOURCES) $(FRAMEWORKS)
	@echo "Universal Objective-C build complete!"

# Install target
install: build
	@echo "Installing $(PRODUCT_NAME) (Objective-C) to $(BINDIR)..."
	@install -d $(BINDIR)
	@install -m 755 $(BUILDDIR)/$(PRODUCT_NAME) $(BINDIR)/$(PRODUCT_NAME)
	@echo "Installation complete!"

uninstall:
	@echo "Uninstalling $(PRODUCT_NAME)..."
	@rm -f $(BINDIR)/$(PRODUCT_NAME)
	@echo "Uninstallation complete!"

clean:
	@echo "Cleaning Objective-C build..."
	@rm -f $(OBJECTS)
	@rm -rf $(BUILDDIR)
	@echo "Objective-C clean complete!"

test: build
	@echo "Running Objective-C tests..."
	@if [ -f Tests/test_runner.m ]; then \
		$(CC) $(OBJCFLAGS) -o $(BUILDDIR)/test_runner Tests/test_runner.m $(OBJECTS) $(FRAMEWORKS) && \
		./$(BUILDDIR)/test_runner; \
	else \
		echo "No test runner found, skipping tests"; \
	fi

fmt:
	@echo "Formatting Objective-C code..."
	@if command -v clang-format >/dev/null 2>&1; then \
		clang-format -i $(SRCDIR)/*.m $(SRCDIR)/*.h; \
	else \
		echo "clang-format not installed, skipping formatting"; \
	fi

lint:
	@echo "Linting Objective-C code..."
	@if command -v clang-tidy >/dev/null 2>&1; then \
		clang-tidy $(SRCDIR)/*.m -- $(OBJCFLAGS) $(FRAMEWORKS); \
	else \
		echo "clang-tidy not installed, skipping linting"; \
	fi

# Release build with version info
release:
	@echo "Building Objective-C release: $(VERSION)"
	@mkdir -p $(BUILDDIR)
	@$(CC) $(OBJCFLAGS) $(UNIVERSAL_FLAGS) -DVERSION=\"$(VERSION)\" -o $(BUILDDIR)/$(PRODUCT_NAME) $(OBJC_SOURCES) $(FRAMEWORKS)
	@echo "Objective-C release build complete: $(VERSION)"
</file>

<file path="archive/swift-spm/pdf22png-swift/Sources/TestFile.swift">
// This is a test file
let test = 123
</file>

<file path="archive/swift-spm/pdf22png-swift/Tests/pdf22pngTests/pdf22pngTests.swift">
import XCTest
@testable import pdf22png

final class pdf22pngTests: XCTestCase {
    
    // MARK: - Scale Specification Tests
    
    func testParseScaleSpec_percentage() {
        let scale = parseScaleSpecification("150%")
        XCTAssertNotNil(scale)
        XCTAssertTrue(scale!.isPercentage)
        XCTAssertEqual(scale!.scaleFactor, 1.5, accuracy: 0.001)
        XCTAssertFalse(scale!.isDPI)
    }
    
    func testParseScaleSpec_factor() {
        let scale = parseScaleSpecification("2.0")
        XCTAssertNotNil(scale)
        XCTAssertFalse(scale!.isPercentage)
        XCTAssertEqual(scale!.scaleFactor, 2.0, accuracy: 0.001)
    }
    
    func testParseScaleSpec_dpi() {
        let scale = parseScaleSpecification("300dpi")
        XCTAssertNotNil(scale)
        XCTAssertTrue(scale!.isDPI)
        XCTAssertEqual(scale!.dpi, 300.0, accuracy: 0.001)
    }
    
    func testParseScaleSpec_dimensions() {
        // Test width only
        var scale = parseScaleSpecification("800x")
        XCTAssertNotNil(scale)
        XCTAssertTrue(scale!.hasWidth)
        XCTAssertFalse(scale!.hasHeight)
        XCTAssertEqual(scale!.maxWidth, 800.0, accuracy: 0.001)
        
        // Test height only
        scale = parseScaleSpecification("x600")
        XCTAssertNotNil(scale)
        XCTAssertFalse(scale!.hasWidth)
        XCTAssertTrue(scale!.hasHeight)
        XCTAssertEqual(scale!.maxHeight, 600.0, accuracy: 0.001)
        
        // Test both dimensions
        scale = parseScaleSpecification("800x600")
        XCTAssertNotNil(scale)
        XCTAssertTrue(scale!.hasWidth)
        XCTAssertTrue(scale!.hasHeight)
        XCTAssertEqual(scale!.maxWidth, 800.0, accuracy: 0.001)
        XCTAssertEqual(scale!.maxHeight, 600.0, accuracy: 0.001)
    }
    
    func testParseScaleSpec_invalid() {
        XCTAssertNil(parseScaleSpecification("invalid"))
        XCTAssertNil(parseScaleSpecification(""))
        XCTAssertNil(parseScaleSpecification("-100%"))
        XCTAssertNil(parseScaleSpecification("0dpi"))
    }
    
    // MARK: - Page Range Tests
    
    func testParsePageRange_single() {
        let pages = parsePageRange("5", totalPages: 10)
        XCTAssertNotNil(pages)
        XCTAssertEqual(pages!.count, 1)
        XCTAssertEqual(pages![0], 5)
    }
    
    func testParsePageRange_range() {
        let pages = parsePageRange("1-3", totalPages: 10)
        XCTAssertNotNil(pages)
        XCTAssertEqual(pages!.count, 3)
        XCTAssertEqual(pages!, [1, 2, 3])
    }
    
    func testParsePageRange_commaSeparated() {
        let pages = parsePageRange("1,3,5", totalPages: 10)
        XCTAssertNotNil(pages)
        XCTAssertEqual(pages!.count, 3)
        XCTAssertEqual(pages!, [1, 3, 5])
    }
    
    func testParsePageRange_complex() {
        let pages = parsePageRange("1-3,5,7-9", totalPages: 10)
        XCTAssertNotNil(pages)
        XCTAssertEqual(pages!.count, 7)
        XCTAssertEqual(pages!, [1, 2, 3, 5, 7, 8, 9])
    }
    
    func testParsePageRange_outOfBounds() {
        let pages = parsePageRange("8-12", totalPages: 10)
        XCTAssertNotNil(pages)
        XCTAssertEqual(pages!, [8, 9, 10]) // Should cap at totalPages
    }
    
    func testParsePageRange_invalid() {
        XCTAssertNil(parsePageRange("0", totalPages: 10)) // Page 0 invalid
        XCTAssertNil(parsePageRange("abc", totalPages: 10))
        XCTAssertNil(parsePageRange("5-3", totalPages: 10)) // Invalid range
    }
    
    // MARK: - Text Slugification Tests
    
    func testSlugifyText() {
        XCTAssertEqual(slugifyText("Hello World!", maxLength: 30), "hello-world")
        XCTAssertEqual(slugifyText("Test@#$123", maxLength: 30), "test123")
        XCTAssertEqual(slugifyText("   Multiple   Spaces   ", maxLength: 30), "multiple-spaces")
    }
    
    func testSlugifyText_truncation() {
        let longText = "This is a very long text that should be truncated"
        let slug = slugifyText(longText, maxLength: 20)
        XCTAssertEqual(slug.count, 20)
        XCTAssertTrue(slug.hasPrefix("this-is-a-very-long"))
    }
    
    // MARK: - Filename Pattern Tests
    
    func testFormatFilenameWithPattern_default() {
        let filename = formatFilenameWithPattern(
            pattern: nil,
            basename: "document",
            pageNum: 5,
            totalPages: 100,
            extractedText: nil
        )
        XCTAssertEqual(filename, "document-005")
    }
    
    func testFormatFilenameWithPattern_custom() {
        let filename = formatFilenameWithPattern(
            pattern: "{basename}_page_{page:04d}_of_{total}",
            basename: "myfile",
            pageNum: 3,
            totalPages: 10,
            extractedText: nil
        )
        XCTAssertEqual(filename, "myfile_page_0003_of_10")
    }
    
    func testFormatFilenameWithPattern_withText() {
        let filename = formatFilenameWithPattern(
            pattern: "{basename}_{page}_{text}",
            basename: "doc",
            pageNum: 1,
            totalPages: 5,
            extractedText: "introduction"
        )
        XCTAssertTrue(filename.contains("introduction"))
    }
    
    // MARK: - File Operations Tests
    
    func testFileExists() {
        // Test with non-existent file
        XCTAssertFalse(fileExists("/path/that/does/not/exist"))
        
        // Test with temp file
        let tempPath = NSTemporaryDirectory().appending("test_file.txt")
        try? "test".write(toFile: tempPath, atomically: true, encoding: .utf8)
        XCTAssertTrue(fileExists(tempPath))
        try? FileManager.default.removeItem(atPath: tempPath)
    }
    
    func testShouldOverwriteFile_nonExistent() {
        XCTAssertTrue(shouldOverwriteFile(path: "/path/that/does/not/exist", interactive: false))
        XCTAssertTrue(shouldOverwriteFile(path: "/path/that/does/not/exist", interactive: true))
    }
    
    func testShouldOverwriteFile_existing() {
        let tempPath = NSTemporaryDirectory().appending("test_file2.txt")
        try? "test".write(toFile: tempPath, atomically: true, encoding: .utf8)
        
        // Non-interactive mode should not overwrite
        XCTAssertFalse(shouldOverwriteFile(path: tempPath, interactive: false))
        
        try? FileManager.default.removeItem(atPath: tempPath)
    }
    
    // MARK: - Scale Factor Calculation Tests
    
    func testCalculateScaleFactor_dpi() {
        var scale = ScaleSpecification()
        scale.isDPI = true
        scale.dpi = 300
        
        let factor = calculateScaleFactor(scale: scale, pageRect: CGRect(x: 0, y: 0, width: 100, height: 100))
        XCTAssertEqual(factor, 300.0 / 72.0, accuracy: 0.001)
    }
    
    func testCalculateScaleFactor_fitWidth() {
        var scale = ScaleSpecification()
        scale.hasWidth = true
        scale.maxWidth = 800
        
        let factor = calculateScaleFactor(scale: scale, pageRect: CGRect(x: 0, y: 0, width: 400, height: 600))
        XCTAssertEqual(factor, 2.0, accuracy: 0.001)
    }
    
    func testCalculateScaleFactor_fitHeight() {
        var scale = ScaleSpecification()
        scale.hasHeight = true
        scale.maxHeight = 600
        
        let factor = calculateScaleFactor(scale: scale, pageRect: CGRect(x: 0, y: 0, width: 400, height: 300))
        XCTAssertEqual(factor, 2.0, accuracy: 0.001)
    }
    
    func testCalculateScaleFactor_fitBoth() {
        var scale = ScaleSpecification()
        scale.hasWidth = true
        scale.hasHeight = true
        scale.maxWidth = 800
        scale.maxHeight = 600
        
        // Should use smaller scale to fit within bounds
        let factor = calculateScaleFactor(scale: scale, pageRect: CGRect(x: 0, y: 0, width: 400, height: 400))
        XCTAssertEqual(factor, 1.5, accuracy: 0.001) // Limited by height
    }
}
</file>

<file path="archive/swift-spm/pdf22png-swift/Makefile">
# Variables
PRODUCT_NAME = pdf22png
SWIFT = xcrun swift
PREFIX = /usr/local
BINDIR = $(PREFIX)/bin
BUILDDIR = build
SWIFT_BUILDDIR = .build
VERSION = $(shell git describe --tags --always --dirty)

# Default target
.PHONY: all clean install uninstall test universal release fmt lint

all: build

build:
	@echo "Building Swift version (standalone implementation)..."
	@echo "Note: Using standalone Swift implementation to avoid SPM dependencies"
	@$(MAKE) -C ../pdf22png-swift-standalone build
	@mkdir -p $(BUILDDIR)
	@cp ../pdf22png-swift-standalone/build/$(PRODUCT_NAME) $(BUILDDIR)/$(PRODUCT_NAME)
	@echo "Swift build complete!"

test:
	@echo "Testing standalone Swift implementation..."
	@$(MAKE) -C ../pdf22png-swift-standalone test

clean:
	@echo "Cleaning Swift build..."
	@$(MAKE) -C ../pdf22png-swift-standalone clean
	@rm -rf $(SWIFT_BUILDDIR) $(BUILDDIR)
	@echo "Swift clean complete!"

# Universal binary target
universal:
	@echo "Building universal binary (standalone Swift)..."
	@$(MAKE) -C ../pdf22png-swift-standalone universal
	@mkdir -p $(BUILDDIR)
	@cp ../pdf22png-swift-standalone/build/$(PRODUCT_NAME)-universal $(BUILDDIR)/$(PRODUCT_NAME)-universal
	@echo "Universal Swift build complete!"

# Install target
install: build
	@echo "Installing $(PRODUCT_NAME) (Swift) to $(BINDIR)..."
	@install -d $(BINDIR)
	@install -m 755 $(BUILDDIR)/$(PRODUCT_NAME) $(BINDIR)/$(PRODUCT_NAME)
	@echo "Installation complete!"

uninstall:
	@echo "Uninstalling $(PRODUCT_NAME)..."
	@rm -f $(BINDIR)/$(PRODUCT_NAME)
	@echo "Uninstallation complete!"

fmt:
	@echo "Formatting Swift code..."
	@if command -v swift-format >/dev/null 2>&1; then \
		swift-format -i Sources/**/*.swift Tests/**/*.swift; \
	else \
		echo "swift-format not installed, skipping Swift formatting"; \
	fi

lint:
	@echo "Linting Swift code..."
	@if command -v swiftlint >/dev/null 2>&1; then \
		swiftlint; \
	else \
		echo "SwiftLint not installed, skipping Swift linting"; \
	fi

# Release build with version info
release:
	@echo "Building Swift release (standalone): $(VERSION)"
	@$(MAKE) -C ../pdf22png-swift-standalone release
	@mkdir -p $(BUILDDIR)
	@cp ../pdf22png-swift-standalone/build/$(PRODUCT_NAME) $(BUILDDIR)/$(PRODUCT_NAME)
	@echo "Swift release build complete: $(VERSION)"
</file>

<file path="archive/swift-spm/pdf22png-swift/Package.swift">
// swift-tools-version:5.7
// The swift-tools-version declares the minimum version of Swift required to build this package.

import PackageDescription

let package = Package(
    name: "pdf22png",
    platforms: [
        .macOS(.v10_15) // Based on existing requirements
    ],
    dependencies: [
        .package(url: "https://github.com/apple/swift-argument-parser.git", from: "1.2.0"),
    ],
    targets: [
        // Targets are the basic building blocks of a package. A target can define a module or a test suite.
        // Targets can depend on other targets in this package, and on products in packages this package depends on.
        .executableTarget(
            name: "pdf22png",
            dependencies: [
                .product(name: "ArgumentParser", package: "swift-argument-parser"),
            ],
            path: "Sources/pdf22png"
        ),
        .testTarget(
            name: "pdf22pngTests",
            dependencies: ["pdf22png"],
            path: "Tests/pdf22pngTests"
        ),
    ]
)
</file>

<file path="docs/EXAMPLES.md">
# pdf22png Examples

This page shows common use cases and examples for the `pdf22png` command-line tool.

## Basic Conversions

**1. Convert the first page of a PDF to a PNG:**

```bash
pdf22png input.pdf output.png
```
*   Reads `input.pdf`.
*   Converts page 1.
*   Saves as `output.png` at default resolution (144 DPI).

**2. Convert a specific page (e.g., page 5):**

```bash
pdf22png -p 5 input.pdf page_5_output.png
```

**3. Read PDF from stdin, write PNG to stdout:**

```bash
cat input.pdf | pdf22png - - > output.png
# OR
pdf22png - - < input.pdf > output.png
```
*   Note: `-` is used for both input (stdin) and output (stdout).

## Resolution and Scaling

**4. Convert with a specific DPI (e.g., 300 DPI):**

```bash
pdf22png -r 300dpi input.pdf high_res_output.png
# or
pdf22png --resolution 300 input.pdf high_res_output.png
```

**5. Scale the output image by a factor (e.g., 2x larger):**

```bash
pdf22png -s 2.0 input.pdf large_output.png
# or by percentage
pdf22png -s 200% input.pdf large_output.png
```

**6. Fit output image to a specific width (e.g., 800px wide), maintaining aspect ratio:**

```bash
pdf22png -s 800x input.pdf width_800_output.png
```

**7. Fit output image to a specific height (e.g., 600px high), maintaining aspect ratio:**

```bash
pdf22png -s x600 input.pdf height_600_output.png
```

**8. Fit output image within specific dimensions (e.g., max 500px width and 500px height):**

```bash
pdf22png -s 500x500 input.pdf bounded_output.png
```

## Batch Conversion (All Pages)

**9. Convert all pages of a PDF, saving in the current directory:**
   Output files will be named `input-001.png`, `input-002.png`, etc. (assuming input file is `input.pdf`)

```bash
pdf22png -a input.pdf
```

**10. Convert all pages, specifying an output prefix:**
    Output files will be named `myprefix-001.png`, `myprefix-002.png`, etc.

```bash
pdf22png -a input.pdf myprefix
# or using -o for prefix
pdf22png -a -o myprefix input.pdf
```

**11. Convert all pages and save them into a specific directory:**
    Output files will be in `output_directory/input-001.png`, etc.

```bash
pdf22png -d ./output_directory input.pdf
```

**12. Convert all pages, save to a directory with a custom prefix:**
    Output files will be in `output_dir/custom_prefix-001.png`, etc.

```bash
pdf22png -d ./output_dir -o custom_prefix input.pdf
```

## Transparency and Quality

**13. Convert with a transparent background (if PDF page has transparency):**

```bash
pdf22png -t input.pdf transparent_output.png
```

**14. Specify PNG quality (0-9, informational for PNG):**

```bash
pdf22png -q 8 input.pdf quality_8_output.png
```
*   Note: PNG is a lossless format. This option is more relevant for formats like JPEG. For PNG, it might influence compression effort/speed in some libraries, but CoreGraphics offers limited direct control.

## Verbose Output

**15. Get detailed logs during conversion:**

```bash
pdf22png -v input.pdf output.png
```
*   Useful for debugging or understanding the conversion process.

## Combining Options

**16. Convert page 3 of `mydoc.pdf` to `page3_high_res.png` at 300 DPI with a transparent background:**

```bash
pdf22png -p 3 -r 300 -t mydoc.pdf page3_high_res.png
```

**17. Convert all pages of `report.pdf` to a subdirectory `report_images`, scaled to 50% size, with verbose output:**

```bash
pdf22png -a -s 50% -d ./report_images -v report.pdf
```
</file>

<file path="docs/pdf22png.1">
.\" Manpage for pdf22png
.\" Contact https://github.com/twardoch/pdf22png for issues
.TH PDF22PNG 1 "December 2024" "pdf22png 2.0.0" "User Commands"

.SH NAME
pdf22png \- convert PDF documents to PNG images

.SH SYNOPSIS
.B pdf22png
[\fIOPTIONS\fR] \fIinput.pdf\fR [\fIoutput.png\fR]

.SH DESCRIPTION
.B pdf22png
is a high-performance command-line tool for converting PDF documents to PNG images on macOS.
It leverages native Core Graphics and Quartz frameworks for optimal quality and speed.

The tool supports both single page and batch conversion modes, with flexible scaling options
and advanced features including transparent background support, custom naming patterns,
and memory-optimized batch processing.

.SH OPTIONS
.TP
.BR \-p ", " \-\-page " \fIspec\fR"
Specify page(s) to convert. Can be a single page number, a range, or comma-separated list.
Examples: 1 (single page), 1-5 (range), 1,3,5-10 (mixed).
Default: 1

.TP
.BR \-a ", " \-\-all
Convert all pages. If -d is not specified, uses input filename as prefix.
Output files are named <prefix>-<page_num>.png.

.TP
.BR \-r ", " \-\-resolution " \fIdpi\fR"
Set output resolution in DPI (dots per inch).
Example: 300 or 300dpi.
Overrides -s if both are specified.

.TP
.BR \-s ", " \-\-scale " \fIspec\fR"
Scaling specification. Supports multiple formats:
.RS
.IP \(bu 2
\fBNNN%\fR: Percentage scaling (e.g., 150%)
.IP \(bu 2
\fBN.N\fR: Scale factor (e.g., 1.5)
.IP \(bu 2
\fBWxH\fR: Fit within WxH pixels (e.g., 800x600)
.IP \(bu 2
\fBWx\fR: Fit to width W pixels (e.g., 1024x)
.IP \(bu 2
\fBxH\fR: Fit to height H pixels (e.g., x768)
.RE
Default: 100% or 1.0

.TP
.BR \-t ", " \-\-transparent
Preserve transparency in output PNG. By default, PDFs are rendered with a white background.

.TP
.BR \-q ", " \-\-quality " \fIn\fR"
PNG compression quality (0-9). 0 = fastest/largest, 9 = slowest/smallest.
Default: 6

.TP
.BR \-o ", " \-\-output " \fIpath\fR"
Output PNG file or prefix for batch mode.
Use '-' to output to stdout (single page mode only).

.TP
.BR \-d ", " \-\-directory " \fIdir\fR"
Output directory for batch mode (converts all pages).
If used, -o specifies filename prefix inside this directory.

.TP
.BR \-v ", " \-\-verbose
Enable verbose output with detailed processing information,
memory usage statistics, and diagnostic messages.

.TP
.BR \-n ", " \-\-name
Include extracted text in output filename (batch mode only).
Extracts text from PDF pages and includes a slugified version in the filename.

.TP
.BR \-P ", " \-\-pattern " \fIpattern\fR"
Custom naming pattern for batch mode. Placeholders:
.RS
.IP \(bu 2
\fB{basename}\fR - Input filename without extension
.IP \(bu 2
\fB{page}\fR - Page number (auto-padded)
.IP \(bu 2
\fB{page:03d}\fR - Page with custom padding
.IP \(bu 2
\fB{text}\fR - Extracted text (requires -n)
.IP \(bu 2
\fB{date}\fR - Current date (YYYYMMDD)
.IP \(bu 2
\fB{time}\fR - Current time (HHMMSS)
.IP \(bu 2
\fB{total}\fR - Total page count
.RE
Example: '{basename}_p{page:04d}_of_{total}'

.TP
.BR \-D ", " \-\-dry\-run
Preview operations without writing files.
Shows what would be created with dimensions and estimated file sizes.

.TP
.BR \-f ", " \-\-force
Force overwrite existing files without prompting.

.TP
.BR \-h ", " \-\-help
Show help message and exit.

.TP
.BR \-\-version
Show version information and exit.

.SH ARGUMENTS
.TP
.I input.pdf
Input PDF file. Use '-' to read from stdin.

.TP
.I output.png
Output PNG file. Required if not using -o or -d options.
If input is stdin and output is not specified, output goes to stdout.
In batch mode (-a or -d), this is used as a prefix if -o is not set.

.SH EXAMPLES
.SS Basic Conversion
Convert the first page of a PDF:
.PP
.nf
pdf22png document.pdf page1.png
.fi

.SS Page Selection
Convert page 5:
.PP
.nf
pdf22png -p 5 document.pdf page5.png
.fi

Convert pages 1-10 and 15:
.PP
.nf
pdf22png -p 1-10,15 document.pdf
.fi

.SS Batch Conversion
Convert all pages to individual PNGs:
.PP
.nf
pdf22png -a document.pdf
# Creates: document-001.png, document-002.png, etc.
.fi

Convert all pages to a specific directory:
.PP
.nf
pdf22png -d output/ document.pdf
.fi

.SS Resolution and Scaling
Convert at 300 DPI:
.PP
.nf
pdf22png -r 300 document.pdf high-res.png
.fi

Scale to 150%:
.PP
.nf
pdf22png -s 150% document.pdf scaled.png
.fi

Fit to 800x600 pixels:
.PP
.nf
pdf22png -s 800x600 document.pdf fitted.png
.fi

.SS Advanced Features
Preserve transparency:
.PP
.nf
pdf22png -t document.pdf transparent.png
.fi

Custom naming pattern:
.PP
.nf
pdf22png -a -P '{basename}_page{page:03d}' document.pdf
# Creates: document_page001.png, document_page002.png, etc.
.fi

Dry run to preview operations:
.PP
.nf
pdf22png -D -a document.pdf
.fi

.SS Pipeline Operations
From stdin to stdout:
.PP
.nf
cat document.pdf | pdf22png - - > output.png
.fi

Process and pipe to ImageMagick:
.PP
.nf
pdf22png -r 300 input.pdf - | convert - -resize 50% final.jpg
.fi

.SH MEMORY MANAGEMENT
pdf22png includes advanced memory management features:

.IP \(bu 2
Real-time memory pressure monitoring
.IP \(bu 2
Adaptive batch sizing based on available memory
.IP \(bu 2
Automatic scale factor adjustment for complex PDFs
.IP \(bu 2
Resource exhaustion prevention

Use the -v flag to see memory usage statistics during processing.

.SH SIGNAL HANDLING
The tool handles interruption signals gracefully:

.IP \(bu 2
\fBSIGINT\fR (Ctrl+C): Graceful shutdown with resource cleanup
.IP \(bu 2
\fBSIGTERM\fR: Clean termination with partial results saved
.IP \(bu 2
\fBSIGHUP\fR: Handled like SIGTERM

Batch operations will save completed pages before terminating.

.SH EXIT STATUS
.TP
.B 0
Success
.TP
.B 1
General error
.TP
.B 2
Invalid command line arguments
.TP
.B 3
Input file not found
.TP
.B 4
Failed to read input file
.TP
.B 5
Failed to write output file
.TP
.B 6
No input data received
.TP
.B 7
Invalid PDF document
.TP
.B 8
PDF document is encrypted
.TP
.B 9
PDF document has no pages
.TP
.B 10
Requested page does not exist
.TP
.B 11
Failed to render PDF page
.TP
.B 12
Memory allocation failed
.TP
.B 13
Failed to create output directory
.TP
.B 14
Invalid scale specification
.TP
.B 15
Batch processing failed
.TP
.B 16
Operation interrupted by signal

.SH ENVIRONMENT
.TP
.B CG_PDF_VERBOSE
Set to enable verbose Core Graphics PDF logging for debugging.

.SH FILES
.TP
.I ~/.pdf22pngrc
User configuration file (future feature).

.SH LIMITATIONS
.IP \(bu 2
Password-protected PDFs are not currently supported
.IP \(bu 2
Maximum 5000 pages per document
.IP \(bu 2
Maximum 500MB input file size
.IP \(bu 2
PNG compression quality setting is currently informational

.SH BUGS
Report bugs at: https://github.com/twardoch/pdf22png/issues

.SH AUTHOR
Written by Adam Twardoch and contributors.

.SH COPYRIGHT
Copyright (C) 2024 Adam Twardoch. Licensed under the Apache License 2.0.

.SH SEE ALSO
.BR convert (1),
.BR sips (1),
.BR qlmanage (1)

Project homepage: https://github.com/twardoch/pdf22png
</file>

<file path="docs/USAGE.md">
# pdf22png Usage

`pdf22png` is a command-line tool to convert PDF documents to PNG images on macOS.

## Synopsis

```bash
pdf22png [OPTIONS] <input.pdf> [output.png | output_format_%%d.png]
```

## Arguments

*   `<input.pdf>`: (Required) The path to the input PDF file. Use `-` to read from stdin.
*   `[output.png | output_format_%%d.png]`: (Optional) The name for the output PNG file.
    *   In single page mode: If specified, this is the exact output filename. If omitted and input is a file, it's an error. If omitted and input is stdin, output goes to stdout.
    *   In batch mode (`-a` or `-d`): This is treated as a filename prefix. Page numbers will be appended (e.g., `prefix-001.png`). If omitted, the prefix is derived from the input filename or defaults to "page".
    *   Use `-` for stdout in single page mode. Cannot be used with batch mode.

## Options

| Short | Long           | Argument        | Description                                                                                                | Default        |
|-------|----------------|-----------------|------------------------------------------------------------------------------------------------------------|----------------|
| `-p`  | `--page`       | `<n>`           | Convert a specific page number. Ignored if `-a` or `-d` is used.                                             | `1`            |
| `-a`  | `--all`        |                 | Convert all pages in the PDF. If `-d` is not given, output files are placed in the current directory.        | Disabled       |
| `-r`  | `--resolution` | `<dpi>`         | Set the output resolution in Dots Per Inch (e.g., `150`, `300dpi`).                                          | `144dpi`       |
| `-s`  | `--scale`      | `<spec>`        | Set the scaling for the output image. Overridden by `-r` if both specify numeric scaling. See syntax below.  | `1.0` or `100%`|
| `-t`  | `--transparent`|                 | Render the PNG with a transparent background instead of white.                                               | Disabled       |
| `-q`  | `--quality`    | `<n>`           | PNG compression quality (0-9). Higher is typically less compression. (Currently informational for PNG)     | `6`            |
| `-o`  | `--output`     | `<path/prefix>` | Specify the output file path or prefix for batch mode. Use `-` for stdout (single page only).                | Varies         |
| `-d`  | `--directory`  | `<dir>`         | Specify the output directory for batch mode. Implies `-a`.                                                   | Current dir    |
| `-v`  | `--verbose`    |                 | Enable verbose logging output to stderr.                                                                     | Disabled       |
| `-h`  | `--help`       |                 | Display the help message and exit.                                                                         |                |

### Scale Specification (`-s, --scale <spec>`)

The `<spec>` argument for the scale option can be:

*   **Percentage:** `NNN%` (e.g., `150%` for 1.5x scale, `50%` for 0.5x scale).
*   **Factor:** `N.N` (e.g., `2.0` for 2x scale, `0.75` for 0.75x scale).
*   **Dimensions:**
    *   `WxH`: Fit image within `W` pixels width AND `H` pixels height, maintaining aspect ratio (e.g., `800x600`).
    *   `Wx`: Fit image to `W` pixels width, height is auto-scaled (e.g., `1024x`).
    *   `xH`: Fit image to `H` pixels height, width is auto-scaled (e.g., `x768`).
*   **DPI (alternative to `-r`):** `NNNdpi` (e.g., `300dpi`). If both `-s NNNdpi` and `-r NNNdpi` are used, the last one parsed takes precedence. It's recommended to use `-r` for DPI settings for clarity.

### Default Behavior

*   If no input file is given and stdin is not a pipe, an error occurs.
*   If input is from stdin and no output is specified via `-o` or a positional argument, output goes to stdout (single page mode only).
*   If `-a` or `-d` is used (batch mode):
    *   All pages are converted.
    *   If `-d` is not specified, output is to the current directory.
    *   If `-o` is not specified, the output filename prefix is derived from the input PDF's name (e.g., `input.pdf` -> `input-`). If input is stdin, prefix is `page-`.
    *   Output filenames are formatted as `<prefix><page_number_padded_with_zeros>.png` (e.g., `mypdf-001.png`, `mypdf-002.png`).

See `EXAMPLES.md` for practical examples.
</file>

<file path="homebrew/pdf22png.rb">
class Pdf22png < Formula
  desc "High-performance PDF to PNG converter for macOS"
  homepage "https://github.com/twardoch/pdf22png"
  url "https://github.com/twardoch/pdf22png/archive/refs/tags/v1.0.0.tar.gz"
  sha256 "YOUR_SHA256_HERE"
  license "MIT"
  head "https://github.com/twardoch/pdf22png.git", branch: "main"

  depends_on :macos

  def install
    system "make", "PREFIX=#{prefix}"
    system "make", "install", "PREFIX=#{prefix}"
  end

  test do
    # Create a simple test PDF
    (testpath/"test.pdf").write <<~EOS
      %PDF-1.4
      1 0 obj << /Type /Catalog /Pages 2 0 R >> endobj
      2 0 obj << /Type /Pages /Kids [3 0 R] /Count 1 >> endobj
      3 0 obj << /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] >> endobj
      xref
      0 4
      0000000000 65535 f
      0000000009 00000 n
      0000000058 00000 n
      0000000115 00000 n
      trailer << /Size 4 /Root 1 0 R >>
      startxref
      190
      %%EOF
    EOS

    system "#{bin}/pdf22png", "test.pdf", "output.png"
    assert_predicate testpath/"output.png", :exist?
  end
end
</file>

<file path="scripts/install.sh">
#!/usr/bin/env bash
# this_file: scripts/install.sh

set -euo pipefail

REPO="twardoch/pdf22png"
INSTALL_DIR="/usr/local/bin"

echo "Installing pdf22png..."

# Check if Homebrew is installed
if command -v brew &> /dev/null; then
    echo "Homebrew detected. Installing via Homebrew..."
    brew tap twardoch/tap
    brew install pdf22png
else
    echo "Building from source..."

    # Clone repo
    git clone "https://github.com/${REPO}.git" /tmp/pdf22png
    cd /tmp/pdf22png

    # Build
    make

    # Install
    sudo make install

    # Cleanup
    cd -
    rm -rf /tmp/pdf22png
fi

echo "Installation complete! Run 'pdf22png --help' to get started."
</file>

<file path="scripts/uninstall.sh">
#!/usr/bin/env bash
# this_file: scripts/uninstall.sh

# Uninstallation script for pdf22png

set -euo pipefail

PRODUCT_NAME="pdf22png"
INSTALL_DIR="/usr/local/bin"
INSTALLED_PATH="${INSTALL_DIR}/${PRODUCT_NAME}"

echo "Uninstalling ${PRODUCT_NAME}..."

if [ -f "${INSTALLED_PATH}" ]; then
    echo "Found ${PRODUCT_NAME} at ${INSTALLED_PATH}."
    # Check if it was installed by Homebrew
    if command -v brew &> /dev/null && brew list --formula | grep -q "^${PRODUCT_NAME}\$" ; then
        echo "${PRODUCT_NAME} appears to be installed via Homebrew."
        echo "Please run 'brew uninstall ${PRODUCT_NAME}' to remove it."
        # Optionally, ask if user wants to proceed with Homebrew uninstall
        # read -p "Do you want to run 'brew uninstall ${PRODUCT_NAME}' now? (y/N) " choice
        # case "$choice" in
        #   y|Y ) brew uninstall ${PRODUCT_NAME};;
        #   * ) echo "Skipping Homebrew uninstall.";;
        # esac
        exit 0
    elif command -v brew &> /dev/null && brew list --cask | grep -q "^${PRODUCT_NAME}\$" ; then
        echo "${PRODUCT_NAME} appears to be installed as a Homebrew Cask."
        echo "Please run 'brew uninstall --cask ${PRODUCT_NAME}' to remove it."
        exit 0
    else
        echo "Attempting to remove ${PRODUCT_NAME} from ${INSTALLED_PATH}..."
        if sudo rm -f "${INSTALLED_PATH}"; then
            echo "${PRODUCT_NAME} removed successfully."
        else
            echo "Failed to remove ${PRODUCT_NAME}. You may need to run this script with sudo or remove it manually."
            exit 1
        fi
    fi
else
    echo "${PRODUCT_NAME} not found at ${INSTALLED_PATH} (standard location)."
    echo "If you installed it to a custom location, you may need to remove it manually."
    echo "If installed via Homebrew, try 'brew uninstall ${PRODUCT_NAME}'."
fi

# Attempt to remove from common tap if it exists (best effort)
TAP_OWNER="twardoch" # As per install script
TAP_NAME="tap"       # As per install script
FORMULA_PATH_IN_TAP="Formula/${PRODUCT_NAME}.rb" # Common pattern for taps

if command -v brew &> /dev/null; then
    TAP_DIR_STANDARD="$(brew --prefix)/Homebrew/Library/Taps/${TAP_OWNER}/${TAP_NAME}"
    TAP_DIR_ALTERNATIVE="/opt/homebrew/Library/Taps/${TAP_OWNER}/${TAP_NAME}" # For Apple Silicon default brew location

    FORMULA_IN_TAP_STANDARD="${TAP_DIR_STANDARD}/${FORMULA_PATH_IN_TAP}"
    FORMULA_IN_TAP_ALTERNATIVE="${TAP_DIR_ALTERNATIVE}/${FORMULA_PATH_IN_TAP}"

    # Check if the formula file exists within a known tap structure
    # This is a heuristic and might not cover all tap configurations.
    # A more robust check would be `brew tap | grep ...` but that's more complex to parse reliably.

    # We don't automatically untap, as the user might have other formulae from the same tap.
    # We also don't remove the formula file from the tap, as `brew uninstall` should handle that.
    # This section is more for informational purposes.
    if [ -f "${FORMULA_IN_TAP_STANDARD}" ] || [ -f "${FORMULA_IN_TAP_ALTERNATIVE}" ]; then
        echo "Note: If you installed via 'brew tap ${TAP_OWNER}/${TAP_NAME}', the tap itself ('${TAP_OWNER}/${TAP_NAME}') is not automatically removed."
        echo "You can untap it using 'brew untap ${TAP_OWNER}/${TAP_NAME}' if you no longer need any formulae from it."
    fi
fi


echo "Uninstallation process complete."
</file>

<file path="src/CLI/ArgumentParser.swift">
import Foundation

// MARK: - Command Line Argument Parser

struct ArgumentParser {
    static func parseArguments() -> ProcessingOptions {
        var options = ProcessingOptions()
        let args = Array(CommandLine.arguments.dropFirst())
        var i = 0
        
        while i < args.count {
            let arg = args[i]
            
            switch arg {
            case "-h", "--help":
                options.showHelp = true
                return options
                
            case "--version":
                options.showVersion = true
                return options
                
            case "-p", "--page":
                guard i + 1 < args.count else {
                    print("Error: --page requires a value")
                    exit(2)
                }
                options.page = args[i + 1]
                i += 1
                
            case "-a", "--all":
                options.allPages = true
                
            case "-r", "--resolution":
                guard i + 1 < args.count else {
                    print("Error: --resolution requires a value")
                    exit(2)
                }
                options.resolution = args[i + 1]
                i += 1
                
            case "-s", "--scale":
                guard i + 1 < args.count else {
                    print("Error: --scale requires a value")
                    exit(2)
                }
                options.scale = args[i + 1]
                i += 1
                
            case "-t", "--transparent":
                options.transparent = true
                
            case "-q", "--quality":
                guard i + 1 < args.count else {
                    print("Error: --quality requires a value")
                    exit(2)
                }
                guard let quality = Int(args[i + 1]), quality >= 0 && quality <= 9 else {
                    print("Error: quality must be between 0 and 9")
                    exit(2)
                }
                options.quality = quality
                i += 1
                
            case "-o", "--output":
                guard i + 1 < args.count else {
                    print("Error: --output requires a value")
                    exit(2)
                }
                options.outputPath = args[i + 1]
                i += 1
                
            case "-d", "--directory":
                guard i + 1 < args.count else {
                    print("Error: --directory requires a value")
                    exit(2)
                }
                options.directory = args[i + 1]
                i += 1
                
            case "-v", "--verbose":
                options.verbose = true
                
            case "-n", "--name":
                options.includeText = true
                
            case "-P", "--pattern":
                guard i + 1 < args.count else {
                    print("Error: --pattern requires a value")
                    exit(2)
                }
                options.namingPattern = args[i + 1]
                i += 1
                
            case "-D", "--dry-run":
                options.dryRun = true
                
            case "-f", "--force":
                options.forceOverwrite = true
                
            default:
                if arg.hasPrefix("-") {
                    print("Error: Unknown option: \(arg)")
                    print("Use --help for usage information")
                    exit(2)
                } else {
                    // Positional arguments
                    if options.inputFile == nil {
                        options.inputFile = arg
                    } else if options.outputFile == nil {
                        options.outputFile = arg
                    } else {
                        print("Error: Too many arguments")
                        exit(2)
                    }
                }
            }
            i += 1
        }
        
        return options
    }
    
    static func validateArguments(_ options: ProcessingOptions) throws {
        // Input validation
        if options.inputFile == nil && !options.isStdinMode {
            throw PDF22PNGError.noInput
        }
        
        // Output validation for single page mode
        if !options.isBatchMode && options.outputFile == nil && options.outputPath == nil {
            throw PDF22PNGError.invalidArgs
        }
        
        // Scale validation
        if ScaleParser.parseScaleSpecification(options.effectiveScale) == nil {
            throw PDF22PNGError.invalidScale
        }
        
        // Quality validation (already handled in parsing)
        if options.quality < 0 || options.quality > 9 {
            throw PDF22PNGError.invalidArgs
        }
    }
}
</file>

<file path="src/CLI/OutputFormatter.swift">
import Foundation

// MARK: - Output Formatter

struct OutputFormatter {
    static func printHelp() {
        print("""
Usage: pdf22png [OPTIONS] <input.pdf> [output.png]
Converts PDF documents to PNG images.

Options:
  -p, --page <spec>       Page(s) to convert. Single page, range, or comma-separated.
                          Examples: 1 | 1-5 | 1,3,5-10 (default: 1)
                          In batch mode, only specified pages are converted.
  -a, --all               Convert all pages. If -d is not given, uses input filename as prefix.
                          Output files named <prefix>-<page_num>.png.
  -r, --resolution <dpi>  Set output DPI (e.g., 150dpi). Overrides -s if both used with numbers.
  -s, --scale <spec>      Scaling specification (default: 100% or 1.0).
                            NNN%: percentage (e.g., 150%)
                            N.N:  scale factor (e.g., 1.5)
                            WxH:  fit to WxH pixels (e.g., 800x600)
                            Wx:   fit to width W pixels (e.g., 1024x)
                            xH:   fit to height H pixels (e.g., x768)
  -t, --transparent       Preserve transparency (default: white background).
  -q, --quality <n>       PNG compression quality (0-9, default: 6). Currently informational.
  -o, --output <path>     Output PNG file or prefix for batch mode.
                          If '-', output to stdout (single page mode only).
  -d, --directory <dir>   Output directory for batch mode (converts all pages).
                          If used, -o specifies filename prefix inside this directory.
  -v, --verbose           Verbose output.
  -n, --name              Include extracted text in output filename (batch mode only).
  -P, --pattern <pat>     Custom naming pattern for batch mode. Placeholders:
                          {basename} - Input filename without extension
                          {page} - Page number (auto-padded)
                          {page:03d} - Page with custom padding
                          {text} - Extracted text (requires -n)
                          {date} - Current date (YYYYMMDD)
                          {time} - Current time (HHMMSS)
                          {total} - Total page count
                          Example: '{basename}_p{page:04d}_of_{total}'
  -D, --dry-run           Preview operations without writing files.
  -f, --force             Force overwrite existing files without prompting.
  -h, --help              Show this help message and exit.
  --version               Show version information and exit.

Arguments:
  <input.pdf>             Input PDF file. If '-', reads from stdin.
  [output.png]            Output PNG file. Required if not using -o or -d.
                          If input is stdin and output is not specified, output goes to stdout.
                          In batch mode (-a or -d), this is used as a prefix if -o is not set.

Examples:
  pdf22png document.pdf page1.png              # Convert first page
  pdf22png -p 5 document.pdf page5.png         # Convert page 5
  pdf22png -a document.pdf                     # Convert all pages (document-001.png, ...)
  pdf22png -r 300 document.pdf hi-res.png      # High resolution
  pdf22png -s 150% document.pdf large.png      # 1.5x scale
  pdf22png -d output/ document.pdf             # All pages to output/ directory
  pdf22png -t document.pdf transparent.png     # Preserve transparency
  cat document.pdf | pdf22png - output.png     # From stdin
""")
    }
    
    static func printVersion() {
        let version = "2.0.0-standalone"
        print("pdf22png \(version)")
        print("Swift standalone implementation")
    }
    
    static func formatError(_ error: PDF22PNGError, context: String? = nil) -> String {
        var output = "❌ Error: \(error.errorDescription ?? "Unknown error")"
        
        if let ctx = context {
            output += "\n📍 Context: \(ctx)"
        }
        
        if let suggestion = error.recoverySuggestion {
            output += "\n💡 Help: \(suggestion)"
        }
        
        return output
    }
    
    static func formatProgress(_ progress: ProgressInfo) -> String {
        let percentage = Int((Double(progress.completed) / Double(progress.total)) * 100)
        let progressBar = createProgressBar(percentage: percentage)
        
        var output = "\r\(progressBar) \(percentage)% (\(progress.completed)/\(progress.total))"
        
        if let speed = progress.speed {
            output += " - \(String(format: "%.1f", speed)) pages/sec"
        }
        
        if let eta = progress.estimatedTimeRemaining {
            output += " - ETA: \(formatDuration(eta))"
        }
        
        return output
    }
    
    static func formatResults(_ results: ProcessingResults) -> String {
        var output = "\n✅ Processing complete!\n"
        output += "   Total: \(results.totalPages) pages"
        
        if results.processingTime > 0 {
            output += " in \(formatDuration(results.processingTime))"
        }
        
        output += "\n   Results: ✓ \(results.successfulPages) successful"
        
        if results.failedPages > 0 {
            output += ", ✗ \(results.failedPages) failed"
        }
        
        if results.pagesPerSecond > 0 {
            output += "\n   Average speed: \(String(format: "%.1f", results.pagesPerSecond)) pages/sec"
        }
        
        return output
    }
    
    private static func createProgressBar(percentage: Int, width: Int = 20) -> String {
        let filled = Int(Double(percentage) / 100.0 * Double(width))
        let empty = width - filled
        return "[" + String(repeating: "█", count: filled) + String(repeating: "░", count: empty) + "]"
    }
    
    private static func formatDuration(_ seconds: TimeInterval) -> String {
        let minutes = Int(seconds) / 60
        let secs = Int(seconds) % 60
        if minutes > 0 {
            return "\(minutes)m \(secs)s"
        } else {
            return "\(secs)s"
        }
    }
}

// MARK: - Progress Info

struct ProgressInfo {
    let completed: Int
    let total: Int
    let speed: Double?
    let estimatedTimeRemaining: TimeInterval?
    let currentOperation: String?
}
</file>

<file path="src/Core/BatchProcessor.swift">
import Foundation
import CoreGraphics
import PDFKit

// MARK: - Batch Processing

class BatchProcessor {
    static let shared = BatchProcessor()
    private init() {}
    
    struct BatchOptions {
        let totalPages: Int
        let outputDirectory: String
        let prefix: String
        let scaleFactor: CGFloat
        let transparent: Bool
        let quality: Int
        let verbose: Bool
        let dryRun: Bool
        let forceOverwrite: Bool
    }
    
    struct BatchResult {
        let totalPages: Int
        let successfulPages: Int
        let failedPages: Int
        let interrupted: Bool
    }
    
    func processBatch(document: PDFDocument, options: BatchOptions) async throws -> BatchResult {
        let totalPages = options.totalPages
        
        // Create output directory
        if !options.dryRun {
            do {
                try FileManager.default.createDirectory(atPath: options.outputDirectory, withIntermediateDirectories: true, attributes: nil)
            } catch {
                throw PDF22PNGError.outputDir
            }
        }
        
        // Calculate optimal batch size based on memory
        guard let firstPage = document.page(at: 0) else {
            throw PDF22PNGError.renderFailed
        }
        
        let pageRect = firstPage.bounds(for: .mediaBox)
        let optimalBatchSize = MemoryManager.shared.calculateOptimalBatchSize(
            totalPages: totalPages,
            pageRect: pageRect,
            scaleFactor: options.scaleFactor,
            verbose: options.verbose
        )
        
        // Initialize progress reporter
        let progressReporter = ProgressReporter(totalPages: totalPages, verbose: options.verbose)
        
        if !options.dryRun {
            print("🚀 Starting batch conversion of \(totalPages) pages...")
            if options.verbose {
                print("   Output directory: \(options.outputDirectory)")
                print("   Output prefix: \(options.prefix)")
                print("   Batch size: \(optimalBatchSize) pages/chunk")
            }
        }
        
        // Process pages in memory-optimized chunks
        let chunks = stride(from: 1, through: totalPages, by: optimalBatchSize).map { start in
            Array(start..<min(start + optimalBatchSize, totalPages + 1))
        }
        
        var successfulPages = 0
        var failedPages = 0
        var interrupted = false
        
        for (chunkIndex, chunk) in chunks.enumerated() {
            // Check for interruption before each chunk
            do {
                try checkInterruption()
            } catch {
                interrupted = true
                break
            }
            
            // Check memory pressure before each chunk
            do {
                try MemoryManager.shared.checkMemoryPressureDuringBatch(verbose: options.verbose)
            } catch {
                // Continue processing even under memory pressure
            }
            
            progressReporter.reportChunkStart(chunkNumber: chunkIndex + 1, totalChunks: chunks.count, pagesInChunk: chunk.count)
            
            for pageNum in chunk {
                // Check for interruption for each page
                do {
                    try checkInterruption()
                } catch {
                    interrupted = true
                    break
                }
                
                progressReporter.reportPageStart(pageNumber: pageNum)
                
                guard let pdfPage = document.page(at: pageNum - 1) else {
                    progressReporter.reportPageComplete(pageNumber: pageNum, success: false)
                    failedPages += 1
                    continue
                }
                
                let renderOptions = ImageRenderer.RenderOptions(
                    scaleFactor: options.scaleFactor,
                    transparentBackground: options.transparent,
                    quality: options.quality,
                    verbose: options.verbose,
                    dryRun: options.dryRun,
                    forceOverwrite: options.forceOverwrite
                )
                
                guard let image = ImageRenderer.shared.renderPageToImage(page: pdfPage, options: renderOptions) else {
                    progressReporter.reportPageComplete(pageNumber: pageNum, success: false)
                    failedPages += 1
                    continue
                }
                
                let filename = String(format: "%@-%03d.png", options.prefix, pageNum)
                let outputPath = (options.outputDirectory as NSString).appendingPathComponent(filename)
                
                if options.dryRun {
                    print("[DRY-RUN] Would create: \(filename) (\(image.width)x\(image.height) pixels)")
                    progressReporter.reportPageComplete(pageNumber: pageNum, success: true, outputFile: filename)
                    successfulPages += 1
                } else {
                    let success = ImageRenderer.shared.writeImageToFile(image: image, path: outputPath, options: renderOptions)
                    progressReporter.reportPageComplete(pageNumber: pageNum, success: success, outputFile: success ? filename : nil)
                    if success {
                        successfulPages += 1
                    } else {
                        failedPages += 1
                    }
                }
            }
            
            // Log memory status after each chunk in verbose mode
            if options.verbose && chunks.count > 1 {
                MemoryManager.shared.logMemoryStatus(verbose: true)
            }
            
            if interrupted {
                progressReporter.reportInterrupted()
                break
            }
        }
        
        // Final status report
        if options.dryRun && !interrupted {
            print("\n[DRY-RUN] Would convert \(totalPages) pages to PNG files")
        } else if !interrupted {
            progressReporter.reportBatchComplete()
        }
        
        return BatchResult(
            totalPages: totalPages,
            successfulPages: successfulPages,
            failedPages: failedPages,
            interrupted: interrupted
        )
    }
    
    func calculateOptimalConcurrency(pages: Int, memoryRequirement: UInt64) -> Int {
        let memInfo = MemoryManager.shared.getSystemMemoryInfo()
        let availableMemory = memInfo.available / 2 // Use only half of available memory
        let maxConcurrentPages = max(1, Int(availableMemory / memoryRequirement))
        return min(pages, maxConcurrentPages)
    }
}
</file>

<file path="src/Core/ImageRenderer.swift">
import Foundation
import CoreGraphics
import PDFKit
import UniformTypeIdentifiers

// MARK: - Image Rendering

class ImageRenderer {
    static let shared = ImageRenderer()
    private init() {}
    
    struct RenderOptions {
        let scaleFactor: CGFloat
        let transparentBackground: Bool
        let quality: Int
        let verbose: Bool
        let dryRun: Bool
        let forceOverwrite: Bool
    }
    
    func renderPageToImage(page: PDFPage, options: RenderOptions) -> CGImage? {
        let pageRect = page.bounds(for: .mediaBox)
        let scaledWidth = Int(pageRect.width * options.scaleFactor)
        let scaledHeight = Int(pageRect.height * options.scaleFactor)
        
        logMessage(options.verbose, "Rendering page at \(scaledWidth)x\(scaledHeight) (scale: \(options.scaleFactor))")
        
        let colorSpace = CGColorSpaceCreateDeviceRGB()
        let bitmapInfo: CGBitmapInfo = options.transparentBackground ? 
            [.byteOrder32Big, CGBitmapInfo(rawValue: CGImageAlphaInfo.premultipliedLast.rawValue)] :
            [.byteOrder32Big, CGBitmapInfo(rawValue: CGImageAlphaInfo.noneSkipLast.rawValue)]
        
        guard let context = CGContext(
            data: nil,
            width: scaledWidth,
            height: scaledHeight,
            bitsPerComponent: 8,
            bytesPerRow: 0,
            space: colorSpace,
            bitmapInfo: bitmapInfo.rawValue
        ) else {
            return nil
        }
        
        context.scaleBy(x: options.scaleFactor, y: options.scaleFactor)
        
        if !options.transparentBackground {
            context.setFillColor(CGColor.white)
            context.fill(CGRect(x: 0, y: 0, width: pageRect.width, height: pageRect.height))
        }
        
        page.draw(with: .mediaBox, to: context)
        
        return context.makeImage()
    }
    
    func writeImageToFile(image: CGImage, path: String, options: RenderOptions) -> Bool {
        if options.dryRun {
            let width = image.width
            let height = image.height
            print("[DRY-RUN] Would write \(width)x\(height) PNG to: \(path)")
            return true
        }
        
        // Check if file exists and handle overwrite
        if FileManager.default.fileExists(atPath: path) && !options.forceOverwrite {
            print("File \(path) already exists. Use --force to overwrite.")
            return false
        }
        
        let url = URL(fileURLWithPath: path)
        guard let destination = CGImageDestinationCreateWithURL(url as CFURL, UTType.png.identifier as CFString, 1, nil) else {
            return false
        }
        
        let compressionOptions: [CFString: Any] = [
            kCGImageDestinationLossyCompressionQuality: CGFloat(options.quality) / 9.0
        ]
        
        CGImageDestinationAddImage(destination, image, compressionOptions as CFDictionary)
        let success = CGImageDestinationFinalize(destination)
        
        if success {
            logMessage(options.verbose, "Successfully wrote PNG to: \(path)")
        }
        
        return success
    }
    
    func writeImageToStdout(image: CGImage, options: RenderOptions) -> Bool {
        logMessage(options.verbose, "Writing PNG to stdout")
        
        let data = NSMutableData()
        guard let destination = CGImageDestinationCreateWithData(data, UTType.png.identifier as CFString, 1, nil) else {
            return false
        }
        
        let compressionOptions: [CFString: Any] = [
            kCGImageDestinationLossyCompressionQuality: CGFloat(options.quality) / 9.0
        ]
        
        CGImageDestinationAddImage(destination, image, compressionOptions as CFDictionary)
        guard CGImageDestinationFinalize(destination) else {
            return false
        }
        
        let stdout = FileHandle.standardOutput
        stdout.write(data as Data)
        return true
    }
    
    func calculateScaleFactor(spec: ScaleSpecification, pageRect: CGRect) -> CGFloat {
        switch spec {
        case .percentage(let percent):
            return percent / 100.0
        case .factor(let factor):
            return factor
        case .resolution(let dpi):
            return dpi / 72.0  // 72 DPI is the default PDF resolution
        case .width(let width):
            return width / pageRect.width
        case .height(let height):
            return height / pageRect.height
        case .fit(let width, let height):
            let scaleX = width / pageRect.width
            let scaleY = height / pageRect.height
            return min(scaleX, scaleY)
        }
    }
}
</file>

<file path="src/Core/PDFProcessor.swift">
import Foundation
import CoreGraphics
import PDFKit
import UniformTypeIdentifiers

// MARK: - PDF Processing

class PDFProcessor {
    static let shared = PDFProcessor()
    private init() {}
    
    func readPDFData(_ inputPath: String?, verbose: Bool) -> Data? {
        if let path = inputPath, path != "-" {
            logMessage(verbose, "Reading PDF from file: \(path)")
            return FileManager.default.contents(atPath: path)
        } else {
            logMessage(verbose, "Reading PDF from stdin")
            let stdin = FileHandle.standardInput
            return stdin.readDataToEndOfFile()
        }
    }
    
    func createPDFDocument(from data: Data) -> PDFDocument? {
        return PDFDocument(data: data)
    }
    
    func validatePDF(_ document: PDFDocument) -> Bool {
        return document.pageCount > 0
    }
    
    func getPageCount(_ document: PDFDocument) -> Int {
        return document.pageCount
    }
    
    func extractPage(_ document: PDFDocument, pageNumber: Int) -> PDFPage? {
        guard pageNumber > 0 && pageNumber <= document.pageCount else {
            return nil
        }
        return document.page(at: pageNumber - 1) // Convert to 0-based index
    }
}
</file>

<file path="src/Core/ResourceManager.swift">
import Foundation

// MARK: - Resource Management System

class ResourceManager {
    static let shared = ResourceManager()
    private init() {}
    
    private var tempFiles: Set<String> = []
    private var fileHandles: Set<ObjectIdentifier> = []
    private let resourceQueue = DispatchQueue(label: "resource.management", qos: .utility)
    
    func registerTempFile(_ path: String) {
        resourceQueue.sync {
            _ = tempFiles.insert(path)
        }
    }
    
    func unregisterTempFile(_ path: String) {
        resourceQueue.sync {
            _ = tempFiles.remove(path)
        }
    }
    
    func registerFileHandle(_ handle: FileHandle) {
        resourceQueue.sync {
            _ = fileHandles.insert(ObjectIdentifier(handle))
        }
    }
    
    func unregisterFileHandle(_ handle: FileHandle) {
        resourceQueue.sync {
            _ = fileHandles.remove(ObjectIdentifier(handle))
        }
    }
    
    func cleanupAllResources() {
        resourceQueue.sync {
            // Clean up temporary files
            for tempFile in tempFiles {
                do {
                    if FileManager.default.fileExists(atPath: tempFile) {
                        try FileManager.default.removeItem(atPath: tempFile)
                    }
                } catch {
                    // Ignore cleanup errors
                }
            }
            tempFiles.removeAll()
            
            // Clear file handle tracking
            fileHandles.removeAll()
        }
    }
    
    func createSecureTempFile(prefix: String = "pdf22png", suffix: String = ".tmp") -> String? {
        let tempDir = NSTemporaryDirectory()
        let tempFileName = "\(prefix)_\(UUID().uuidString)\(suffix)"
        let tempPath = (tempDir as NSString).appendingPathComponent(tempFileName)
        
        // Create the file with secure permissions (600)
        let success = FileManager.default.createFile(atPath: tempPath, contents: nil, attributes: [
            .posixPermissions: 0o600
        ])
        
        if success {
            registerTempFile(tempPath)
            return tempPath
        }
        
        return nil
    }
}
</file>

<file path="src/Core/SignalHandler.swift">
import Foundation

// MARK: - Enhanced Signal Handling

class SignalHandler {
    static let shared = SignalHandler()
    private init() {}
    
    private var shouldTerminate = false
    private var cleanupHandlers: [() -> Void] = []
    private let signalQueue = DispatchQueue(label: "signal.handling", qos: .utility)
    
    var isTerminated: Bool {
        return shouldTerminate
    }
    
    func installSignalHandlers() {
        // Handle SIGINT (Ctrl+C)
        signal(SIGINT) { _ in
            SignalHandler.shared.handleGracefulShutdown(signal: "SIGINT")
        }
        
        // Handle SIGTERM (termination request)
        signal(SIGTERM) { _ in
            SignalHandler.shared.handleGracefulShutdown(signal: "SIGTERM")
        }
        
        // Handle SIGHUP (hangup)
        signal(SIGHUP) { _ in
            SignalHandler.shared.handleGracefulShutdown(signal: "SIGHUP")
        }
    }
    
    private func handleGracefulShutdown(signal: String) {
        shouldTerminate = true
        
        fputs("\n📡 Received \(signal), initiating graceful shutdown...\n", stderr)
        fflush(stderr)
        
        // Perform cleanup on a separate queue to avoid deadlocks
        signalQueue.async {
            self.performCleanup()
            
            // Give a brief moment for current operations to finish
            usleep(100_000) // 100ms
            
            fputs("✅ Cleanup complete. Exiting.\n", stderr)
            fflush(stderr)
            exit(1)
        }
    }
    
    private func performCleanup() {
        // Execute registered cleanup handlers
        for handler in cleanupHandlers {
            handler()
        }
        cleanupHandlers.removeAll()
        
        // Clean up resources
        ResourceManager.shared.cleanupAllResources()
    }
    
    func registerCleanupHandler(_ handler: @escaping () -> Void) {
        cleanupHandlers.append(handler)
    }
    
    func checkInterruption() throws {
        if shouldTerminate {
            throw PDF22PNGError.signalInterruption
        }
    }
}
</file>

<file path="src/Models/Errors.swift">
import Foundation

// MARK: - Error Types

enum PDF22PNGError: Int, Error, LocalizedError {
    case success = 0
    case generalError = 1
    case invalidArgs = 2
    case fileNotFound = 3
    case fileRead = 4
    case fileWrite = 5
    case noInput = 6
    case invalidPDF = 7
    case encryptedPDF = 8
    case emptyPDF = 9
    case pageNotFound = 10
    case renderFailed = 11
    case memory = 12
    case outputDir = 13
    case invalidScale = 14
    case batchFailed = 15
    case signalInterruption = 16
    
    var errorDescription: String? {
        switch self {
        case .success: return "Success"
        case .generalError: return "General error occurred"
        case .invalidArgs: return "Invalid command line arguments"
        case .fileNotFound: return "Input file not found"
        case .fileRead: return "Failed to read input file"
        case .fileWrite: return "Failed to write output file"
        case .noInput: return "No input data received"
        case .invalidPDF: return "Invalid PDF document"
        case .encryptedPDF: return "PDF document is encrypted"
        case .emptyPDF: return "PDF document has no pages"
        case .pageNotFound: return "Requested page does not exist"
        case .renderFailed: return "Failed to render PDF page"
        case .memory: return "Memory allocation failed"
        case .outputDir: return "Failed to create output directory"
        case .invalidScale: return "Invalid scale specification"
        case .batchFailed: return "Batch processing failed"
        case .signalInterruption: return "Operation interrupted by system signal"
        }
    }
    
    var recoverySuggestion: String? {
        switch self {
        case .invalidArgs:
            return "Check command syntax with --help flag. Verify all arguments are correct and use absolute paths."
        case .fileNotFound, .fileRead:
            return "Verify the file path is correct, the file exists, and you have read permissions."
        case .fileWrite:
            return "Check available disk space and write permissions to the output directory."
        case .invalidScale:
            return "Use valid formats: 150%, 2.0, 800x600, or 300dpi."
        case .pageNotFound:
            return "PDF pages start at 1. Use --verbose to see total page count."
        case .memory:
            return "Close other applications, use smaller scale factor, or process fewer pages at once."
        case .encryptedPDF:
            return "Remove password protection using Preview or qpdf command-line tool."
        default:
            return "Run with --verbose flag for detailed information. Check --help for usage examples."
        }
    }
}

struct ErrorReporter {
    static func reportError(_ error: PDF22PNGError, context: String? = nil) {
        print("❌ Error: \(error.errorDescription ?? "Unknown error")")
        
        if let ctx = context {
            print("📍 Context: \(ctx)")
        }
        
        if let suggestion = error.recoverySuggestion {
            print("\n💡 Help: \(suggestion)")
        }
        
        // Provide specific troubleshooting based on error type
        switch error {
        case .invalidArgs:
            print("\n💡 Input Validation Help:")
            print("   • Check command syntax with --help flag")
            print("   • Verify all arguments are correct")
            print("   • Use absolute paths to avoid confusion")
            
        case .fileNotFound:
            print("\n💡 File Access Help:")
            print("   • Verify the file path is correct and the file exists")
            print("   • Use absolute paths to avoid confusion")
            print("   • Check file permissions with 'ls -la'")
            
        case .fileRead:
            print("\n💡 File Access Help:")
            print("   • Check file permissions with 'ls -la'")
            print("   • Ensure you have read access to the file")
            print("   • Verify file is not corrupted")
            
        case .fileWrite:
            print("\n💡 File Write Help:")
            print("   • Check available disk space with 'df -h'")
            print("   • Verify write permissions to output directory")
            print("   • Try a different output location")
            
        case .invalidScale:
            print("\n💡 Scale Format Help:")
            print("   • Valid formats: 150%, 2.0, 800x600, 300dpi")
            print("   • Percentage: append % (e.g., 150%)")
            print("   • Factor: decimal number (e.g., 1.5)")
            print("   • Dimensions: WIDTHxHEIGHT (e.g., 1024x768)")
            
        case .pageNotFound:
            print("\n💡 Page Range Help:")
            print("   • PDF pages start at 1, not 0")
            print("   • Use --verbose to see total page count")
            print("   • Valid formats: 5 (single), 1-10 (range)")
            
        case .memory:
            print("\n💡 Memory Help:")
            print("   • Close other applications to free RAM")
            print("   • Use smaller scale factor: --scale 50%")
            print("   • Process fewer pages at once")
            
        case .encryptedPDF:
            print("\n💡 Encrypted PDF Help:")
            print("   • Remove password protection:")
            print("     - In Preview: File → Export As → PDF (uncheck Encrypt)")
            print("     - Command line: qpdf --decrypt --password=PASSWORD input.pdf output.pdf")
            
        default:
            print("\n💡 General Help:")
            print("   • Run with --verbose flag for detailed information")
            print("   • Check --help for usage examples")
            print("   • Try with a simpler PDF first")
        }
    }
}
</file>

<file path="src/Models/ProcessingOptions.swift">
import Foundation

// MARK: - Processing Options

struct ProcessingOptions {
    var inputFile: String?
    var outputFile: String?
    var page: String = "1"
    var allPages: Bool = false
    var resolution: String?
    var scale: String = "100%"
    var transparent: Bool = false
    var quality: Int = 6
    var outputPath: String?
    var directory: String?
    var verbose: Bool = false
    var includeText: Bool = false
    var namingPattern: String?
    var dryRun: Bool = false
    var forceOverwrite: Bool = false
    var showHelp: Bool = false
    var showVersion: Bool = false
    
    // Computed properties
    var effectiveScale: String {
        return resolution ?? scale
    }
    
    var effectiveOutputDirectory: String {
        return directory ?? "."
    }
    
    var isBatchMode: Bool {
        return allPages
    }
    
    var isStdoutMode: Bool {
        return outputPath == "-" || outputFile == "-"
    }
    
    var isStdinMode: Bool {
        return inputFile == "-" || inputFile == nil
    }
}
</file>

<file path="src/Models/Results.swift">
import Foundation

// MARK: - Result Types

struct ProcessingResults {
    let totalPages: Int
    let successfulPages: Int
    let failedPages: Int
    let interrupted: Bool
    let processingTime: TimeInterval
    let outputFiles: [String]
    
    var successRate: Double {
        guard totalPages > 0 else { return 0.0 }
        return Double(successfulPages) / Double(totalPages)
    }
    
    var pagesPerSecond: Double {
        guard processingTime > 0 else { return 0.0 }
        return Double(successfulPages) / processingTime
    }
    
    var isSuccessful: Bool {
        return failedPages == 0 && !interrupted
    }
}

struct PageResult {
    let pageNumber: Int
    let success: Bool
    let outputFile: String?
    let processingTime: TimeInterval
    let errorMessage: String?
    
    init(pageNumber: Int, success: Bool, outputFile: String? = nil, processingTime: TimeInterval = 0, error: Error? = nil) {
        self.pageNumber = pageNumber
        self.success = success
        self.outputFile = outputFile
        self.processingTime = processingTime
        self.errorMessage = error?.localizedDescription
    }
}

struct BatchResult {
    let totalPages: Int
    let successfulPages: Int
    let failedPages: Int
    let interrupted: Bool
    let processingTime: TimeInterval
    let pageResults: [PageResult]
    
    var processingResults: ProcessingResults {
        let outputFiles = pageResults.compactMap { $0.outputFile }
        return ProcessingResults(
            totalPages: totalPages,
            successfulPages: successfulPages,
            failedPages: failedPages,
            interrupted: interrupted,
            processingTime: processingTime,
            outputFiles: outputFiles
        )
    }
    
    init(totalPages: Int, successfulPages: Int, failedPages: Int, interrupted: Bool, processingTime: TimeInterval = 0, pageResults: [PageResult] = []) {
        self.totalPages = totalPages
        self.successfulPages = successfulPages
        self.failedPages = failedPages
        self.interrupted = interrupted
        self.processingTime = processingTime
        self.pageResults = pageResults
    }
}
</file>

<file path="src/Models/ScaleSpecification.swift">
import Foundation
import CoreGraphics

// MARK: - Scale Specification

enum ScaleSpecification {
    case percentage(CGFloat)
    case factor(CGFloat)
    case resolution(CGFloat)  // DPI
    case width(CGFloat)
    case height(CGFloat)
    case fit(width: CGFloat, height: CGFloat)
}

struct ScaleParser {
    static func parseScaleSpecification(_ scaleStr: String) -> ScaleSpecification? {
        let trimmed = scaleStr.trimmingCharacters(in: .whitespaces)
        
        if trimmed.hasSuffix("%") {
            let percentStr = String(trimmed.dropLast())
            guard let percent = Double(percentStr), percent > 0 else { return nil }
            return .percentage(CGFloat(percent))
        }
        
        if trimmed.hasSuffix("dpi") {
            let dpiStr = String(trimmed.dropLast(3))
            guard let dpi = Double(dpiStr), dpi > 0 else { return nil }
            return .resolution(CGFloat(dpi))
        }
        
        if trimmed.contains("x") {
            let parts = trimmed.components(separatedBy: "x")
            guard parts.count == 2 else { return nil }
            
            let widthStr = parts[0]
            let heightStr = parts[1]
            
            if !widthStr.isEmpty && !heightStr.isEmpty {
                guard let width = Double(widthStr), width > 0,
                      let height = Double(heightStr), height > 0 else { return nil }
                return .fit(width: CGFloat(width), height: CGFloat(height))
            } else if !widthStr.isEmpty {
                guard let width = Double(widthStr), width > 0 else { return nil }
                return .width(CGFloat(width))
            } else if !heightStr.isEmpty {
                guard let height = Double(heightStr), height > 0 else { return nil }
                return .height(CGFloat(height))
            }
            
            return nil
        }
        
        guard let factor = Double(trimmed), factor > 0 else { return nil }
        return .factor(CGFloat(factor))
    }
}
</file>

<file path="src/Utilities/InputValidator.swift">
import Foundation

// MARK: - Input Validation

class InputValidator {
    static let maxFileSize: UInt64 = 500 * 1024 * 1024 // 500MB
    static let maxPageNumber: Int = 10000
    static let maxTotalPages: Int = 5000
    static let maxPathLength: Int = 1024
    
    static func validateFilePath(_ path: String, allowCreate: Bool = false) throws -> String {
        // Check path length
        guard path.count <= maxPathLength else {
            throw PDF22PNGError.invalidArgs
        }
        
        // Prevent path traversal attacks
        let normalizedPath = (path as NSString).standardizingPath
        guard !normalizedPath.contains("../") && !normalizedPath.contains("..\\") else {
            throw PDF22PNGError.invalidArgs
        }
        
        // Check for null bytes and other dangerous characters
        guard !path.contains("\0") && !path.contains("\n") && !path.contains("\r") else {
            throw PDF22PNGError.invalidArgs
        }
        
        if !allowCreate {
            // For input files, check existence and size
            guard FileManager.default.fileExists(atPath: normalizedPath) else {
                throw PDF22PNGError.fileNotFound
            }
            
            do {
                let attributes = try FileManager.default.attributesOfItem(atPath: normalizedPath)
                if let fileSize = attributes[.size] as? UInt64, fileSize > maxFileSize {
                    throw PDF22PNGError.invalidArgs
                }
            } catch {
                throw PDF22PNGError.fileRead
            }
        }
        
        return normalizedPath
    }
    
    static func validateOutputDirectory(_ path: String) throws -> String {
        let normalizedPath = try validateFilePath(path, allowCreate: true)
        
        // Check if parent directory exists and is writable
        let parentDir = (normalizedPath as NSString).deletingLastPathComponent
        guard FileManager.default.fileExists(atPath: parentDir) else {
            throw PDF22PNGError.outputDir
        }
        
        guard FileManager.default.isWritableFile(atPath: parentDir) else {
            throw PDF22PNGError.fileWrite
        }
        
        return normalizedPath
    }
    
    static func validatePageNumber(_ page: Int, totalPages: Int) throws {
        guard page >= 1 && page <= totalPages else {
            throw PDF22PNGError.pageNotFound
        }
        
        guard page <= maxPageNumber else {
            throw PDF22PNGError.invalidArgs
        }
    }
    
    static func validatePageRange(_ range: String, totalPages: Int) throws {
        // Basic validation of page range format
        let validChars = CharacterSet(charactersIn: "0123456789,-")
        guard range.rangeOfCharacter(from: validChars.inverted) == nil else {
            throw PDF22PNGError.invalidArgs
        }
        
        // Check for reasonable range limits
        let components = range.components(separatedBy: CharacterSet(charactersIn: ",-"))
        for component in components {
            if let pageNum = Int(component.trimmingCharacters(in: .whitespaces)) {
                try validatePageNumber(pageNum, totalPages: totalPages)
            }
        }
    }
    
    static func validateScale(_ scale: String) throws {
        guard scale.count <= 20 else { // Reasonable limit for scale specification
            throw PDF22PNGError.invalidScale
        }
        
        // Check for basic format validity
        let validChars = CharacterSet(charactersIn: "0123456789.%xdpi")
        guard scale.rangeOfCharacter(from: validChars.inverted) == nil else {
            throw PDF22PNGError.invalidScale
        }
    }
    
    static func validateQuality(_ quality: Int) throws {
        guard quality >= 0 && quality <= 9 else {
            throw PDF22PNGError.invalidArgs
        }
    }
    
    static func validateNamingPattern(_ pattern: String) throws {
        guard pattern.count <= 200 else { // Reasonable pattern length
            throw PDF22PNGError.invalidArgs
        }
        
        // Check for potentially dangerous pattern elements
        guard !pattern.contains("../") && !pattern.contains("..\\") && !pattern.contains("\0") else {
            throw PDF22PNGError.invalidArgs
        }
    }
}
</file>

<file path="src/Utilities/ProgressReporter.swift">
import Foundation

// MARK: - Progress Reporter

class ProgressReporter {
    private let totalPages: Int
    private var startTime: Date
    private var processedPages: Int = 0
    private var successfulPages: Int = 0
    private var failedPages: Int = 0
    private var lastReportTime: Date
    private let reportInterval: TimeInterval = 1.0 // Report at most once per second
    private let verbose: Bool
    
    init(totalPages: Int, verbose: Bool = false) {
        self.totalPages = totalPages
        self.verbose = verbose
        self.startTime = Date()
        self.lastReportTime = Date()
    }
    
    func reportPageStart(pageNumber: Int) {
        if verbose {
            print("Processing page \(pageNumber)/\(totalPages)...")
        }
    }
    
    func reportPageComplete(pageNumber: Int, success: Bool, outputFile: String? = nil) {
        processedPages += 1
        if success {
            successfulPages += 1
            if let outputFile = outputFile, !verbose {
                // For non-verbose mode, show successful outputs
                print("✓ Page \(pageNumber) → \(outputFile)")
            }
        } else {
            failedPages += 1
            print("✗ Page \(pageNumber) failed")
        }
        
        // Report progress if enough time has passed or we're at a milestone
        let now = Date()
        let shouldReportTime = now.timeIntervalSince(lastReportTime) >= reportInterval
        let shouldReportMilestone = processedPages % 10 == 0 || processedPages == totalPages
        
        if shouldReportTime || shouldReportMilestone {
            reportProgress()
            lastReportTime = now
        }
    }
    
    func reportChunkStart(chunkNumber: Int, totalChunks: Int, pagesInChunk: Int) {
        if verbose {
            print("\n📦 Processing chunk \(chunkNumber)/\(totalChunks) (\(pagesInChunk) pages)")
        }
    }
    
    private func reportProgress() {
        let percentage = (processedPages * 100) / totalPages
        let elapsed = Date().timeIntervalSince(startTime)
        let pagesPerSecond = elapsed > 0 ? Double(processedPages) / elapsed : 0
        let estimatedTotal = pagesPerSecond > 0 ? Double(totalPages) / pagesPerSecond : 0
        let estimatedRemaining = max(0, estimatedTotal - elapsed)
        
        var progressBar = "["
        let barWidth = 30
        let filledWidth = (barWidth * processedPages) / totalPages
        progressBar += String(repeating: "■", count: filledWidth)
        progressBar += String(repeating: "□", count: barWidth - filledWidth)
        progressBar += "]"
        
        print("\n📊 Progress: \(progressBar) \(percentage)%")
        print("   Processed: \(processedPages)/\(totalPages) pages (✓ \(successfulPages), ✗ \(failedPages))")
        
        if pagesPerSecond > 0 {
            print("   Speed: \(String(format: "%.1f", pagesPerSecond)) pages/sec")
            print("   Time: \(formatDuration(elapsed)) elapsed, ~\(formatDuration(estimatedRemaining)) remaining")
        }
        
        // Memory status in verbose mode
        if verbose {
            let memInfo = MemoryManager.shared.getSystemMemoryInfo()
            let usedGB = Double(memInfo.used) / (1024 * 1024 * 1024)
            let availableGB = Double(memInfo.available) / (1024 * 1024 * 1024)
            print("   Memory: \(String(format: "%.1f", usedGB))GB used, \(String(format: "%.1f", availableGB))GB available")
        }
    }
    
    func reportBatchComplete() {
        let elapsed = Date().timeIntervalSince(startTime)
        let pagesPerSecond = elapsed > 0 ? Double(processedPages) / elapsed : 0
        
        print("\n✅ Batch processing complete!")
        print("   Total: \(processedPages) pages processed in \(formatDuration(elapsed))")
        print("   Results: ✓ \(successfulPages) successful, ✗ \(failedPages) failed")
        if pagesPerSecond > 0 {
            print("   Average speed: \(String(format: "%.1f", pagesPerSecond)) pages/sec")
        }
    }
    
    func reportInterrupted() {
        print("\n⚠️  Processing interrupted!")
        print("   Completed: \(processedPages)/\(totalPages) pages")
        print("   Results: ✓ \(successfulPages) successful, ✗ \(failedPages) failed")
    }
    
    private func formatDuration(_ seconds: TimeInterval) -> String {
        let minutes = Int(seconds) / 60
        let secs = Int(seconds) % 60
        if minutes > 0 {
            return "\(minutes)m \(secs)s"
        } else {
            return "\(secs)s"
        }
    }
    
    // Progress info for external consumption
    func getCurrentProgress() -> ProgressInfo {
        let elapsed = Date().timeIntervalSince(startTime)
        let pagesPerSecond = elapsed > 0 ? Double(processedPages) / elapsed : 0
        let estimatedTotal = pagesPerSecond > 0 ? Double(totalPages) / pagesPerSecond : 0
        let estimatedRemaining = max(0, estimatedTotal - elapsed)
        
        return ProgressInfo(
            completed: processedPages,
            total: totalPages,
            speed: pagesPerSecond > 0 ? pagesPerSecond : nil,
            estimatedTimeRemaining: estimatedRemaining > 0 ? estimatedRemaining : nil,
            currentOperation: nil
        )
    }
}
</file>

<file path="Tests/CLITests/ArgumentParserTests.swift">
import Foundation
import XCTest
@testable import pdf22png

/// Unit tests for ArgumentParser module
final class ArgumentParserTests: XCTestCase {
    
    // MARK: - Basic Argument Parsing Tests
    
    func testParseBasicArguments() {
        // Test parsing of basic arguments
        // This would simulate CommandLine.arguments
        XCTAssertTrue(true, "Placeholder test - needs argument simulation")
    }
    
    func testParseHelpFlag() {
        // Test that help flag is correctly parsed
        XCTAssertTrue(true, "Placeholder test - needs argument simulation")
    }
    
    func testParseVersionFlag() {
        // Test that version flag is correctly parsed
        XCTAssertTrue(true, "Placeholder test - needs argument simulation")
    }
    
    func testParsePageArgument() {
        // Test parsing of page argument
        XCTAssertTrue(true, "Placeholder test - needs argument simulation")
    }
    
    func testParseAllPagesFlag() {
        // Test parsing of all pages flag
        XCTAssertTrue(true, "Placeholder test - needs argument simulation")
    }
    
    func testParseScaleArgument() {
        // Test parsing of scale argument
        XCTAssertTrue(true, "Placeholder test - needs argument simulation")
    }
    
    func testParseQualityArgument() {
        // Test parsing of quality argument
        XCTAssertTrue(true, "Placeholder test - needs argument simulation")
    }
    
    // MARK: - Validation Tests
    
    func testValidateValidArguments() {
        // Test validation of valid argument combinations
        let options = ProcessingOptions()
        
        do {
            try ArgumentParser.validateArguments(options)
            XCTFail("Should throw error for empty options")
        } catch {
            XCTAssertTrue(error is PDF22PNGError, "Should throw PDF22PNGError")
        }
    }
    
    func testValidateInvalidArguments() {
        // Test validation of invalid argument combinations
        var options = ProcessingOptions()
        options.quality = 15 // Invalid quality value
        
        do {
            try ArgumentParser.validateArguments(options)
            XCTFail("Should throw error for invalid quality")
        } catch {
            XCTAssertTrue(error is PDF22PNGError, "Should throw PDF22PNGError")
        }
    }
    
    // MARK: - Error Handling Tests
    
    func testHandleUnknownArgument() {
        // Test handling of unknown arguments
        XCTAssertTrue(true, "Placeholder test - needs argument simulation")
    }
    
    func testHandleMissingRequiredArgument() {
        // Test handling when required arguments are missing
        XCTAssertTrue(true, "Placeholder test - needs argument simulation")
    }
}

// MARK: - Test Extensions

extension ArgumentParserTests {
    
    /// Helper method to simulate command line arguments
    private func simulateArguments(_ args: [String]) {
        // This would temporarily override CommandLine.arguments for testing
        // Implementation would depend on testing framework capabilities
    }
    
    /// Helper method to create test options
    private func createTestOptions() -> ProcessingOptions {
        var options = ProcessingOptions()
        options.inputFile = "test.pdf"
        options.outputFile = "test.png"
        return options
    }
}
</file>

<file path="Tests/CoreTests/ImageRendererTests.swift">
import Foundation
import XCTest
import CoreGraphics
import PDFKit
@testable import pdf22png

/// Unit tests for ImageRenderer module
final class ImageRendererTests: XCTestCase {
    
    var renderer: ImageRenderer!
    
    override func setUp() {
        super.setUp()
        renderer = ImageRenderer.shared
    }
    
    override func tearDown() {
        renderer = nil
        super.tearDown()
    }
    
    // MARK: - Rendering Options Tests
    
    func testRenderOptionsInitialization() {
        let options = ImageRenderer.RenderOptions(
            scaleFactor: 2.0,
            transparentBackground: true,
            quality: 6,
            verbose: false,
            dryRun: false,
            forceOverwrite: false
        )
        
        XCTAssertEqual(options.scaleFactor, 2.0)
        XCTAssertTrue(options.transparentBackground)
        XCTAssertEqual(options.quality, 6)
        XCTAssertFalse(options.verbose)
        XCTAssertFalse(options.dryRun)
        XCTAssertFalse(options.forceOverwrite)
    }
    
    // MARK: - Scale Factor Calculation Tests
    
    func testCalculateScaleFactorPercentage() {
        let spec = ScaleSpecification.percentage(150.0)
        let pageRect = CGRect(x: 0, y: 0, width: 100, height: 100)
        
        let scaleFactor = renderer.calculateScaleFactor(spec: spec, pageRect: pageRect)
        XCTAssertEqual(scaleFactor, 1.5, accuracy: 0.001)
    }
    
    func testCalculateScaleFactorFactor() {
        let spec = ScaleSpecification.factor(2.5)
        let pageRect = CGRect(x: 0, y: 0, width: 100, height: 100)
        
        let scaleFactor = renderer.calculateScaleFactor(spec: spec, pageRect: pageRect)
        XCTAssertEqual(scaleFactor, 2.5, accuracy: 0.001)
    }
    
    func testCalculateScaleFactorResolution() {
        let spec = ScaleSpecification.resolution(144.0)
        let pageRect = CGRect(x: 0, y: 0, width: 100, height: 100)
        
        let scaleFactor = renderer.calculateScaleFactor(spec: spec, pageRect: pageRect)
        XCTAssertEqual(scaleFactor, 2.0, accuracy: 0.001) // 144/72 = 2.0
    }
    
    func testCalculateScaleFactorWidth() {
        let spec = ScaleSpecification.width(200.0)
        let pageRect = CGRect(x: 0, y: 0, width: 100, height: 150)
        
        let scaleFactor = renderer.calculateScaleFactor(spec: spec, pageRect: pageRect)
        XCTAssertEqual(scaleFactor, 2.0, accuracy: 0.001) // 200/100 = 2.0
    }
    
    func testCalculateScaleFactorHeight() {
        let spec = ScaleSpecification.height(300.0)
        let pageRect = CGRect(x: 0, y: 0, width: 100, height: 150)
        
        let scaleFactor = renderer.calculateScaleFactor(spec: spec, pageRect: pageRect)
        XCTAssertEqual(scaleFactor, 2.0, accuracy: 0.001) // 300/150 = 2.0
    }
    
    func testCalculateScaleFactorFit() {
        let spec = ScaleSpecification.fit(width: 200.0, height: 200.0)
        let pageRect = CGRect(x: 0, y: 0, width: 100, height: 150)
        
        let scaleFactor = renderer.calculateScaleFactor(spec: spec, pageRect: pageRect)
        // Should use the smaller scale factor (min of 200/100=2.0 and 200/150=1.33)
        XCTAssertEqual(scaleFactor, 200.0/150.0, accuracy: 0.001)
    }
    
    // MARK: - Image Rendering Tests
    
    func testRenderPageToImageWithValidPage() {
        // This test would require a valid PDFPage
        // For now, we test that the method exists and handles nil gracefully
        XCTAssertTrue(true, "Placeholder test - needs valid PDFPage")
    }
    
    func testRenderPageToImageWithTransparency() {
        // Test rendering with transparent background
        XCTAssertTrue(true, "Placeholder test - needs valid PDFPage")
    }
    
    func testRenderPageToImageWithOpaqueBackground() {
        // Test rendering with opaque background
        XCTAssertTrue(true, "Placeholder test - needs valid PDFPage")
    }
    
    // MARK: - File Writing Tests
    
    func testWriteImageToFileValidPath() {
        // Test writing image to a valid file path
        // This would require a valid CGImage
        XCTAssertTrue(true, "Placeholder test - needs valid CGImage and temporary file")
    }
    
    func testWriteImageToFileInvalidPath() {
        // Test writing image to an invalid file path
        XCTAssertTrue(true, "Placeholder test - needs valid CGImage")
    }
    
    func testWriteImageToFileDryRun() {
        // Test dry run mode - should not actually write file
        XCTAssertTrue(true, "Placeholder test - needs valid CGImage")
    }
    
    func testWriteImageToFileForceOverwrite() {
        // Test force overwrite functionality
        XCTAssertTrue(true, "Placeholder test - needs valid CGImage and existing file")
    }
    
    // MARK: - Stdout Writing Tests
    
    func testWriteImageToStdout() {
        // Test writing image to stdout
        XCTAssertTrue(true, "Placeholder test - needs valid CGImage")
    }
}

// MARK: - Test Extensions

extension ImageRendererTests {
    
    /// Helper method to create a test CGImage
    private func createTestImage() -> CGImage? {
        let width = 100
        let height = 100
        let colorSpace = CGColorSpaceCreateDeviceRGB()
        let context = CGContext(
            data: nil,
            width: width,
            height: height,
            bitsPerComponent: 8,
            bytesPerRow: 0,
            space: colorSpace,
            bitmapInfo: CGImageAlphaInfo.premultipliedLast.rawValue
        )
        
        context?.setFillColor(CGColor(red: 1, green: 0, blue: 0, alpha: 1))
        context?.fill(CGRect(x: 0, y: 0, width: width, height: height))
        
        return context?.makeImage()
    }
    
    /// Helper method to create test render options
    private func createTestRenderOptions() -> ImageRenderer.RenderOptions {
        return ImageRenderer.RenderOptions(
            scaleFactor: 1.0,
            transparentBackground: false,
            quality: 6,
            verbose: false,
            dryRun: true,
            forceOverwrite: false
        )
    }
}
</file>

<file path="Tests/CoreTests/MemoryManagerTests.swift">
import Foundation
import XCTest
import CoreGraphics
@testable import pdf22png

/// Unit tests for MemoryManager module
final class MemoryManagerTests: XCTestCase {
    
    var memoryManager: MemoryManager!
    
    override func setUp() {
        super.setUp()
        memoryManager = MemoryManager.shared
    }
    
    override func tearDown() {
        memoryManager = nil
        super.tearDown()
    }
    
    // MARK: - System Memory Information Tests
    
    func testGetSystemMemoryInfo() {
        let memInfo = memoryManager.getSystemMemoryInfo()
        
        XCTAssertGreaterThan(memInfo.total, 0, "Total memory should be greater than 0")
        XCTAssertGreaterThanOrEqual(memInfo.total, memInfo.used, "Total memory should be >= used memory")
        XCTAssertEqual(memInfo.total, memInfo.used + memInfo.available, "Total should equal used + available")
    }
    
    // MARK: - Memory Pressure Detection Tests
    
    func testMemoryPressureDetection() {
        // Test memory pressure detection methods exist and return valid results
        let isHighPressure = memoryManager.isMemoryPressureHigh()
        let isCriticalPressure = memoryManager.isMemoryPressureCritical()
        
        // If critical pressure is true, high pressure should also be true
        if isCriticalPressure {
            XCTAssertTrue(isHighPressure, "Critical pressure implies high pressure")
        }
        
        // Both should be boolean values (this test always passes but ensures methods work)
        XCTAssertTrue(isHighPressure == true || isHighPressure == false)
        XCTAssertTrue(isCriticalPressure == true || isCriticalPressure == false)
    }
    
    // MARK: - Memory Requirement Estimation Tests
    
    func testEstimateMemoryRequirementBasic() {
        let pageRect = CGRect(x: 0, y: 0, width: 100, height: 100)
        let scaleFactor: CGFloat = 1.0
        let transparentBackground = false
        
        let requirement = memoryManager.estimateMemoryRequirement(
            pageRect: pageRect,
            scaleFactor: scaleFactor,
            transparentBackground: transparentBackground
        )
        
        XCTAssertGreaterThan(requirement, 0, "Memory requirement should be positive")
        
        // Basic calculation: 100x100 pixels * 4 bytes = 40,000 bytes + overhead
        XCTAssertGreaterThanOrEqual(requirement, 40000, "Should be at least base pixel memory")
    }
    
    func testEstimateMemoryRequirementWithScaling() {
        let pageRect = CGRect(x: 0, y: 0, width: 100, height: 100)
        let scaleFactor: CGFloat = 2.0
        let transparentBackground = false
        
        let requirement = memoryManager.estimateMemoryRequirement(
            pageRect: pageRect,
            scaleFactor: scaleFactor,
            transparentBackground: transparentBackground
        )
        
        // Should be roughly 4x the memory for 2x scale factor (2x width * 2x height)
        XCTAssertGreaterThan(requirement, 160000, "Scaled requirement should be much larger")
    }
    
    func testEstimateMemoryRequirementWithTransparency() {
        let pageRect = CGRect(x: 0, y: 0, width: 100, height: 100)
        let scaleFactor: CGFloat = 1.0
        
        let opaqueRequirement = memoryManager.estimateMemoryRequirement(
            pageRect: pageRect,
            scaleFactor: scaleFactor,
            transparentBackground: false
        )
        
        let transparentRequirement = memoryManager.estimateMemoryRequirement(
            pageRect: pageRect,
            scaleFactor: scaleFactor,
            transparentBackground: true
        )
        
        XCTAssertGreaterThan(transparentRequirement, opaqueRequirement,
                           "Transparent background should require more memory")
    }
    
    // MARK: - Memory Allocation Tests
    
    func testCanAllocateMemorySmallAmount() {
        let smallAmount: UInt64 = 1024 * 1024 // 1MB
        let canAllocate = memoryManager.canAllocateMemory(smallAmount, verbose: false)
        
        // On most systems, 1MB should be allocatable
        XCTAssertTrue(canAllocate, "Should be able to allocate 1MB")
    }
    
    func testCanAllocateMemoryLargeAmount() {
        let largeAmount: UInt64 = 100 * 1024 * 1024 * 1024 // 100GB
        let canAllocate = memoryManager.canAllocateMemory(largeAmount, verbose: false)
        
        // 100GB should not be allocatable on most systems
        XCTAssertFalse(canAllocate, "Should not be able to allocate 100GB")
    }
    
    // MARK: - Batch Size Calculation Tests
    
    func testCalculateOptimalBatchSizeSmallPages() {
        let totalPages = 10
        let pageRect = CGRect(x: 0, y: 0, width: 100, height: 100)
        let scaleFactor: CGFloat = 1.0
        
        let batchSize = memoryManager.calculateOptimalBatchSize(
            totalPages: totalPages,
            pageRect: pageRect,
            scaleFactor: scaleFactor,
            verbose: false
        )
        
        XCTAssertGreaterThan(batchSize, 0, "Batch size should be positive")
        XCTAssertLessThanOrEqual(batchSize, totalPages, "Batch size should not exceed total pages")
    }
    
    func testCalculateOptimalBatchSizeLargePages() {
        let totalPages = 1000
        let pageRect = CGRect(x: 0, y: 0, width: 2000, height: 2000)
        let scaleFactor: CGFloat = 2.0
        
        let batchSize = memoryManager.calculateOptimalBatchSize(
            totalPages: totalPages,
            pageRect: pageRect,
            scaleFactor: scaleFactor,
            verbose: false
        )
        
        XCTAssertGreaterThan(batchSize, 0, "Batch size should be positive")
        XCTAssertLessThan(batchSize, totalPages, "Batch size should be smaller for large pages")
    }
    
    // MARK: - Memory Status Logging Tests
    
    func testLogMemoryStatusVerbose() {
        // Test that verbose logging doesn't crash
        memoryManager.logMemoryStatus(verbose: true)
        XCTAssertTrue(true, "Verbose logging should complete without crashing")
    }
    
    func testLogMemoryStatusNonVerbose() {
        // Test that non-verbose mode doesn't log
        memoryManager.logMemoryStatus(verbose: false)
        XCTAssertTrue(true, "Non-verbose logging should complete without output")
    }
    
    // MARK: - Memory Pressure Handling Tests
    
    func testCheckMemoryPressureDuringBatch() {
        // Test memory pressure checking during batch processing
        do {
            try memoryManager.checkMemoryPressureDuringBatch(verbose: false)
            XCTAssertTrue(true, "Memory pressure check should complete normally")
        } catch {
            // If memory pressure is critical, an error should be thrown
            XCTAssertTrue(error is PDF22PNGError, "Should throw PDF22PNGError for memory pressure")
        }
    }
}

// MARK: - Test Extensions

extension MemoryManagerTests {
    
    /// Helper method to create test page rect
    private func createTestPageRect(width: CGFloat, height: CGFloat) -> CGRect {
        return CGRect(x: 0, y: 0, width: width, height: height)
    }
    
    /// Helper method to get current memory usage percentage
    private func getCurrentMemoryUsage() -> Double {
        let memInfo = memoryManager.getSystemMemoryInfo()
        return Double(memInfo.used) / Double(memInfo.total)
    }
}
</file>

<file path="Tests/CoreTests/PDFProcessorTests.swift">
import Foundation
import XCTest
@testable import pdf22png

/// Unit tests for PDFProcessor module
final class PDFProcessorTests: XCTestCase {
    
    var processor: PDFProcessor!
    
    override func setUp() {
        super.setUp()
        processor = PDFProcessor.shared
    }
    
    override func tearDown() {
        processor = nil
        super.tearDown()
    }
    
    // MARK: - PDF Loading Tests
    
    func testPDFLoadingFromValidFile() {
        // Test PDF loading from a valid file
        // This would require a test PDF file
        let testPath = "test.pdf"
        
        // For now, test that the method exists and handles nil gracefully
        let result = processor.readPDFData(nil, verbose: false)
        XCTAssertNotNil(result, "Should handle stdin input")
    }
    
    func testPDFLoadingFromInvalidFile() {
        // Test PDF loading from non-existent file
        let invalidPath = "/non/existent/path.pdf"
        let result = processor.readPDFData(invalidPath, verbose: false)
        XCTAssertNil(result, "Should return nil for non-existent file")
    }
    
    func testCreatePDFDocumentFromValidData() {
        // Test PDF document creation from valid data
        // This would require valid PDF data
        let emptyData = Data()
        let result = processor.createPDFDocument(from: emptyData)
        XCTAssertNil(result, "Should return nil for empty data")
    }
    
    // MARK: - Page Extraction Tests
    
    func testPageExtractionValidPage() {
        // Create a mock PDF document for testing
        // This test would be fully implemented with a real test PDF
        XCTAssertTrue(true, "Placeholder test - needs test PDF file")
    }
    
    func testPageExtractionInvalidPage() {
        // Test extracting page numbers that don't exist
        XCTAssertTrue(true, "Placeholder test - needs test PDF file")
    }
    
    // MARK: - Validation Tests
    
    func testValidatePDFWithValidDocument() {
        // Test PDF validation with a valid document
        XCTAssertTrue(true, "Placeholder test - needs test PDF file")
    }
    
    func testGetPageCountWithValidDocument() {
        // Test getting page count from a valid document
        XCTAssertTrue(true, "Placeholder test - needs test PDF file")
    }
}

// MARK: - Test Extensions

extension PDFProcessorTests {
    
    /// Helper method to create test PDF data
    private func createTestPDFData() -> Data? {
        // This would create minimal PDF data for testing
        // For now, return nil to avoid test failures
        return nil
    }
    
    /// Helper method to create test PDF file
    private func createTestPDFFile(at path: String) -> Bool {
        // This would create a test PDF file
        // For now, return false to avoid test failures
        return false
    }
}
</file>

<file path="Tests/UtilitiesTests/InputValidatorTests.swift">
import Foundation
import XCTest
@testable import pdf22png

/// Unit tests for InputValidator module
final class InputValidatorTests: XCTestCase {
    
    // MARK: - File Path Validation Tests
    
    func testValidateFilePathValid() {
        let validPath = "/tmp/test.pdf"
        
        do {
            let result = try InputValidator.validateFilePath(validPath, allowCreate: true)
            XCTAssertEqual(result, validPath, "Should return normalized path")
        } catch {
            XCTFail("Should not throw error for valid path: \(error)")
        }
    }
    
    func testValidateFilePathTooLong() {
        let longPath = String(repeating: "a", count: InputValidator.maxPathLength + 1)
        
        do {
            _ = try InputValidator.validateFilePath(longPath, allowCreate: true)
            XCTFail("Should throw error for path too long")
        } catch {
            XCTAssertTrue(error is PDF22PNGError, "Should throw PDF22PNGError")
        }
    }
    
    func testValidateFilePathWithPathTraversal() {
        let maliciousPath = "../../../etc/passwd"
        
        do {
            _ = try InputValidator.validateFilePath(maliciousPath, allowCreate: true)
            XCTFail("Should throw error for path traversal attempt")
        } catch {
            XCTAssertTrue(error is PDF22PNGError, "Should throw PDF22PNGError")
        }
    }
    
    func testValidateFilePathWithNullByte() {
        let maliciousPath = "/tmp/test\0.pdf"
        
        do {
            _ = try InputValidator.validateFilePath(maliciousPath, allowCreate: true)
            XCTFail("Should throw error for null byte in path")
        } catch {
            XCTAssertTrue(error is PDF22PNGError, "Should throw PDF22PNGError")
        }
    }
    
    func testValidateFilePathWithNewline() {
        let maliciousPath = "/tmp/test\n.pdf"
        
        do {
            _ = try InputValidator.validateFilePath(maliciousPath, allowCreate: true)
            XCTFail("Should throw error for newline in path")
        } catch {
            XCTAssertTrue(error is PDF22PNGError, "Should throw PDF22PNGError")
        }
    }
    
    // MARK: - Output Directory Validation Tests
    
    func testValidateOutputDirectoryValid() {
        let validDir = "/tmp"
        
        do {
            let result = try InputValidator.validateOutputDirectory(validDir)
            XCTAssertEqual(result, validDir, "Should return normalized directory path")
        } catch {
            XCTFail("Should not throw error for valid directory: \(error)")
        }
    }
    
    func testValidateOutputDirectoryNonExistent() {
        let nonExistentDir = "/non/existent/directory"
        
        do {
            _ = try InputValidator.validateOutputDirectory(nonExistentDir)
            XCTFail("Should throw error for non-existent directory")
        } catch {
            XCTAssertTrue(error is PDF22PNGError, "Should throw PDF22PNGError")
        }
    }
    
    // MARK: - Page Number Validation Tests
    
    func testValidatePageNumberValid() {
        let validPage = 5
        let totalPages = 10
        
        do {
            try InputValidator.validatePageNumber(validPage, totalPages: totalPages)
            XCTAssertTrue(true, "Should not throw error for valid page number")
        } catch {
            XCTFail("Should not throw error for valid page number: \(error)")
        }
    }
    
    func testValidatePageNumberTooLow() {
        let invalidPage = 0
        let totalPages = 10
        
        do {
            try InputValidator.validatePageNumber(invalidPage, totalPages: totalPages)
            XCTFail("Should throw error for page number too low")
        } catch {
            XCTAssertTrue(error is PDF22PNGError, "Should throw PDF22PNGError")
        }
    }
    
    func testValidatePageNumberTooHigh() {
        let invalidPage = 15
        let totalPages = 10
        
        do {
            try InputValidator.validatePageNumber(invalidPage, totalPages: totalPages)
            XCTFail("Should throw error for page number too high")
        } catch {
            XCTAssertTrue(error is PDF22PNGError, "Should throw PDF22PNGError")
        }
    }
    
    func testValidatePageNumberExceedsMaximum() {
        let invalidPage = InputValidator.maxPageNumber + 1
        let totalPages = InputValidator.maxPageNumber + 10
        
        do {
            try InputValidator.validatePageNumber(invalidPage, totalPages: totalPages)
            XCTFail("Should throw error for page number exceeding maximum")
        } catch {
            XCTAssertTrue(error is PDF22PNGError, "Should throw PDF22PNGError")
        }
    }
    
    // MARK: - Page Range Validation Tests
    
    func testValidatePageRangeValid() {
        let validRange = "1,3,5-10"
        let totalPages = 15
        
        do {
            try InputValidator.validatePageRange(validRange, totalPages: totalPages)
            XCTAssertTrue(true, "Should not throw error for valid page range")
        } catch {
            XCTFail("Should not throw error for valid page range: \(error)")
        }
    }
    
    func testValidatePageRangeInvalidCharacters() {
        let invalidRange = "1,3,5-10a"
        let totalPages = 15
        
        do {
            try InputValidator.validatePageRange(invalidRange, totalPages: totalPages)
            XCTFail("Should throw error for invalid characters in range")
        } catch {
            XCTAssertTrue(error is PDF22PNGError, "Should throw PDF22PNGError")
        }
    }
    
    func testValidatePageRangePageOutOfBounds() {
        let invalidRange = "1,3,20"
        let totalPages = 15
        
        do {
            try InputValidator.validatePageRange(invalidRange, totalPages: totalPages)
            XCTFail("Should throw error for page out of bounds")
        } catch {
            XCTAssertTrue(error is PDF22PNGError, "Should throw PDF22PNGError")
        }
    }
    
    // MARK: - Scale Validation Tests
    
    func testValidateScaleValid() {
        let validScales = ["100%", "1.5", "800x600", "300dpi"]
        
        for scale in validScales {
            do {
                try InputValidator.validateScale(scale)
                XCTAssertTrue(true, "Should not throw error for valid scale: \(scale)")
            } catch {
                XCTFail("Should not throw error for valid scale \(scale): \(error)")
            }
        }
    }
    
    func testValidateScaleTooLong() {
        let longScale = String(repeating: "1", count: 25)
        
        do {
            try InputValidator.validateScale(longScale)
            XCTFail("Should throw error for scale too long")
        } catch {
            XCTAssertTrue(error is PDF22PNGError, "Should throw PDF22PNGError")
        }
    }
    
    func testValidateScaleInvalidCharacters() {
        let invalidScale = "100%$"
        
        do {
            try InputValidator.validateScale(invalidScale)
            XCTFail("Should throw error for invalid characters in scale")
        } catch {
            XCTAssertTrue(error is PDF22PNGError, "Should throw PDF22PNGError")
        }
    }
    
    // MARK: - Quality Validation Tests
    
    func testValidateQualityValid() {
        for quality in 0...9 {
            do {
                try InputValidator.validateQuality(quality)
                XCTAssertTrue(true, "Should not throw error for valid quality: \(quality)")
            } catch {
                XCTFail("Should not throw error for valid quality \(quality): \(error)")
            }
        }
    }
    
    func testValidateQualityTooLow() {
        let invalidQuality = -1
        
        do {
            try InputValidator.validateQuality(invalidQuality)
            XCTFail("Should throw error for quality too low")
        } catch {
            XCTAssertTrue(error is PDF22PNGError, "Should throw PDF22PNGError")
        }
    }
    
    func testValidateQualityTooHigh() {
        let invalidQuality = 10
        
        do {
            try InputValidator.validateQuality(invalidQuality)
            XCTFail("Should throw error for quality too high")
        } catch {
            XCTAssertTrue(error is PDF22PNGError, "Should throw PDF22PNGError")
        }
    }
    
    // MARK: - Naming Pattern Validation Tests
    
    func testValidateNamingPatternValid() {
        let validPattern = "{basename}_p{page:04d}_of_{total}"
        
        do {
            try InputValidator.validateNamingPattern(validPattern)
            XCTAssertTrue(true, "Should not throw error for valid naming pattern")
        } catch {
            XCTFail("Should not throw error for valid naming pattern: \(error)")
        }
    }
    
    func testValidateNamingPatternTooLong() {
        let longPattern = String(repeating: "a", count: 250)
        
        do {
            try InputValidator.validateNamingPattern(longPattern)
            XCTFail("Should throw error for pattern too long")
        } catch {
            XCTAssertTrue(error is PDF22PNGError, "Should throw PDF22PNGError")
        }
    }
    
    func testValidateNamingPatternWithPathTraversal() {
        let maliciousPattern = "../{basename}"
        
        do {
            try InputValidator.validateNamingPattern(maliciousPattern)
            XCTFail("Should throw error for path traversal in pattern")
        } catch {
            XCTAssertTrue(error is PDF22PNGError, "Should throw PDF22PNGError")
        }
    }
}

// MARK: - Test Extensions

extension InputValidatorTests {
    
    /// Helper method to create temporary file for testing
    private func createTemporaryFile() -> String? {
        let tempDir = NSTemporaryDirectory()
        let tempFile = "\(tempDir)/test_\(UUID().uuidString).pdf"
        
        if FileManager.default.createFile(atPath: tempFile, contents: Data(), attributes: nil) {
            return tempFile
        }
        return nil
    }
    
    /// Helper method to clean up temporary file
    private func cleanupTemporaryFile(_ path: String) {
        try? FileManager.default.removeItem(atPath: path)
    }
}
</file>

<file path="Tests/test-framework.swift">
#!/usr/bin/env swift

import Foundation

// MARK: - Test Framework

struct TestResult {
    let testName: String
    let passed: Bool
    let message: String
    let duration: TimeInterval
}

class TestFramework {
    private var results: [TestResult] = []
    private let executable: String
    
    init(executable: String) {
        self.executable = executable
    }
    
    func runTest(name: String, test: () throws -> (Bool, String)) {
        print("Running test: \(name)")
        let startTime = Date()
        
        do {
            let (passed, message) = try test()
            let duration = Date().timeIntervalSince(startTime)
            let result = TestResult(testName: name, passed: passed, message: message, duration: duration)
            results.append(result)
            
            let status = passed ? "✅ PASS" : "❌ FAIL"
            print("  \(status): \(message) (\(String(format: "%.3f", duration))s)")
        } catch {
            let duration = Date().timeIntervalSince(startTime)
            let result = TestResult(testName: name, passed: false, message: "Exception: \(error)", duration: duration)
            results.append(result)
            print("  ❌ FAIL: Exception - \(error) (\(String(format: "%.3f", duration))s)")
        }
    }
    
    func runCommand(_ args: [String]) -> (exitCode: Int32, stdout: String, stderr: String) {
        let process = Process()
        process.executableURL = URL(fileURLWithPath: executable)
        process.arguments = args
        
        let stdoutPipe = Pipe()
        let stderrPipe = Pipe()
        process.standardOutput = stdoutPipe
        process.standardError = stderrPipe
        
        do {
            try process.run()
            process.waitUntilExit()
        } catch {
            return (1, "", "Failed to execute: \(error)")
        }
        
        let stdout = String(data: stdoutPipe.fileHandleForReading.readDataToEndOfFile(), encoding: .utf8) ?? ""
        let stderr = String(data: stderrPipe.fileHandleForReading.readDataToEndOfFile(), encoding: .utf8) ?? ""
        
        return (process.terminationStatus, stdout, stderr)
    }
    
    func createTestPDF(path: String, pageCount: Int = 1) -> Bool {
        // Create a minimal PDF for testing
        let pdfContent = """
%PDF-1.4
1 0 obj
<< /Type /Catalog /Pages 2 0 R >>
endobj
2 0 obj
<< /Type /Pages /Count \(pageCount) /Kids [\(pageCount == 1 ? "3 0 R" : (1...pageCount).map { "\($0 + 2) 0 R" }.joined(separator: " "))] >>
endobj
3 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 4 0 R >>
endobj
4 0 obj
<< /Length 44 >>
stream
BT
/F1 12 Tf
100 700 Td
(Test Page) Tj
ET
endstream
endobj
xref
0 5
0000000000 65535 f
0000000009 00000 n
0000000058 00000 n
0000000115 00000 n
0000000207 00000 n
trailer
<< /Size 5 /Root 1 0 R >>
startxref
301
%%EOF
"""
        
        do {
            try pdfContent.write(toFile: path, atomically: true, encoding: .utf8)
            return true
        } catch {
            return false
        }
    }
    
    func printSummary() {
        let totalTests = results.count
        let passedTests = results.filter { $0.passed }.count
        let failedTests = totalTests - passedTests
        let totalDuration = results.reduce(0) { $0 + $1.duration }
        
        print("\n" + String(repeating: "=", count: 60))
        print("TEST SUMMARY")
        print(String(repeating: "=", count: 60))
        print("Total tests: \(totalTests)")
        print("Passed: \(passedTests)")
        print("Failed: \(failedTests)")
        print("Total duration: \(String(format: "%.3f", totalDuration))s")
        print("Success rate: \(String(format: "%.1f", Double(passedTests) / Double(totalTests) * 100))%")
        
        if failedTests > 0 {
            print("\nFAILED TESTS:")
            for result in results where !result.passed {
                print("  • \(result.testName): \(result.message)")
            }
        }
        
        print(String(repeating: "=", count: 60))
    }
}

// MARK: - Test Suite

func runTestSuite() {
    let framework = TestFramework(executable: "./build/pdf22png")
    
    // Test 1: Help output
    framework.runTest(name: "Help Output") {
        let result = framework.runCommand(["--help"])
        let success = result.exitCode == 0 && result.stdout.contains("Usage:")
        return (success, success ? "Help displayed correctly" : "Help command failed")
    }
    
    // Test 2: Version output
    framework.runTest(name: "Version Output") {
        let result = framework.runCommand(["--version"])
        let success = result.exitCode == 0 && result.stdout.contains("pdf22png")
        return (success, success ? "Version displayed correctly" : "Version command failed")
    }
    
    // Test 3: Invalid arguments
    framework.runTest(name: "Invalid Arguments") {
        let result = framework.runCommand(["--invalid-option"])
        let success = result.exitCode != 0
        return (success, success ? "Invalid arguments rejected" : "Should reject invalid arguments")
    }
    
    // Test 4: Missing input file
    framework.runTest(name: "Missing Input File") {
        let result = framework.runCommand([])
        let success = result.exitCode != 0
        return (success, success ? "Missing input file detected" : "Should require input file")
    }
    
    // Test 5: Nonexistent input file
    framework.runTest(name: "Nonexistent Input File") {
        let result = framework.runCommand(["nonexistent.pdf", "output.png"])
        let output = result.stdout + result.stderr
        let success = result.exitCode != 0 && (output.contains("not found") || output.contains("Input file not found"))
        return (success, success ? "Nonexistent file error handled" : "Exit: \(result.exitCode), output: '\(output.prefix(100))'")
    }
    
    // Test 6: Invalid quality parameter
    framework.runTest(name: "Invalid Quality Parameter") {
        let result = framework.runCommand(["--quality", "15", "test.pdf", "output.png"])
        let success = result.exitCode != 0
        return (success, success ? "Invalid quality rejected" : "Should reject invalid quality")
    }
    
    // Test 7: Invalid scale parameter
    framework.runTest(name: "Invalid Scale Parameter") {
        let result = framework.runCommand(["--scale", "invalid", "test.pdf", "output.png"])
        let success = result.exitCode != 0
        return (success, success ? "Invalid scale rejected" : "Should reject invalid scale")
    }
    
    // Test 8: Dry run mode
    framework.runTest(name: "Dry Run Mode") {
        guard framework.createTestPDF(path: "test.pdf") else {
            return (false, "Failed to create test PDF")
        }
        
        defer { try? FileManager.default.removeItem(atPath: "test.pdf") }
        
        let result = framework.runCommand(["--dry-run", "test.pdf", "output.png"])
        let success = result.exitCode == 0 && result.stdout.contains("DRY-RUN")
        
        // Verify no output file was created
        let noOutputFile = !FileManager.default.fileExists(atPath: "output.png")
        
        return (success && noOutputFile, success && noOutputFile ? "Dry run mode works correctly" : "Dry run should not create files")
    }
    
    // Test 9: Single page conversion (if test PDF available)
    framework.runTest(name: "Single Page Conversion") {
        guard framework.createTestPDF(path: "test.pdf") else {
            return (false, "Failed to create test PDF")
        }
        
        defer { 
            try? FileManager.default.removeItem(atPath: "test.pdf")
            try? FileManager.default.removeItem(atPath: "output.png")
        }
        
        let result = framework.runCommand(["test.pdf", "output.png"])
        let success = result.exitCode == 0
        let outputExists = FileManager.default.fileExists(atPath: "output.png")
        
        return (success && outputExists, success && outputExists ? "Single page conversion successful" : "Failed to convert single page")
    }
    
    // Test 10: Batch mode with dry run
    framework.runTest(name: "Batch Mode Dry Run") {
        guard framework.createTestPDF(path: "test.pdf", pageCount: 3) else {
            return (false, "Failed to create test PDF")
        }
        
        defer { try? FileManager.default.removeItem(atPath: "test.pdf") }
        
        let result = framework.runCommand(["--all", "--dry-run", "test.pdf"])
        let success = result.exitCode == 0 && result.stdout.contains("DRY-RUN")
        
        return (success, success ? "Batch dry run mode works" : "Batch dry run failed")
    }
    
    // Test 11: Memory pressure simulation (verbose mode)
    framework.runTest(name: "Memory Monitoring Verbose") {
        guard framework.createTestPDF(path: "test.pdf") else {
            return (false, "Failed to create test PDF")
        }
        
        defer { 
            try? FileManager.default.removeItem(atPath: "test.pdf")
            try? FileManager.default.removeItem(atPath: "output.png")
        }
        
        let result = framework.runCommand(["--verbose", "--dry-run", "test.pdf", "output.png"])
        let success = result.exitCode == 0 && result.stdout.contains("Memory")
        
        return (success, success ? "Memory monitoring active in verbose mode" : "Memory monitoring not working")
    }
    
    // Test 12: Signal handling (timeout test)
    framework.runTest(name: "Signal Handling Ready") {
        // This test just verifies the signal handling code is in place
        // We can't easily test actual signal handling in a unit test
        let result = framework.runCommand(["--help"])
        let success = result.exitCode == 0
        return (success, success ? "Signal handling infrastructure in place" : "Basic functionality required for signal handling")
    }
    
    framework.printSummary()
}

// MARK: - Main Execution

print("PDF22PNG Standalone Swift Implementation Test Suite")
print("Running comprehensive integration tests...")
print("")

runTestSuite()
</file>

<file path=".cursorrules">
# pdf22png

A high-performance command-line tool for converting PDF documents to PNG images on macOS, leveraging native Core Graphics and Quartz frameworks for optimal quality and speed.

## Features

- **Single & Batch Conversion**: Convert individual pages or entire PDF documents
- **Flexible Scaling Options**: 
  - Resolution control (DPI)
  - Percentage scaling
  - Fixed dimensions (width/height fitting)
  - Scale factors
- **Advanced Options**:
  - Transparent background support
  - PNG compression quality control
  - Verbose logging for debugging
- **I/O Flexibility**:
  - Read from files or stdin
  - Write to files, stdout, or batch output directories
  - Customizable output naming patterns
- **Native Performance**: Built with Objective-C using macOS native frameworks
- **Universal Binary**: Supports both Intel and Apple Silicon Macs

## Installation

### Using Homebrew (Recommended)

```bash
brew tap twardoch/homebrew-pdf22png
brew install pdf22png
```

### Building from Source

Requirements:
- macOS 10.15 or later
- Xcode Command Line Tools

```bash
git clone https://github.com/twardoch/pdf22png.git
cd pdf22png
make
sudo make install
```

To build a universal binary for both Intel and Apple Silicon:

```bash
make universal
```

## Usage

### Basic Syntax

```bash
pdf22png [OPTIONS] <input.pdf> [output.png]
```

### Quick Examples

Convert first page of a PDF:
```bash
pdf22png input.pdf output.png
```

Convert a specific page:
```bash
pdf22png -p 5 document.pdf page5.png
```

Convert all pages to individual PNGs:
```bash
pdf22png -a document.pdf
# Creates: document-001.png, document-002.png, etc.
```

Convert at 300 DPI resolution:
```bash
pdf22png -r 300 input.pdf high-res.png
```

Scale to 50% size:
```bash
pdf22png -s 50% input.pdf half-size.png
```

### Options

| Option | Long Form | Description | Default |
|--------|-----------|-------------|---------|
| `-p <n>` | `--page` | Convert specific page number | 1 |
| `-a` | `--all` | Convert all pages | disabled |
| `-r <dpi>` | `--resolution` | Set output DPI (e.g., 300) | 144 |
| `-s <spec>` | `--scale` | Scale specification (see below) | 100% |
| `-t` | `--transparent` | Preserve transparency | disabled |
| `-q <0-9>` | `--quality` | PNG compression quality | 6 |
| `-o <path>` | `--output` | Output file/prefix or `-` for stdout | - |
| `-d <dir>` | `--directory` | Output directory for batch mode | . |
| `-v` | `--verbose` | Enable verbose logging | disabled |
| `-h` | `--help` | Show help message | - |

### Scale Specifications

The `-s/--scale` option accepts various formats:

- **Percentage**: `150%` (1.5x scale)
- **Factor**: `2.0` (2x scale)
- **Fixed width**: `800x` (800px wide, height auto)
- **Fixed height**: `x600` (600px high, width auto)
- **Fit within**: `800x600` (fit within 800x600 box)

### Advanced Examples

Convert with transparent background at 300 DPI:
```bash
pdf22png -t -r 300 input.pdf transparent-300dpi.png
```

Batch convert all pages to a specific directory:
```bash
pdf22png -d ./output_images -o myprefix document.pdf
# Creates: ./output_images/myprefix-001.png, etc.
```

Pipe operations:
```bash
# From stdin to stdout
cat document.pdf | pdf22png - - > output.png

# Process and pipe to ImageMagick
pdf22png -r 300 input.pdf - | convert - -resize 50% final.jpg
```

## Architecture

pdf22png is built using:
- **Objective-C** with ARC (Automatic Reference Counting)
- **Core Graphics** for PDF rendering
- **Quartz** framework for image processing
- **ImageIO** for PNG output
- Native macOS APIs for optimal performance

The codebase is organized into:
- `src/pdf22png.m` - Main program logic and argument parsing
- `src/utils.m` - Utility functions for scaling, rendering, and I/O
- `tests/` - XCTest-based unit tests

## Performance

pdf22png is optimized for performance:
- Parallel processing for batch conversions using Grand Central Dispatch
- Efficient memory management with autoreleasepool usage
- Native Core Graphics rendering for best quality
- Minimal dependencies (only macOS system frameworks)


# main-overview

## Development Guidelines

- Only modify code directly relevant to the specific request. Avoid changing unrelated functionality.
- Never replace code with placeholders like `# ... rest of the processing ...`. Always include complete code.
- Break problems into smaller steps. Think through each step separately before implementing.
- Always provide a complete PLAN with REASONING based on evidence from code and logs before making changes.
- Explain your OBSERVATIONS clearly, then provide REASONING to identify the exact issue. Add console logs when needed to gather more information.


pdf22png implements specialized PDF to PNG conversion logic leveraging macOS native frameworks. The core business functionality is organized around:

## Core Conversion Engine
The primary conversion logic resides in `src/pdf22png.m`, handling:
- PDF page rendering with customizable scaling
- Transparent background preservation 
- Quality-controlled PNG output generation
- Batch processing with parallel execution

## Scale Specification System
Located in `src/utils.m`, implements specialized scaling algorithms:
- Percentage-based scaling (e.g. "150%")
- Fixed dimension specifications (e.g. "800x600")
- DPI-based resolution control
- Aspect ratio preservation logic

## Output Management
Implements flexible output handling:
- Custom naming pattern generation for batch conversions
- Directory organization for multi-page outputs
- Stream-based processing for pipeline integration
- Transparent vs opaque background handling

## Platform Integration
Native integration with macOS frameworks:
- Core Graphics PDF parsing and rendering
- Quartz image processing pipeline
- Universal binary support for Intel/ARM
- System-level optimization for performance

## Processing Modes
Supports multiple operational modes:
- Single page conversion
- Full document batch processing
- Stream-based pipeline processing
- Interactive command-line interface

The business logic focuses on providing professional-grade PDF to PNG conversion with emphasis on flexibility, quality control, and integration capabilities for automated workflows.

—— When you’re done with a round of updates, update CHANGELOG.md with the changes, remove done things from TODO.md, identify new things that need to be done and add them to TODO.md. Then build the app or run ./release.sh and then continue updates.
</file>

<file path=".editorconfig">
# EditorConfig is awesome: https://EditorConfig.org

# top-most EditorConfig file
root = true

[*]
indent_style = space
indent_size = 4
end_of_line = lf
charset = utf-8
trim_trailing_whitespace = true
insert_final_newline = true

[*.md]
trim_trailing_whitespace = false

[Makefile]
indent_style = tab
indent_size = 4

[*.sh]
indent_style = space
indent_size = 2

[*.yml]
indent_style = space
indent_size = 2

[*.rb]
indent_style = space
indent_size = 2
</file>

<file path=".gitattributes">
# Auto detect text files and perform LF normalization
* text=auto eol=lf

# Explicitly declare files that will always have LF line endings on checkout
*.h text eol=lf
*.m text eol=lf
*.c text eol=lf
*.sh text eol=lf
*.md text eol=lf
*.txt text eol=lf
*.yml text eol=lf
*.yaml text eol=lf
*.rb text eol=lf
Makefile text eol=lf
LICENSE text eol=lf

# Explicitly declare files that are binary and should not be modified.
*.png binary
*.pdf binary
*.gz binary
*.zip binary
*.dmg binary
</file>

<file path="LICENSE">
MIT License

Copyright (c) $(date +%Y) twardoch

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="README.html">
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta http-equiv="Content-Style-Type" content="text/css">
  <title></title>
  <meta name="Generator" content="Cocoa HTML Writer">
  <meta name="CocoaVersion" content="2575.6">
  <style type="text/css">
    p.p1 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px 'Helvetica Light'}
    p.p2 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px 'Helvetica Light'; min-height: 14.0px}
  </style>
</head>
<body>
<p class="p1"># pdf22png</p>
<p class="p2"><br></p>
<p class="p1">[![Version](https://img.shields.io/github/v/release/twardoch/pdf22png?label=version)](https://github.com/twardoch/pdf22png/releases/latest)</p>
<p class="p1">[![License](https://img.shields.io/badge/license-MIT-blue.svg)](LICENSE)</p>
<p class="p1">[![Platform](https://img.shields.io/badge/platform-macOS-lightgrey.svg)](https://www.apple.com/macos/)</p>
<p class="p2"><br></p>
<p class="p1">A high-performance command-line tool for converting PDF documents to PNG images on macOS, leveraging native Core Graphics and Quartz frameworks for optimal quality and speed.</p>
<p class="p2"><br></p>
<p class="p1">## Features</p>
<p class="p2"><br></p>
<p class="p1">- **Single &amp; Batch Conversion**: Convert individual pages or entire PDF documents</p>
<p class="p1">- **Flexible Scaling Options**:<span class="Apple-converted-space"> </span></p>
<p class="p1"><span class="Apple-converted-space">  </span>- Resolution control (DPI)</p>
<p class="p1"><span class="Apple-converted-space">  </span>- Percentage scaling</p>
<p class="p1"><span class="Apple-converted-space">  </span>- Fixed dimensions (width/height fitting)</p>
<p class="p1"><span class="Apple-converted-space">  </span>- Scale factors</p>
<p class="p1">- **Advanced Options**:</p>
<p class="p1"><span class="Apple-converted-space">  </span>- Transparent background support</p>
<p class="p1"><span class="Apple-converted-space">  </span>- PNG compression quality control</p>
<p class="p1"><span class="Apple-converted-space">  </span>- Verbose logging for debugging</p>
<p class="p1">- **I/O Flexibility**:</p>
<p class="p1"><span class="Apple-converted-space">  </span>- Read from files or stdin</p>
<p class="p1"><span class="Apple-converted-space">  </span>- Write to files, stdout, or batch output directories</p>
<p class="p1"><span class="Apple-converted-space">  </span>- Customizable output naming patterns</p>
<p class="p1">- **Native Performance**: Built with Objective-C using macOS native frameworks</p>
<p class="p1">- **Universal Binary**: Supports both Intel and Apple Silicon Macs</p>
<p class="p2"><br></p>
<p class="p1">## Installation</p>
<p class="p2"><br></p>
<p class="p1">### Using Homebrew (Recommended)</p>
<p class="p2"><br></p>
<p class="p1">```bash</p>
<p class="p1">brew tap twardoch/homebrew-pdf22png</p>
<p class="p1">brew install pdf22png</p>
<p class="p1">```</p>
<p class="p2"><br></p>
<p class="p1">### Building from Source</p>
<p class="p2"><br></p>
<p class="p1">Requirements:</p>
<p class="p1">- macOS 10.15 or later</p>
<p class="p1">- Xcode Command Line Tools</p>
<p class="p2"><br></p>
<p class="p1">```bash</p>
<p class="p1">git clone https://github.com/twardoch/pdf22png.git</p>
<p class="p1">cd pdf22png</p>
<p class="p1">make</p>
<p class="p1">sudo make install</p>
<p class="p1">```</p>
<p class="p2"><br></p>
<p class="p1">To build a universal binary for both Intel and Apple Silicon:</p>
<p class="p2"><br></p>
<p class="p1">```bash</p>
<p class="p1">make universal</p>
<p class="p1">```</p>
<p class="p2"><br></p>
<p class="p1">## Usage</p>
<p class="p2"><br></p>
<p class="p1">### Basic Syntax</p>
<p class="p2"><br></p>
<p class="p1">```bash</p>
<p class="p1">pdf22png [OPTIONS] &lt;input.pdf&gt; [output.png]</p>
<p class="p1">```</p>
<p class="p2"><br></p>
<p class="p1">### Quick Examples</p>
<p class="p2"><br></p>
<p class="p1">Convert first page of a PDF:</p>
<p class="p1">```bash</p>
<p class="p1">pdf22png input.pdf output.png</p>
<p class="p1">```</p>
<p class="p2"><br></p>
<p class="p1">Convert a specific page:</p>
<p class="p1">```bash</p>
<p class="p1">pdf22png -p 5 document.pdf page5.png</p>
<p class="p1">```</p>
<p class="p2"><br></p>
<p class="p1">Convert all pages to individual PNGs:</p>
<p class="p1">```bash</p>
<p class="p1">pdf22png -a document.pdf</p>
<p class="p1"># Creates: document-001.png, document-002.png, etc.</p>
<p class="p1">```</p>
<p class="p2"><br></p>
<p class="p1">Convert at 300 DPI resolution:</p>
<p class="p1">```bash</p>
<p class="p1">pdf22png -r 300 input.pdf high-res.png</p>
<p class="p1">```</p>
<p class="p2"><br></p>
<p class="p1">Scale to 50% size:</p>
<p class="p1">```bash</p>
<p class="p1">pdf22png -s 50% input.pdf half-size.png</p>
<p class="p1">```</p>
<p class="p2"><br></p>
<p class="p1">### Options</p>
<p class="p2"><br></p>
<p class="p1">| Option | Long Form | Description | Default |</p>
<p class="p1">|--------|-----------|-------------|---------|</p>
<p class="p1">| `-p &lt;n&gt;` | `--page` | Convert specific page number | 1 |</p>
<p class="p1">| `-a` | `--all` | Convert all pages | disabled |</p>
<p class="p1">| `-r &lt;dpi&gt;` | `--resolution` | Set output DPI (e.g., 300) | 144 |</p>
<p class="p1">| `-s &lt;spec&gt;` | `--scale` | Scale specification (see below) | 100% |</p>
<p class="p1">| `-t` | `--transparent` | Preserve transparency | disabled |</p>
<p class="p1">| `-q &lt;0-9&gt;` | `--quality` | PNG compression quality | 6 |</p>
<p class="p1">| `-o &lt;path&gt;` | `--output` | Output file/prefix or `-` for stdout | - |</p>
<p class="p1">| `-d &lt;dir&gt;` | `--directory` | Output directory for batch mode | . |</p>
<p class="p1">| `-v` | `--verbose` | Enable verbose logging | disabled |</p>
<p class="p1">| `-h` | `--help` | Show help message | - |</p>
<p class="p2"><br></p>
<p class="p1">### Scale Specifications</p>
<p class="p2"><br></p>
<p class="p1">The `-s/--scale` option accepts various formats:</p>
<p class="p2"><br></p>
<p class="p1">- **Percentage**: `150%` (1.5x scale)</p>
<p class="p1">- **Factor**: `2.0` (2x scale)</p>
<p class="p1">- **Fixed width**: `800x` (800px wide, height auto)</p>
<p class="p1">- **Fixed height**: `x600` (600px high, width auto)</p>
<p class="p1">- **Fit within**: `800x600` (fit within 800x600 box)</p>
<p class="p2"><br></p>
<p class="p1">### Advanced Examples</p>
<p class="p2"><br></p>
<p class="p1">Convert with transparent background at 300 DPI:</p>
<p class="p1">```bash</p>
<p class="p1">pdf22png -t -r 300 input.pdf transparent-300dpi.png</p>
<p class="p1">```</p>
<p class="p2"><br></p>
<p class="p1">Batch convert all pages to a specific directory:</p>
<p class="p1">```bash</p>
<p class="p1">pdf22png -d ./output_images -o myprefix document.pdf</p>
<p class="p1"># Creates: ./output_images/myprefix-001.png, etc.</p>
<p class="p1">```</p>
<p class="p2"><br></p>
<p class="p1">Pipe operations:</p>
<p class="p1">```bash</p>
<p class="p1"># From stdin to stdout</p>
<p class="p1">cat document.pdf | pdf22png - - &gt; output.png</p>
<p class="p2"><br></p>
<p class="p1"># Process and pipe to ImageMagick</p>
<p class="p1">pdf22png -r 300 input.pdf - | convert - -resize 50% final.jpg</p>
<p class="p1">```</p>
<p class="p2"><br></p>
<p class="p1">## Architecture</p>
<p class="p2"><br></p>
<p class="p1">pdf22png is built using:</p>
<p class="p1">- **Objective-C** with ARC (Automatic Reference Counting)</p>
<p class="p1">- **Core Graphics** for PDF rendering</p>
<p class="p1">- **Quartz** framework for image processing</p>
<p class="p1">- **ImageIO** for PNG output</p>
<p class="p1">- Native macOS APIs for optimal performance</p>
<p class="p2"><br></p>
<p class="p1">The codebase is organized into:</p>
<p class="p1">- `src/pdf22png.m` - Main program logic and argument parsing</p>
<p class="p1">- `src/utils.m` - Utility functions for scaling, rendering, and I/O</p>
<p class="p1">- `tests/` - XCTest-based unit tests</p>
<p class="p2"><br></p>
<p class="p1">## Performance</p>
<p class="p2"><br></p>
<p class="p1">pdf22png is optimized for performance:</p>
<p class="p1">- Parallel processing for batch conversions using Grand Central Dispatch</p>
<p class="p1">- Efficient memory management with autoreleasepool usage</p>
<p class="p1">- Native Core Graphics rendering for best quality</p>
<p class="p1">- Minimal dependencies (only macOS system frameworks)</p>
<p class="p2"><br></p>
<p class="p1">## Contributing</p>
<p class="p2"><br></p>
<p class="p1">Contributions are welcome! Please feel free to submit issues, feature requests, or pull requests.</p>
<p class="p2"><br></p>
<p class="p1">### Development</p>
<p class="p2"><br></p>
<p class="p1">To build from source:</p>
<p class="p1">```bash</p>
<p class="p1">make</p>
<p class="p1">```</p>
<p class="p2"><br></p>
<p class="p1">To run tests:</p>
<p class="p1">```bash</p>
<p class="p1">make test</p>
<p class="p1">```</p>
<p class="p2"><br></p>
<p class="p1">### Releasing</p>
<p class="p2"><br></p>
<p class="p1">To create a new release:</p>
<p class="p1">```bash</p>
<p class="p1"># Automatic versioning (increments minor version)</p>
<p class="p1">./release.sh</p>
<p class="p2"><br></p>
<p class="p1"># Specify version explicitly</p>
<p class="p1">./release.sh --v 2.1.0</p>
<p class="p1">```</p>
<p class="p2"><br></p>
<p class="p1">This will:</p>
<p class="p1">1. Build the universal binary</p>
<p class="p1">2. Run tests</p>
<p class="p1">3. Create and push a git tag</p>
<p class="p1">4. Trigger GitHub Actions to build and publish release artifacts</p>
<p class="p2"><br></p>
<p class="p1">See [TODO.md](TODO.md) for planned features and improvements.</p>
<p class="p2"><br></p>
<p class="p1">## License</p>
<p class="p2"><br></p>
<p class="p1">pdf22png is released under the MIT License. See [LICENSE](LICENSE) for details.</p>
<p class="p2"><br></p>
<p class="p1">## Author</p>
<p class="p2"><br></p>
<p class="p1">- Created by [Adam Twardoch](https://github.com/twardoch)</p>
<p class="p1">- Developed using Anthropic software</p>
<p class="p2"><br></p>
<p class="p1">## See Also</p>
<p class="p2"><br></p>
<p class="p1">- [Usage Guide](docs/USAGE.md) - Detailed usage instructions</p>
<p class="p1">- [Examples](docs/EXAMPLES.md) - More usage examples</p>
<p class="p1">- [API Documentation](docs/API.md) - Function reference</p>
<p class="p1">- [Changelog](CHANGELOG.md) - Version history</p>
</body>
</html>
</file>

<file path=".github/workflows/build.yml">
name: Build and Test

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  build:
    runs-on: macos-latest
    strategy:
      matrix:
        os: [macos-12, macos-13, macos-14]

    steps:
    - uses: actions/checkout@v4

    - name: Build
      run: make

    - name: Run tests
      run: make test

    - name: Build universal binary
      run: make universal

    - name: Upload artifacts
      uses: actions/upload-artifact@v4
      with:
        name: pdf22png-${{ matrix.os }}
        path: src/pdf22png
</file>

<file path="docs/API.md">
# pdf22png API Documentation

While `pdf22png` is primarily a command-line tool, its core logic is available in both Swift and Objective-C implementations. This document provides an overview of the key structures and functions for both versions, which could be adapted for direct use within other macOS applications.

## Core Structures

### Objective-C Implementation

#### `Options`
Defined in `src/pdf22png.h`

This structure holds all the configurable parameters for the PDF conversion process.

```objectivec
typedef struct {
    ScaleSpec scale;            // See ScaleSpec below
    NSInteger pageNumber;       // Specific page to convert (1-based)
    NSString *inputPath;        // Path to the input PDF file (nil for stdin)
    NSString *outputPath;       // Path for the output PNG file or prefix for batch
    NSString *outputDirectory;  // Directory for batch output
    BOOL batchMode;             // YES if converting all pages
    BOOL transparentBackground; // YES to render with transparency
    int pngQuality;             // PNG quality/compression hint (0-9)
    BOOL verbose;               // YES for verbose logging
    BOOL includeText;           // Include extracted text in filename
    NSString *pageRange;        // Page range specification
    BOOL dryRun;                // Preview operations without writing
    NSString *namingPattern;    // Custom naming pattern
    BOOL forceOverwrite;        // Force overwrite without prompting
} Options;
```

#### `ScaleSpec`
Defined in `src/pdf22png.h`

This structure defines how the PDF page should be scaled.

```objectivec
typedef struct {
    CGFloat scaleFactor;  // e.g., 1.0, 1.5, 0.75
    CGFloat maxWidth;     // Max width in pixels for 'WxH' or 'Wx' scaling
    CGFloat maxHeight;    // Max height in pixels for 'WxH' or 'xH' scaling
    CGFloat dpi;          // Dots Per Inch for scaling
    BOOL isPercentage;    // YES if scaleFactor is from a 'NNN%' input
    BOOL isDPI;           // YES if scaling is based on DPI
    BOOL hasWidth;        // YES if maxWidth is set
    BOOL hasHeight;       // YES if maxHeight is set
} ScaleSpec;
```

### Swift Implementation

#### `ProcessingOptions`
Defined in `Sources/pdf22png/Models.swift`

```swift
struct ProcessingOptions {
    var scale = ScaleSpecification()
    var pageNumber: Int = 1
    var inputPath: String?
    var outputPath: String?
    var outputDirectory: String?
    var batchMode = false
    var transparentBackground = false
    var pngQuality = 6
    var verbose = false
    var includeText = false
    var pageRange: String?
    var dryRun = false
    var namingPattern: String?
    var forceOverwrite = false
}
```

#### `ScaleSpecification`
Defined in `Sources/pdf22png/Models.swift`

```swift
struct ScaleSpecification {
    var scaleFactor: CGFloat = 1.0
    var maxWidth: CGFloat = 0
    var maxHeight: CGFloat = 0
    var dpi: CGFloat = 144  // Default DPI
    var isPercentage: Bool = true
    var isDPI: Bool = false
    var hasWidth: Bool = false
    var hasHeight: Bool = false
}
```

## Key Functions

### Objective-C Implementation

The primary logic is found in `src/pdf22png.m` and utility functions in `src/utils.m`.

#### Main Entry Point
The `main` function in `src/pdf22png.m` orchestrates the process:
1.  Parses command-line arguments into an `Options` struct (`parseArguments`).
2.  Reads PDF data (`readPDFData` from `utils.m`).
3.  Creates a `CGPDFDocumentRef` from the data.
4.  Either processes a single page (`processSinglePage`) or all pages in batch mode (`processBatchMode`).

#### Core Conversion Functions

*   **`BOOL parseArguments(int argc, const char *argv[])`** (in `pdf22png.m`)
    *   Parses command-line arguments and populates the `Options` struct.
    *   Handles help messages and argument validation.

*   **`BOOL parseScaleSpec(const char *spec, ScaleSpec *scale)`** (in `utils.m`)
    *   Parses the string provided to the `-s` or `-r` option into a `ScaleSpec` struct.

*   **`NSData *readPDFData(NSString *inputPath, BOOL verbose)`** (in `utils.m`)
    *   Reads PDF file data from the given path or from stdin if `inputPath` is `nil`.

*   **`CGFloat calculateScaleFactor(ScaleSpec *scale, CGRect pageRect)`** (in `utils.m`)
    *   Calculates the final `CGFloat` scale factor to be applied, based on the `ScaleSpec` and the PDF page's dimensions.

*   **`CGImageRef renderPDFPageToImage(CGPDFPageRef pdfPage, CGFloat scaleFactor, BOOL transparentBackground, BOOL verbose)`** (in `utils.m`)
    *   Takes a `CGPDFPageRef` and a scale factor.
    *   Renders the page into a `CGImageRef` (a bitmap image).
    *   Handles background transparency.

*   **`BOOL writeImageToFile(CGImageRef image, NSString *outputPath, int pngQuality, BOOL verbose)`** (in `utils.m`)
    *   Writes the given `CGImageRef` to the specified `outputPath` as a PNG file.

*   **`BOOL writeImageAsPNG(CGImageRef image, NSFileHandle *output, int pngQuality, BOOL verbose)`** (in `utils.m`)
    *   Writes the `CGImageRef` as PNG data to the given `NSFileHandle` (e.g., stdout).

*   **`BOOL processSinglePage(CGPDFDocumentRef pdfDocument, Options *options)`** (in `pdf22png.m`)
    *   Orchestrates the conversion of a single PDF page based on `options`.

*   **`BOOL processBatchMode(CGPDFDocumentRef pdfDocument, Options *options)`** (in `pdf22png.m`)
    *   Orchestrates the conversion of all pages in a PDF document, typically using Grand Central Dispatch (`dispatch_apply`) for parallel processing.

#### Helper Functions

*   **`void printUsage(const char *programName)`** (in `pdf22png.m`)
*   **`NSString *getOutputPrefix(Options *options)`** (in `utils.m`)
*   **`void logMessage(BOOL verbose, NSString *format, ...)`** (in `utils.m`)
*   **`NSString *extractTextFromPDFPage(CGPDFPageRef page)`** (in `utils.m`)
*   **`NSString *performOCROnImage(CGImageRef image)`** (in `utils.m`)
*   **`NSArray<NSNumber *> *parsePageRange(NSString *rangeSpec, NSUInteger totalPages)`** (in `utils.m`)

### Swift Implementation

The Swift implementation is found in `Sources/pdf22png/`.

#### Main Entry Point
The `PDF22PNG` struct in `main.swift` uses ArgumentParser:
1. Parses command-line arguments automatically via `@Option` and `@Flag` properties
2. Configures options in the `run()` method
3. Calls either `processSinglePage` or `processBatchMode`

#### Core Conversion Functions

*   **`func parseScaleSpecification(_ spec: String) -> ScaleSpecification?`** (in `Utilities.swift`)
    *   Parses scale specifications into a `ScaleSpecification` struct

*   **`func readPDFData(_ inputPath: String?, verbose: Bool) -> Data?`** (in `Utilities.swift`)
    *   Reads PDF data from file or stdin

*   **`func calculateScaleFactor(scale: ScaleSpecification, pageRect: CGRect) -> CGFloat`** (in `Utilities.swift`)
    *   Calculates the scale factor based on specifications

*   **`func renderPDFPageToImage(page: PDFPage, scaleFactor: CGFloat, transparentBackground: Bool, verbose: Bool) -> CGImage?`** (in `Utilities.swift`)
    *   Renders a PDF page to a CGImage

*   **`func writeImageToFile(image: CGImage, path: String, quality: Int, verbose: Bool, dryRun: Bool, forceOverwrite: Bool) -> Bool`** (in `Utilities.swift`)
    *   Writes image to file with overwrite protection

*   **`func processSinglePage(pdfDocument: PDFDocument, options: inout ProcessingOptions) throws -> Bool`** (in `main.swift`)
    *   Processes a single PDF page

*   **`func processBatchMode(pdfDocument: PDFDocument, options: inout ProcessingOptions) throws -> Bool`** (in `main.swift`)
    *   Processes multiple pages using Swift Concurrency

#### Helper Functions

*   **`func logMessage(_ verbose: Bool, _ message: String)`** (in `Utilities.swift`)
*   **`func extractTextFromPDFPage(page: PDFPage) -> String?`** (in `Utilities.swift`)
*   **`func performOCROnImage(image: CGImage) async -> String?`** (in `Utilities.swift`)
*   **`func parsePageRange(_ rangeSpec: String, totalPages: Int) -> [Int]?`** (in `Utilities.swift`)
*   **`func formatFilenameWithPattern(...) -> String`** (in `Utilities.swift`)

## Using the Code

### Objective-C Usage

To use the Objective-C implementation directly:
1. Include `pdf22png.h` and `utils.h`
2. Compile and link `pdf22png.m` and `utils.m` with your project
3. Link against frameworks: `Foundation`, `Quartz`, `Vision`, and `ImageIO`
4. Populate an `Options` struct with your settings
5. Call the appropriate processing functions

### Swift Usage

To use the Swift implementation:
1. Import the module or include the Swift files
2. Create a `ProcessingOptions` instance
3. Use the utility functions directly
4. For CLI parsing, extend the `PDF22PNG` struct

### Framework Requirements

Both implementations require:
- Foundation
- CoreGraphics / Quartz
- PDFKit (part of Quartz)
- Vision (for OCR)
- ImageIO

### Error Handling

- **Objective-C**: Uses BOOL returns and logs errors to stderr
- **Swift**: Uses Swift's error handling with `throws` and typed errors

For library use, you may want to adapt the error handling to return proper error objects instead of printing to stderr.
</file>

<file path="src/Core/MemoryManager.swift">
import Foundation
import Darwin.Mach

// MARK: - Memory Management System

class MemoryManager {
    static let shared = MemoryManager()
    private init() {}
    
    // System memory thresholds (in bytes)
    private let lowMemoryThreshold: UInt64 = 512 * 1024 * 1024    // 512MB
    private let criticalMemoryThreshold: UInt64 = 256 * 1024 * 1024 // 256MB
    private let maxMemoryUsage: UInt64 = 2 * 1024 * 1024 * 1024    // 2GB
    
    func getSystemMemoryInfo() -> (total: UInt64, available: UInt64, used: UInt64) {
        var size = MemoryLayout<vm_size_t>.size
        var physicalMemory: vm_size_t = 0
        sysctlbyname("hw.memsize", &physicalMemory, &size, nil, 0)
        
        var info = mach_task_basic_info()
        var count = mach_msg_type_number_t(MemoryLayout<mach_task_basic_info>.size)/4
        
        let kr = withUnsafeMutablePointer(to: &info) {
            $0.withMemoryRebound(to: integer_t.self, capacity: 1) {
                task_info(mach_task_self_, task_flavor_t(MACH_TASK_BASIC_INFO), $0, &count)
            }
        }
        
        let used = UInt64(kr == KERN_SUCCESS ? info.resident_size : 0)
        let total = UInt64(physicalMemory)
        let available = total > used ? total - used : 0
        
        return (total: total, available: available, used: used)
    }
    
    func isMemoryPressureHigh() -> Bool {
        let memInfo = getSystemMemoryInfo()
        return memInfo.available < lowMemoryThreshold
    }
    
    func isMemoryPressureCritical() -> Bool {
        let memInfo = getSystemMemoryInfo()
        return memInfo.available < criticalMemoryThreshold
    }
    
    func estimateMemoryRequirement(pageRect: CGRect, scaleFactor: CGFloat, transparentBackground: Bool) -> UInt64 {
        let scaledWidth = pageRect.width * scaleFactor
        let scaledHeight = pageRect.height * scaleFactor
        let pixelCount = scaledWidth * scaledHeight
        
        // 4 bytes per pixel (RGBA), plus overhead
        let baseMemory = UInt64(pixelCount * 4)
        
        // Add overhead for Core Graphics contexts and intermediate buffers
        let overhead = baseMemory / 4
        
        // Transparent backgrounds require more memory
        let transparencyMultiplier: CGFloat = transparentBackground ? 1.5 : 1.0
        
        return UInt64(CGFloat(baseMemory + overhead) * transparencyMultiplier)
    }
    
    func canAllocateMemory(_ requiredMemory: UInt64, verbose: Bool) -> Bool {
        let memInfo = getSystemMemoryInfo()
        let canAllocate = memInfo.available > requiredMemory + criticalMemoryThreshold
        
        if verbose {
            let availableMB = memInfo.available / (1024 * 1024)
            let requiredMB = requiredMemory / (1024 * 1024)
            logMessage(true, "Memory check: Available \(availableMB)MB, Required \(requiredMB)MB")
        }
        
        return canAllocate
    }
    
    func calculateOptimalBatchSize(totalPages: Int, pageRect: CGRect, scaleFactor: CGFloat, verbose: Bool) -> Int {
        let memoryPerPage = estimateMemoryRequirement(pageRect: pageRect, scaleFactor: scaleFactor, transparentBackground: false)
        let memInfo = getSystemMemoryInfo()
        let availableForBatch = memInfo.available / 2 // Use only half of available memory
        
        let optimalBatchSize = max(1, min(totalPages, Int(availableForBatch / memoryPerPage)))
        
        if verbose {
            let batchMemoryMB = (UInt64(optimalBatchSize) * memoryPerPage) / (1024 * 1024)
            logMessage(true, "Optimal batch size: \(optimalBatchSize) pages (\(batchMemoryMB)MB estimated)")
        }
        
        return optimalBatchSize
    }
    
    func logMemoryStatus(verbose: Bool) {
        if !verbose { return }
        
        let memInfo = getSystemMemoryInfo()
        let totalGB = Double(memInfo.total) / (1024 * 1024 * 1024)
        let availableMB = memInfo.available / (1024 * 1024)
        let usedMB = memInfo.used / (1024 * 1024)
        
        logMessage(true, String(format: "Memory status: %.1fGB total, %lluMB used, %lluMB available", 
                              totalGB, usedMB, availableMB))
        
        if isMemoryPressureCritical() {
            print("⚠️  Critical memory pressure detected!")
        } else if isMemoryPressureHigh() {
            print("⚠️  High memory pressure detected")
        }
    }
    
    func checkMemoryPressureDuringBatch(verbose: Bool) throws {
        if isMemoryPressureCritical() {
            throw PDF22PNGError.memory
        }
        
        if isMemoryPressureHigh() && verbose {
            print("⚠️  High memory pressure - consider reducing batch size")
        }
    }
}

// Helper function for logging (to be defined elsewhere)
func logMessage(_ verbose: Bool, _ message: String) {
    if verbose {
        fputs("[\(DateFormatter.logFormat.string(from: Date()))] \(message)\n", stderr)
    }
}

extension DateFormatter {
    static let logFormat: DateFormatter = {
        let formatter = DateFormatter()
        formatter.dateFormat = "yyyy-MM-dd HH:mm:ss"
        return formatter
    }()
}
</file>

<file path="src/llms.txt">
This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
CLI/
  ArgumentParser.swift
  OutputFormatter.swift
Core/
  BatchProcessor.swift
  ImageRenderer.swift
  MemoryManager.swift
  PDFProcessor.swift
  ResourceManager.swift
  SignalHandler.swift
Models/
  Errors.swift
  ProcessingOptions.swift
  Results.swift
  ScaleSpecification.swift
Utilities/
  InputValidator.swift
  ProgressReporter.swift
main.swift
Makefile
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="CLI/ArgumentParser.swift">
import Foundation

// MARK: - Command Line Argument Parser

struct ArgumentParser {
    static func parseArguments() -> ProcessingOptions {
        var options = ProcessingOptions()
        let args = Array(CommandLine.arguments.dropFirst())
        var i = 0
        
        while i < args.count {
            let arg = args[i]
            
            switch arg {
            case "-h", "--help":
                options.showHelp = true
                return options
                
            case "--version":
                options.showVersion = true
                return options
                
            case "-p", "--page":
                guard i + 1 < args.count else {
                    print("Error: --page requires a value")
                    exit(2)
                }
                options.page = args[i + 1]
                i += 1
                
            case "-a", "--all":
                options.allPages = true
                
            case "-r", "--resolution":
                guard i + 1 < args.count else {
                    print("Error: --resolution requires a value")
                    exit(2)
                }
                options.resolution = args[i + 1]
                i += 1
                
            case "-s", "--scale":
                guard i + 1 < args.count else {
                    print("Error: --scale requires a value")
                    exit(2)
                }
                options.scale = args[i + 1]
                i += 1
                
            case "-t", "--transparent":
                options.transparent = true
                
            case "-q", "--quality":
                guard i + 1 < args.count else {
                    print("Error: --quality requires a value")
                    exit(2)
                }
                guard let quality = Int(args[i + 1]), quality >= 0 && quality <= 9 else {
                    print("Error: quality must be between 0 and 9")
                    exit(2)
                }
                options.quality = quality
                i += 1
                
            case "-o", "--output":
                guard i + 1 < args.count else {
                    print("Error: --output requires a value")
                    exit(2)
                }
                options.outputPath = args[i + 1]
                i += 1
                
            case "-d", "--directory":
                guard i + 1 < args.count else {
                    print("Error: --directory requires a value")
                    exit(2)
                }
                options.directory = args[i + 1]
                i += 1
                
            case "-v", "--verbose":
                options.verbose = true
                
            case "-n", "--name":
                options.includeText = true
                
            case "-P", "--pattern":
                guard i + 1 < args.count else {
                    print("Error: --pattern requires a value")
                    exit(2)
                }
                options.namingPattern = args[i + 1]
                i += 1
                
            case "-D", "--dry-run":
                options.dryRun = true
                
            case "-f", "--force":
                options.forceOverwrite = true
                
            default:
                if arg.hasPrefix("-") {
                    print("Error: Unknown option: \(arg)")
                    print("Use --help for usage information")
                    exit(2)
                } else {
                    // Positional arguments
                    if options.inputFile == nil {
                        options.inputFile = arg
                    } else if options.outputFile == nil {
                        options.outputFile = arg
                    } else {
                        print("Error: Too many arguments")
                        exit(2)
                    }
                }
            }
            i += 1
        }
        
        return options
    }
    
    static func validateArguments(_ options: ProcessingOptions) throws {
        // Input validation
        if options.inputFile == nil && !options.isStdinMode {
            throw PDF22PNGError.noInput
        }
        
        // Output validation for single page mode
        if !options.isBatchMode && options.outputFile == nil && options.outputPath == nil {
            throw PDF22PNGError.invalidArgs
        }
        
        // Scale validation
        if ScaleParser.parseScaleSpecification(options.effectiveScale) == nil {
            throw PDF22PNGError.invalidScale
        }
        
        // Quality validation (already handled in parsing)
        if options.quality < 0 || options.quality > 9 {
            throw PDF22PNGError.invalidArgs
        }
    }
}
</file>

<file path="CLI/OutputFormatter.swift">
import Foundation

// MARK: - Output Formatter

struct OutputFormatter {
    static func printHelp() {
        print("""
Usage: pdf22png [OPTIONS] <input.pdf> [output.png]
Converts PDF documents to PNG images.

Options:
  -p, --page <spec>       Page(s) to convert. Single page, range, or comma-separated.
                          Examples: 1 | 1-5 | 1,3,5-10 (default: 1)
                          In batch mode, only specified pages are converted.
  -a, --all               Convert all pages. If -d is not given, uses input filename as prefix.
                          Output files named <prefix>-<page_num>.png.
  -r, --resolution <dpi>  Set output DPI (e.g., 150dpi). Overrides -s if both used with numbers.
  -s, --scale <spec>      Scaling specification (default: 100% or 1.0).
                            NNN%: percentage (e.g., 150%)
                            N.N:  scale factor (e.g., 1.5)
                            WxH:  fit to WxH pixels (e.g., 800x600)
                            Wx:   fit to width W pixels (e.g., 1024x)
                            xH:   fit to height H pixels (e.g., x768)
  -t, --transparent       Preserve transparency (default: white background).
  -q, --quality <n>       PNG compression quality (0-9, default: 6). Currently informational.
  -o, --output <path>     Output PNG file or prefix for batch mode.
                          If '-', output to stdout (single page mode only).
  -d, --directory <dir>   Output directory for batch mode (converts all pages).
                          If used, -o specifies filename prefix inside this directory.
  -v, --verbose           Verbose output.
  -n, --name              Include extracted text in output filename (batch mode only).
  -P, --pattern <pat>     Custom naming pattern for batch mode. Placeholders:
                          {basename} - Input filename without extension
                          {page} - Page number (auto-padded)
                          {page:03d} - Page with custom padding
                          {text} - Extracted text (requires -n)
                          {date} - Current date (YYYYMMDD)
                          {time} - Current time (HHMMSS)
                          {total} - Total page count
                          Example: '{basename}_p{page:04d}_of_{total}'
  -D, --dry-run           Preview operations without writing files.
  -f, --force             Force overwrite existing files without prompting.
  -h, --help              Show this help message and exit.
  --version               Show version information and exit.

Arguments:
  <input.pdf>             Input PDF file. If '-', reads from stdin.
  [output.png]            Output PNG file. Required if not using -o or -d.
                          If input is stdin and output is not specified, output goes to stdout.
                          In batch mode (-a or -d), this is used as a prefix if -o is not set.

Examples:
  pdf22png document.pdf page1.png              # Convert first page
  pdf22png -p 5 document.pdf page5.png         # Convert page 5
  pdf22png -a document.pdf                     # Convert all pages (document-001.png, ...)
  pdf22png -r 300 document.pdf hi-res.png      # High resolution
  pdf22png -s 150% document.pdf large.png      # 1.5x scale
  pdf22png -d output/ document.pdf             # All pages to output/ directory
  pdf22png -t document.pdf transparent.png     # Preserve transparency
  cat document.pdf | pdf22png - output.png     # From stdin
""")
    }
    
    static func printVersion() {
        let version = "2.0.0-standalone"
        print("pdf22png \(version)")
        print("Swift standalone implementation")
    }
    
    static func formatError(_ error: PDF22PNGError, context: String? = nil) -> String {
        var output = "❌ Error: \(error.errorDescription ?? "Unknown error")"
        
        if let ctx = context {
            output += "\n📍 Context: \(ctx)"
        }
        
        if let suggestion = error.recoverySuggestion {
            output += "\n💡 Help: \(suggestion)"
        }
        
        return output
    }
    
    static func formatProgress(_ progress: ProgressInfo) -> String {
        let percentage = Int((Double(progress.completed) / Double(progress.total)) * 100)
        let progressBar = createProgressBar(percentage: percentage)
        
        var output = "\r\(progressBar) \(percentage)% (\(progress.completed)/\(progress.total))"
        
        if let speed = progress.speed {
            output += " - \(String(format: "%.1f", speed)) pages/sec"
        }
        
        if let eta = progress.estimatedTimeRemaining {
            output += " - ETA: \(formatDuration(eta))"
        }
        
        return output
    }
    
    static func formatResults(_ results: ProcessingResults) -> String {
        var output = "\n✅ Processing complete!\n"
        output += "   Total: \(results.totalPages) pages"
        
        if results.processingTime > 0 {
            output += " in \(formatDuration(results.processingTime))"
        }
        
        output += "\n   Results: ✓ \(results.successfulPages) successful"
        
        if results.failedPages > 0 {
            output += ", ✗ \(results.failedPages) failed"
        }
        
        if results.pagesPerSecond > 0 {
            output += "\n   Average speed: \(String(format: "%.1f", results.pagesPerSecond)) pages/sec"
        }
        
        return output
    }
    
    private static func createProgressBar(percentage: Int, width: Int = 20) -> String {
        let filled = Int(Double(percentage) / 100.0 * Double(width))
        let empty = width - filled
        return "[" + String(repeating: "█", count: filled) + String(repeating: "░", count: empty) + "]"
    }
    
    private static func formatDuration(_ seconds: TimeInterval) -> String {
        let minutes = Int(seconds) / 60
        let secs = Int(seconds) % 60
        if minutes > 0 {
            return "\(minutes)m \(secs)s"
        } else {
            return "\(secs)s"
        }
    }
}

// MARK: - Progress Info

struct ProgressInfo {
    let completed: Int
    let total: Int
    let speed: Double?
    let estimatedTimeRemaining: TimeInterval?
    let currentOperation: String?
}
</file>

<file path="Core/BatchProcessor.swift">
import Foundation
import CoreGraphics
import PDFKit

// MARK: - Batch Processing

class BatchProcessor {
    static let shared = BatchProcessor()
    private init() {}
    
    struct BatchOptions {
        let totalPages: Int
        let outputDirectory: String
        let prefix: String
        let scaleFactor: CGFloat
        let transparent: Bool
        let quality: Int
        let verbose: Bool
        let dryRun: Bool
        let forceOverwrite: Bool
    }
    
    struct BatchResult {
        let totalPages: Int
        let successfulPages: Int
        let failedPages: Int
        let interrupted: Bool
    }
    
    func processBatch(document: PDFDocument, options: BatchOptions) async throws -> BatchResult {
        let totalPages = options.totalPages
        
        // Create output directory
        if !options.dryRun {
            do {
                try FileManager.default.createDirectory(atPath: options.outputDirectory, withIntermediateDirectories: true, attributes: nil)
            } catch {
                throw PDF22PNGError.outputDir
            }
        }
        
        // Calculate optimal batch size based on memory
        guard let firstPage = document.page(at: 0) else {
            throw PDF22PNGError.renderFailed
        }
        
        let pageRect = firstPage.bounds(for: .mediaBox)
        let optimalBatchSize = MemoryManager.shared.calculateOptimalBatchSize(
            totalPages: totalPages,
            pageRect: pageRect,
            scaleFactor: options.scaleFactor,
            verbose: options.verbose
        )
        
        // Initialize progress reporter
        let progressReporter = ProgressReporter(totalPages: totalPages, verbose: options.verbose)
        
        if !options.dryRun {
            print("🚀 Starting batch conversion of \(totalPages) pages...")
            if options.verbose {
                print("   Output directory: \(options.outputDirectory)")
                print("   Output prefix: \(options.prefix)")
                print("   Batch size: \(optimalBatchSize) pages/chunk")
            }
        }
        
        // Process pages in memory-optimized chunks
        let chunks = stride(from: 1, through: totalPages, by: optimalBatchSize).map { start in
            Array(start..<min(start + optimalBatchSize, totalPages + 1))
        }
        
        var successfulPages = 0
        var failedPages = 0
        var interrupted = false
        
        for (chunkIndex, chunk) in chunks.enumerated() {
            // Check for interruption before each chunk
            do {
                try checkInterruption()
            } catch {
                interrupted = true
                break
            }
            
            // Check memory pressure before each chunk
            do {
                try MemoryManager.shared.checkMemoryPressureDuringBatch(verbose: options.verbose)
            } catch {
                // Continue processing even under memory pressure
            }
            
            progressReporter.reportChunkStart(chunkNumber: chunkIndex + 1, totalChunks: chunks.count, pagesInChunk: chunk.count)
            
            for pageNum in chunk {
                // Check for interruption for each page
                do {
                    try checkInterruption()
                } catch {
                    interrupted = true
                    break
                }
                
                progressReporter.reportPageStart(pageNumber: pageNum)
                
                guard let pdfPage = document.page(at: pageNum - 1) else {
                    progressReporter.reportPageComplete(pageNumber: pageNum, success: false)
                    failedPages += 1
                    continue
                }
                
                let renderOptions = ImageRenderer.RenderOptions(
                    scaleFactor: options.scaleFactor,
                    transparentBackground: options.transparent,
                    quality: options.quality,
                    verbose: options.verbose,
                    dryRun: options.dryRun,
                    forceOverwrite: options.forceOverwrite
                )
                
                guard let image = ImageRenderer.shared.renderPageToImage(page: pdfPage, options: renderOptions) else {
                    progressReporter.reportPageComplete(pageNumber: pageNum, success: false)
                    failedPages += 1
                    continue
                }
                
                let filename = String(format: "%@-%03d.png", options.prefix, pageNum)
                let outputPath = (options.outputDirectory as NSString).appendingPathComponent(filename)
                
                if options.dryRun {
                    print("[DRY-RUN] Would create: \(filename) (\(image.width)x\(image.height) pixels)")
                    progressReporter.reportPageComplete(pageNumber: pageNum, success: true, outputFile: filename)
                    successfulPages += 1
                } else {
                    let success = ImageRenderer.shared.writeImageToFile(image: image, path: outputPath, options: renderOptions)
                    progressReporter.reportPageComplete(pageNumber: pageNum, success: success, outputFile: success ? filename : nil)
                    if success {
                        successfulPages += 1
                    } else {
                        failedPages += 1
                    }
                }
            }
            
            // Log memory status after each chunk in verbose mode
            if options.verbose && chunks.count > 1 {
                MemoryManager.shared.logMemoryStatus(verbose: true)
            }
            
            if interrupted {
                progressReporter.reportInterrupted()
                break
            }
        }
        
        // Final status report
        if options.dryRun && !interrupted {
            print("\n[DRY-RUN] Would convert \(totalPages) pages to PNG files")
        } else if !interrupted {
            progressReporter.reportBatchComplete()
        }
        
        return BatchResult(
            totalPages: totalPages,
            successfulPages: successfulPages,
            failedPages: failedPages,
            interrupted: interrupted
        )
    }
    
    func calculateOptimalConcurrency(pages: Int, memoryRequirement: UInt64) -> Int {
        let memInfo = MemoryManager.shared.getSystemMemoryInfo()
        let availableMemory = memInfo.available / 2 // Use only half of available memory
        let maxConcurrentPages = max(1, Int(availableMemory / memoryRequirement))
        return min(pages, maxConcurrentPages)
    }
}
</file>

<file path="Core/ImageRenderer.swift">
import Foundation
import CoreGraphics
import PDFKit
import UniformTypeIdentifiers

// MARK: - Image Rendering

class ImageRenderer {
    static let shared = ImageRenderer()
    private init() {}
    
    struct RenderOptions {
        let scaleFactor: CGFloat
        let transparentBackground: Bool
        let quality: Int
        let verbose: Bool
        let dryRun: Bool
        let forceOverwrite: Bool
    }
    
    func renderPageToImage(page: PDFPage, options: RenderOptions) -> CGImage? {
        let pageRect = page.bounds(for: .mediaBox)
        let scaledWidth = Int(pageRect.width * options.scaleFactor)
        let scaledHeight = Int(pageRect.height * options.scaleFactor)
        
        logMessage(options.verbose, "Rendering page at \(scaledWidth)x\(scaledHeight) (scale: \(options.scaleFactor))")
        
        let colorSpace = CGColorSpaceCreateDeviceRGB()
        let bitmapInfo: CGBitmapInfo = options.transparentBackground ? 
            [.byteOrder32Big, CGBitmapInfo(rawValue: CGImageAlphaInfo.premultipliedLast.rawValue)] :
            [.byteOrder32Big, CGBitmapInfo(rawValue: CGImageAlphaInfo.noneSkipLast.rawValue)]
        
        guard let context = CGContext(
            data: nil,
            width: scaledWidth,
            height: scaledHeight,
            bitsPerComponent: 8,
            bytesPerRow: 0,
            space: colorSpace,
            bitmapInfo: bitmapInfo.rawValue
        ) else {
            return nil
        }
        
        context.scaleBy(x: options.scaleFactor, y: options.scaleFactor)
        
        if !options.transparentBackground {
            context.setFillColor(CGColor.white)
            context.fill(CGRect(x: 0, y: 0, width: pageRect.width, height: pageRect.height))
        }
        
        page.draw(with: .mediaBox, to: context)
        
        return context.makeImage()
    }
    
    func writeImageToFile(image: CGImage, path: String, options: RenderOptions) -> Bool {
        if options.dryRun {
            let width = image.width
            let height = image.height
            print("[DRY-RUN] Would write \(width)x\(height) PNG to: \(path)")
            return true
        }
        
        // Check if file exists and handle overwrite
        if FileManager.default.fileExists(atPath: path) && !options.forceOverwrite {
            print("File \(path) already exists. Use --force to overwrite.")
            return false
        }
        
        let url = URL(fileURLWithPath: path)
        guard let destination = CGImageDestinationCreateWithURL(url as CFURL, UTType.png.identifier as CFString, 1, nil) else {
            return false
        }
        
        let compressionOptions: [CFString: Any] = [
            kCGImageDestinationLossyCompressionQuality: CGFloat(options.quality) / 9.0
        ]
        
        CGImageDestinationAddImage(destination, image, compressionOptions as CFDictionary)
        let success = CGImageDestinationFinalize(destination)
        
        if success {
            logMessage(options.verbose, "Successfully wrote PNG to: \(path)")
        }
        
        return success
    }
    
    func writeImageToStdout(image: CGImage, options: RenderOptions) -> Bool {
        logMessage(options.verbose, "Writing PNG to stdout")
        
        let data = NSMutableData()
        guard let destination = CGImageDestinationCreateWithData(data, UTType.png.identifier as CFString, 1, nil) else {
            return false
        }
        
        let compressionOptions: [CFString: Any] = [
            kCGImageDestinationLossyCompressionQuality: CGFloat(options.quality) / 9.0
        ]
        
        CGImageDestinationAddImage(destination, image, compressionOptions as CFDictionary)
        guard CGImageDestinationFinalize(destination) else {
            return false
        }
        
        let stdout = FileHandle.standardOutput
        stdout.write(data as Data)
        return true
    }
    
    func calculateScaleFactor(spec: ScaleSpecification, pageRect: CGRect) -> CGFloat {
        switch spec {
        case .percentage(let percent):
            return percent / 100.0
        case .factor(let factor):
            return factor
        case .resolution(let dpi):
            return dpi / 72.0  // 72 DPI is the default PDF resolution
        case .width(let width):
            return width / pageRect.width
        case .height(let height):
            return height / pageRect.height
        case .fit(let width, let height):
            let scaleX = width / pageRect.width
            let scaleY = height / pageRect.height
            return min(scaleX, scaleY)
        }
    }
}
</file>

<file path="Core/MemoryManager.swift">
import Foundation
import Darwin.Mach

// MARK: - Memory Management System

class MemoryManager {
    static let shared = MemoryManager()
    private init() {}
    
    // System memory thresholds (in bytes)
    private let lowMemoryThreshold: UInt64 = 512 * 1024 * 1024    // 512MB
    private let criticalMemoryThreshold: UInt64 = 256 * 1024 * 1024 // 256MB
    private let maxMemoryUsage: UInt64 = 2 * 1024 * 1024 * 1024    // 2GB
    
    func getSystemMemoryInfo() -> (total: UInt64, available: UInt64, used: UInt64) {
        var size = MemoryLayout<vm_size_t>.size
        var physicalMemory: vm_size_t = 0
        sysctlbyname("hw.memsize", &physicalMemory, &size, nil, 0)
        
        var info = mach_task_basic_info()
        var count = mach_msg_type_number_t(MemoryLayout<mach_task_basic_info>.size)/4
        
        let kr = withUnsafeMutablePointer(to: &info) {
            $0.withMemoryRebound(to: integer_t.self, capacity: 1) {
                task_info(mach_task_self_, task_flavor_t(MACH_TASK_BASIC_INFO), $0, &count)
            }
        }
        
        let used = UInt64(kr == KERN_SUCCESS ? info.resident_size : 0)
        let total = UInt64(physicalMemory)
        let available = total > used ? total - used : 0
        
        return (total: total, available: available, used: used)
    }
    
    func isMemoryPressureHigh() -> Bool {
        let memInfo = getSystemMemoryInfo()
        return memInfo.available < lowMemoryThreshold
    }
    
    func isMemoryPressureCritical() -> Bool {
        let memInfo = getSystemMemoryInfo()
        return memInfo.available < criticalMemoryThreshold
    }
    
    func estimateMemoryRequirement(pageRect: CGRect, scaleFactor: CGFloat, transparentBackground: Bool) -> UInt64 {
        let scaledWidth = pageRect.width * scaleFactor
        let scaledHeight = pageRect.height * scaleFactor
        let pixelCount = scaledWidth * scaledHeight
        
        // 4 bytes per pixel (RGBA), plus overhead
        let baseMemory = UInt64(pixelCount * 4)
        
        // Add overhead for Core Graphics contexts and intermediate buffers
        let overhead = baseMemory / 4
        
        // Transparent backgrounds require more memory
        let transparencyMultiplier: CGFloat = transparentBackground ? 1.5 : 1.0
        
        return UInt64(CGFloat(baseMemory + overhead) * transparencyMultiplier)
    }
    
    func canAllocateMemory(_ requiredMemory: UInt64, verbose: Bool) -> Bool {
        let memInfo = getSystemMemoryInfo()
        let canAllocate = memInfo.available > requiredMemory + criticalMemoryThreshold
        
        if verbose {
            let availableMB = memInfo.available / (1024 * 1024)
            let requiredMB = requiredMemory / (1024 * 1024)
            logMessage(true, "Memory check: Available \(availableMB)MB, Required \(requiredMB)MB")
        }
        
        return canAllocate
    }
    
    func calculateOptimalBatchSize(totalPages: Int, pageRect: CGRect, scaleFactor: CGFloat, verbose: Bool) -> Int {
        let memoryPerPage = estimateMemoryRequirement(pageRect: pageRect, scaleFactor: scaleFactor, transparentBackground: false)
        let memInfo = getSystemMemoryInfo()
        let availableForBatch = memInfo.available / 2 // Use only half of available memory
        
        let optimalBatchSize = max(1, min(totalPages, Int(availableForBatch / memoryPerPage)))
        
        if verbose {
            let batchMemoryMB = (UInt64(optimalBatchSize) * memoryPerPage) / (1024 * 1024)
            logMessage(true, "Optimal batch size: \(optimalBatchSize) pages (\(batchMemoryMB)MB estimated)")
        }
        
        return optimalBatchSize
    }
    
    func logMemoryStatus(verbose: Bool) {
        if !verbose { return }
        
        let memInfo = getSystemMemoryInfo()
        let totalGB = Double(memInfo.total) / (1024 * 1024 * 1024)
        let availableMB = memInfo.available / (1024 * 1024)
        let usedMB = memInfo.used / (1024 * 1024)
        
        logMessage(true, String(format: "Memory status: %.1fGB total, %lluMB used, %lluMB available", 
                              totalGB, usedMB, availableMB))
        
        if isMemoryPressureCritical() {
            print("⚠️  Critical memory pressure detected!")
        } else if isMemoryPressureHigh() {
            print("⚠️  High memory pressure detected")
        }
    }
    
    func checkMemoryPressureDuringBatch(verbose: Bool) throws {
        if isMemoryPressureCritical() {
            throw PDF22PNGError.memory
        }
        
        if isMemoryPressureHigh() && verbose {
            print("⚠️  High memory pressure - consider reducing batch size")
        }
    }
}

// Helper function for logging (to be defined elsewhere)
func logMessage(_ verbose: Bool, _ message: String) {
    if verbose {
        fputs("[\(DateFormatter.logFormat.string(from: Date()))] \(message)\n", stderr)
    }
}

extension DateFormatter {
    static let logFormat: DateFormatter = {
        let formatter = DateFormatter()
        formatter.dateFormat = "yyyy-MM-dd HH:mm:ss"
        return formatter
    }()
}
</file>

<file path="Core/PDFProcessor.swift">
import Foundation
import CoreGraphics
import PDFKit
import UniformTypeIdentifiers

// MARK: - PDF Processing

class PDFProcessor {
    static let shared = PDFProcessor()
    private init() {}
    
    func readPDFData(_ inputPath: String?, verbose: Bool) -> Data? {
        if let path = inputPath, path != "-" {
            logMessage(verbose, "Reading PDF from file: \(path)")
            return FileManager.default.contents(atPath: path)
        } else {
            logMessage(verbose, "Reading PDF from stdin")
            let stdin = FileHandle.standardInput
            return stdin.readDataToEndOfFile()
        }
    }
    
    func createPDFDocument(from data: Data) -> PDFDocument? {
        return PDFDocument(data: data)
    }
    
    func validatePDF(_ document: PDFDocument) -> Bool {
        return document.pageCount > 0
    }
    
    func getPageCount(_ document: PDFDocument) -> Int {
        return document.pageCount
    }
    
    func extractPage(_ document: PDFDocument, pageNumber: Int) -> PDFPage? {
        guard pageNumber > 0 && pageNumber <= document.pageCount else {
            return nil
        }
        return document.page(at: pageNumber - 1) // Convert to 0-based index
    }
}
</file>

<file path="Core/ResourceManager.swift">
import Foundation

// MARK: - Resource Management System

class ResourceManager {
    static let shared = ResourceManager()
    private init() {}
    
    private var tempFiles: Set<String> = []
    private var fileHandles: Set<ObjectIdentifier> = []
    private let resourceQueue = DispatchQueue(label: "resource.management", qos: .utility)
    
    func registerTempFile(_ path: String) {
        resourceQueue.sync {
            _ = tempFiles.insert(path)
        }
    }
    
    func unregisterTempFile(_ path: String) {
        resourceQueue.sync {
            _ = tempFiles.remove(path)
        }
    }
    
    func registerFileHandle(_ handle: FileHandle) {
        resourceQueue.sync {
            _ = fileHandles.insert(ObjectIdentifier(handle))
        }
    }
    
    func unregisterFileHandle(_ handle: FileHandle) {
        resourceQueue.sync {
            _ = fileHandles.remove(ObjectIdentifier(handle))
        }
    }
    
    func cleanupAllResources() {
        resourceQueue.sync {
            // Clean up temporary files
            for tempFile in tempFiles {
                do {
                    if FileManager.default.fileExists(atPath: tempFile) {
                        try FileManager.default.removeItem(atPath: tempFile)
                    }
                } catch {
                    // Ignore cleanup errors
                }
            }
            tempFiles.removeAll()
            
            // Clear file handle tracking
            fileHandles.removeAll()
        }
    }
    
    func createSecureTempFile(prefix: String = "pdf22png", suffix: String = ".tmp") -> String? {
        let tempDir = NSTemporaryDirectory()
        let tempFileName = "\(prefix)_\(UUID().uuidString)\(suffix)"
        let tempPath = (tempDir as NSString).appendingPathComponent(tempFileName)
        
        // Create the file with secure permissions (600)
        let success = FileManager.default.createFile(atPath: tempPath, contents: nil, attributes: [
            .posixPermissions: 0o600
        ])
        
        if success {
            registerTempFile(tempPath)
            return tempPath
        }
        
        return nil
    }
}
</file>

<file path="Core/SignalHandler.swift">
import Foundation

// MARK: - Enhanced Signal Handling

class SignalHandler {
    static let shared = SignalHandler()
    private init() {}
    
    private var shouldTerminate = false
    private var cleanupHandlers: [() -> Void] = []
    private let signalQueue = DispatchQueue(label: "signal.handling", qos: .utility)
    
    var isTerminated: Bool {
        return shouldTerminate
    }
    
    func installSignalHandlers() {
        // Handle SIGINT (Ctrl+C)
        signal(SIGINT) { _ in
            SignalHandler.shared.handleGracefulShutdown(signal: "SIGINT")
        }
        
        // Handle SIGTERM (termination request)
        signal(SIGTERM) { _ in
            SignalHandler.shared.handleGracefulShutdown(signal: "SIGTERM")
        }
        
        // Handle SIGHUP (hangup)
        signal(SIGHUP) { _ in
            SignalHandler.shared.handleGracefulShutdown(signal: "SIGHUP")
        }
    }
    
    private func handleGracefulShutdown(signal: String) {
        shouldTerminate = true
        
        fputs("\n📡 Received \(signal), initiating graceful shutdown...\n", stderr)
        fflush(stderr)
        
        // Perform cleanup on a separate queue to avoid deadlocks
        signalQueue.async {
            self.performCleanup()
            
            // Give a brief moment for current operations to finish
            usleep(100_000) // 100ms
            
            fputs("✅ Cleanup complete. Exiting.\n", stderr)
            fflush(stderr)
            exit(1)
        }
    }
    
    private func performCleanup() {
        // Execute registered cleanup handlers
        for handler in cleanupHandlers {
            handler()
        }
        cleanupHandlers.removeAll()
        
        // Clean up resources
        ResourceManager.shared.cleanupAllResources()
    }
    
    func registerCleanupHandler(_ handler: @escaping () -> Void) {
        cleanupHandlers.append(handler)
    }
    
    func checkInterruption() throws {
        if shouldTerminate {
            throw PDF22PNGError.signalInterruption
        }
    }
}
</file>

<file path="Models/Errors.swift">
import Foundation

// MARK: - Error Types

enum PDF22PNGError: Int, Error, LocalizedError {
    case success = 0
    case generalError = 1
    case invalidArgs = 2
    case fileNotFound = 3
    case fileRead = 4
    case fileWrite = 5
    case noInput = 6
    case invalidPDF = 7
    case encryptedPDF = 8
    case emptyPDF = 9
    case pageNotFound = 10
    case renderFailed = 11
    case memory = 12
    case outputDir = 13
    case invalidScale = 14
    case batchFailed = 15
    case signalInterruption = 16
    
    var errorDescription: String? {
        switch self {
        case .success: return "Success"
        case .generalError: return "General error occurred"
        case .invalidArgs: return "Invalid command line arguments"
        case .fileNotFound: return "Input file not found"
        case .fileRead: return "Failed to read input file"
        case .fileWrite: return "Failed to write output file"
        case .noInput: return "No input data received"
        case .invalidPDF: return "Invalid PDF document"
        case .encryptedPDF: return "PDF document is encrypted"
        case .emptyPDF: return "PDF document has no pages"
        case .pageNotFound: return "Requested page does not exist"
        case .renderFailed: return "Failed to render PDF page"
        case .memory: return "Memory allocation failed"
        case .outputDir: return "Failed to create output directory"
        case .invalidScale: return "Invalid scale specification"
        case .batchFailed: return "Batch processing failed"
        case .signalInterruption: return "Operation interrupted by system signal"
        }
    }
    
    var recoverySuggestion: String? {
        switch self {
        case .invalidArgs:
            return "Check command syntax with --help flag. Verify all arguments are correct and use absolute paths."
        case .fileNotFound, .fileRead:
            return "Verify the file path is correct, the file exists, and you have read permissions."
        case .fileWrite:
            return "Check available disk space and write permissions to the output directory."
        case .invalidScale:
            return "Use valid formats: 150%, 2.0, 800x600, or 300dpi."
        case .pageNotFound:
            return "PDF pages start at 1. Use --verbose to see total page count."
        case .memory:
            return "Close other applications, use smaller scale factor, or process fewer pages at once."
        case .encryptedPDF:
            return "Remove password protection using Preview or qpdf command-line tool."
        default:
            return "Run with --verbose flag for detailed information. Check --help for usage examples."
        }
    }
}

struct ErrorReporter {
    static func reportError(_ error: PDF22PNGError, context: String? = nil) {
        print("❌ Error: \(error.errorDescription ?? "Unknown error")")
        
        if let ctx = context {
            print("📍 Context: \(ctx)")
        }
        
        if let suggestion = error.recoverySuggestion {
            print("\n💡 Help: \(suggestion)")
        }
        
        // Provide specific troubleshooting based on error type
        switch error {
        case .invalidArgs:
            print("\n💡 Input Validation Help:")
            print("   • Check command syntax with --help flag")
            print("   • Verify all arguments are correct")
            print("   • Use absolute paths to avoid confusion")
            
        case .fileNotFound:
            print("\n💡 File Access Help:")
            print("   • Verify the file path is correct and the file exists")
            print("   • Use absolute paths to avoid confusion")
            print("   • Check file permissions with 'ls -la'")
            
        case .fileRead:
            print("\n💡 File Access Help:")
            print("   • Check file permissions with 'ls -la'")
            print("   • Ensure you have read access to the file")
            print("   • Verify file is not corrupted")
            
        case .fileWrite:
            print("\n💡 File Write Help:")
            print("   • Check available disk space with 'df -h'")
            print("   • Verify write permissions to output directory")
            print("   • Try a different output location")
            
        case .invalidScale:
            print("\n💡 Scale Format Help:")
            print("   • Valid formats: 150%, 2.0, 800x600, 300dpi")
            print("   • Percentage: append % (e.g., 150%)")
            print("   • Factor: decimal number (e.g., 1.5)")
            print("   • Dimensions: WIDTHxHEIGHT (e.g., 1024x768)")
            
        case .pageNotFound:
            print("\n💡 Page Range Help:")
            print("   • PDF pages start at 1, not 0")
            print("   • Use --verbose to see total page count")
            print("   • Valid formats: 5 (single), 1-10 (range)")
            
        case .memory:
            print("\n💡 Memory Help:")
            print("   • Close other applications to free RAM")
            print("   • Use smaller scale factor: --scale 50%")
            print("   • Process fewer pages at once")
            
        case .encryptedPDF:
            print("\n💡 Encrypted PDF Help:")
            print("   • Remove password protection:")
            print("     - In Preview: File → Export As → PDF (uncheck Encrypt)")
            print("     - Command line: qpdf --decrypt --password=PASSWORD input.pdf output.pdf")
            
        default:
            print("\n💡 General Help:")
            print("   • Run with --verbose flag for detailed information")
            print("   • Check --help for usage examples")
            print("   • Try with a simpler PDF first")
        }
    }
}
</file>

<file path="Models/ProcessingOptions.swift">
import Foundation

// MARK: - Processing Options

struct ProcessingOptions {
    var inputFile: String?
    var outputFile: String?
    var page: String = "1"
    var allPages: Bool = false
    var resolution: String?
    var scale: String = "100%"
    var transparent: Bool = false
    var quality: Int = 6
    var outputPath: String?
    var directory: String?
    var verbose: Bool = false
    var includeText: Bool = false
    var namingPattern: String?
    var dryRun: Bool = false
    var forceOverwrite: Bool = false
    var showHelp: Bool = false
    var showVersion: Bool = false
    
    // Computed properties
    var effectiveScale: String {
        return resolution ?? scale
    }
    
    var effectiveOutputDirectory: String {
        return directory ?? "."
    }
    
    var isBatchMode: Bool {
        return allPages
    }
    
    var isStdoutMode: Bool {
        return outputPath == "-" || outputFile == "-"
    }
    
    var isStdinMode: Bool {
        return inputFile == "-" || inputFile == nil
    }
}
</file>

<file path="Models/Results.swift">
import Foundation

// MARK: - Result Types

struct ProcessingResults {
    let totalPages: Int
    let successfulPages: Int
    let failedPages: Int
    let interrupted: Bool
    let processingTime: TimeInterval
    let outputFiles: [String]
    
    var successRate: Double {
        guard totalPages > 0 else { return 0.0 }
        return Double(successfulPages) / Double(totalPages)
    }
    
    var pagesPerSecond: Double {
        guard processingTime > 0 else { return 0.0 }
        return Double(successfulPages) / processingTime
    }
    
    var isSuccessful: Bool {
        return failedPages == 0 && !interrupted
    }
}

struct PageResult {
    let pageNumber: Int
    let success: Bool
    let outputFile: String?
    let processingTime: TimeInterval
    let errorMessage: String?
    
    init(pageNumber: Int, success: Bool, outputFile: String? = nil, processingTime: TimeInterval = 0, error: Error? = nil) {
        self.pageNumber = pageNumber
        self.success = success
        self.outputFile = outputFile
        self.processingTime = processingTime
        self.errorMessage = error?.localizedDescription
    }
}

struct BatchResult {
    let totalPages: Int
    let successfulPages: Int
    let failedPages: Int
    let interrupted: Bool
    let processingTime: TimeInterval
    let pageResults: [PageResult]
    
    var processingResults: ProcessingResults {
        let outputFiles = pageResults.compactMap { $0.outputFile }
        return ProcessingResults(
            totalPages: totalPages,
            successfulPages: successfulPages,
            failedPages: failedPages,
            interrupted: interrupted,
            processingTime: processingTime,
            outputFiles: outputFiles
        )
    }
    
    init(totalPages: Int, successfulPages: Int, failedPages: Int, interrupted: Bool, processingTime: TimeInterval = 0, pageResults: [PageResult] = []) {
        self.totalPages = totalPages
        self.successfulPages = successfulPages
        self.failedPages = failedPages
        self.interrupted = interrupted
        self.processingTime = processingTime
        self.pageResults = pageResults
    }
}
</file>

<file path="Models/ScaleSpecification.swift">
import Foundation
import CoreGraphics

// MARK: - Scale Specification

enum ScaleSpecification {
    case percentage(CGFloat)
    case factor(CGFloat)
    case resolution(CGFloat)  // DPI
    case width(CGFloat)
    case height(CGFloat)
    case fit(width: CGFloat, height: CGFloat)
}

struct ScaleParser {
    static func parseScaleSpecification(_ scaleStr: String) -> ScaleSpecification? {
        let trimmed = scaleStr.trimmingCharacters(in: .whitespaces)
        
        if trimmed.hasSuffix("%") {
            let percentStr = String(trimmed.dropLast())
            guard let percent = Double(percentStr), percent > 0 else { return nil }
            return .percentage(CGFloat(percent))
        }
        
        if trimmed.hasSuffix("dpi") {
            let dpiStr = String(trimmed.dropLast(3))
            guard let dpi = Double(dpiStr), dpi > 0 else { return nil }
            return .resolution(CGFloat(dpi))
        }
        
        if trimmed.contains("x") {
            let parts = trimmed.components(separatedBy: "x")
            guard parts.count == 2 else { return nil }
            
            let widthStr = parts[0]
            let heightStr = parts[1]
            
            if !widthStr.isEmpty && !heightStr.isEmpty {
                guard let width = Double(widthStr), width > 0,
                      let height = Double(heightStr), height > 0 else { return nil }
                return .fit(width: CGFloat(width), height: CGFloat(height))
            } else if !widthStr.isEmpty {
                guard let width = Double(widthStr), width > 0 else { return nil }
                return .width(CGFloat(width))
            } else if !heightStr.isEmpty {
                guard let height = Double(heightStr), height > 0 else { return nil }
                return .height(CGFloat(height))
            }
            
            return nil
        }
        
        guard let factor = Double(trimmed), factor > 0 else { return nil }
        return .factor(CGFloat(factor))
    }
}
</file>

<file path="Utilities/InputValidator.swift">
import Foundation

// MARK: - Input Validation

class InputValidator {
    static let maxFileSize: UInt64 = 500 * 1024 * 1024 // 500MB
    static let maxPageNumber: Int = 10000
    static let maxTotalPages: Int = 5000
    static let maxPathLength: Int = 1024
    
    static func validateFilePath(_ path: String, allowCreate: Bool = false) throws -> String {
        // Check path length
        guard path.count <= maxPathLength else {
            throw PDF22PNGError.invalidArgs
        }
        
        // Prevent path traversal attacks
        let normalizedPath = (path as NSString).standardizingPath
        guard !normalizedPath.contains("../") && !normalizedPath.contains("..\\") else {
            throw PDF22PNGError.invalidArgs
        }
        
        // Check for null bytes and other dangerous characters
        guard !path.contains("\0") && !path.contains("\n") && !path.contains("\r") else {
            throw PDF22PNGError.invalidArgs
        }
        
        if !allowCreate {
            // For input files, check existence and size
            guard FileManager.default.fileExists(atPath: normalizedPath) else {
                throw PDF22PNGError.fileNotFound
            }
            
            do {
                let attributes = try FileManager.default.attributesOfItem(atPath: normalizedPath)
                if let fileSize = attributes[.size] as? UInt64, fileSize > maxFileSize {
                    throw PDF22PNGError.invalidArgs
                }
            } catch {
                throw PDF22PNGError.fileRead
            }
        }
        
        return normalizedPath
    }
    
    static func validateOutputDirectory(_ path: String) throws -> String {
        let normalizedPath = try validateFilePath(path, allowCreate: true)
        
        // Check if parent directory exists and is writable
        let parentDir = (normalizedPath as NSString).deletingLastPathComponent
        guard FileManager.default.fileExists(atPath: parentDir) else {
            throw PDF22PNGError.outputDir
        }
        
        guard FileManager.default.isWritableFile(atPath: parentDir) else {
            throw PDF22PNGError.fileWrite
        }
        
        return normalizedPath
    }
    
    static func validatePageNumber(_ page: Int, totalPages: Int) throws {
        guard page >= 1 && page <= totalPages else {
            throw PDF22PNGError.pageNotFound
        }
        
        guard page <= maxPageNumber else {
            throw PDF22PNGError.invalidArgs
        }
    }
    
    static func validatePageRange(_ range: String, totalPages: Int) throws {
        // Basic validation of page range format
        let validChars = CharacterSet(charactersIn: "0123456789,-")
        guard range.rangeOfCharacter(from: validChars.inverted) == nil else {
            throw PDF22PNGError.invalidArgs
        }
        
        // Check for reasonable range limits
        let components = range.components(separatedBy: CharacterSet(charactersIn: ",-"))
        for component in components {
            if let pageNum = Int(component.trimmingCharacters(in: .whitespaces)) {
                try validatePageNumber(pageNum, totalPages: totalPages)
            }
        }
    }
    
    static func validateScale(_ scale: String) throws {
        guard scale.count <= 20 else { // Reasonable limit for scale specification
            throw PDF22PNGError.invalidScale
        }
        
        // Check for basic format validity
        let validChars = CharacterSet(charactersIn: "0123456789.%xdpi")
        guard scale.rangeOfCharacter(from: validChars.inverted) == nil else {
            throw PDF22PNGError.invalidScale
        }
    }
    
    static func validateQuality(_ quality: Int) throws {
        guard quality >= 0 && quality <= 9 else {
            throw PDF22PNGError.invalidArgs
        }
    }
    
    static func validateNamingPattern(_ pattern: String) throws {
        guard pattern.count <= 200 else { // Reasonable pattern length
            throw PDF22PNGError.invalidArgs
        }
        
        // Check for potentially dangerous pattern elements
        guard !pattern.contains("../") && !pattern.contains("..\\") && !pattern.contains("\0") else {
            throw PDF22PNGError.invalidArgs
        }
    }
}
</file>

<file path="Utilities/ProgressReporter.swift">
import Foundation

// MARK: - Progress Reporter

class ProgressReporter {
    private let totalPages: Int
    private var startTime: Date
    private var processedPages: Int = 0
    private var successfulPages: Int = 0
    private var failedPages: Int = 0
    private var lastReportTime: Date
    private let reportInterval: TimeInterval = 1.0 // Report at most once per second
    private let verbose: Bool
    
    init(totalPages: Int, verbose: Bool = false) {
        self.totalPages = totalPages
        self.verbose = verbose
        self.startTime = Date()
        self.lastReportTime = Date()
    }
    
    func reportPageStart(pageNumber: Int) {
        if verbose {
            print("Processing page \(pageNumber)/\(totalPages)...")
        }
    }
    
    func reportPageComplete(pageNumber: Int, success: Bool, outputFile: String? = nil) {
        processedPages += 1
        if success {
            successfulPages += 1
            if let outputFile = outputFile, !verbose {
                // For non-verbose mode, show successful outputs
                print("✓ Page \(pageNumber) → \(outputFile)")
            }
        } else {
            failedPages += 1
            print("✗ Page \(pageNumber) failed")
        }
        
        // Report progress if enough time has passed or we're at a milestone
        let now = Date()
        let shouldReportTime = now.timeIntervalSince(lastReportTime) >= reportInterval
        let shouldReportMilestone = processedPages % 10 == 0 || processedPages == totalPages
        
        if shouldReportTime || shouldReportMilestone {
            reportProgress()
            lastReportTime = now
        }
    }
    
    func reportChunkStart(chunkNumber: Int, totalChunks: Int, pagesInChunk: Int) {
        if verbose {
            print("\n📦 Processing chunk \(chunkNumber)/\(totalChunks) (\(pagesInChunk) pages)")
        }
    }
    
    private func reportProgress() {
        let percentage = (processedPages * 100) / totalPages
        let elapsed = Date().timeIntervalSince(startTime)
        let pagesPerSecond = elapsed > 0 ? Double(processedPages) / elapsed : 0
        let estimatedTotal = pagesPerSecond > 0 ? Double(totalPages) / pagesPerSecond : 0
        let estimatedRemaining = max(0, estimatedTotal - elapsed)
        
        var progressBar = "["
        let barWidth = 30
        let filledWidth = (barWidth * processedPages) / totalPages
        progressBar += String(repeating: "■", count: filledWidth)
        progressBar += String(repeating: "□", count: barWidth - filledWidth)
        progressBar += "]"
        
        print("\n📊 Progress: \(progressBar) \(percentage)%")
        print("   Processed: \(processedPages)/\(totalPages) pages (✓ \(successfulPages), ✗ \(failedPages))")
        
        if pagesPerSecond > 0 {
            print("   Speed: \(String(format: "%.1f", pagesPerSecond)) pages/sec")
            print("   Time: \(formatDuration(elapsed)) elapsed, ~\(formatDuration(estimatedRemaining)) remaining")
        }
        
        // Memory status in verbose mode
        if verbose {
            let memInfo = MemoryManager.shared.getSystemMemoryInfo()
            let usedGB = Double(memInfo.used) / (1024 * 1024 * 1024)
            let availableGB = Double(memInfo.available) / (1024 * 1024 * 1024)
            print("   Memory: \(String(format: "%.1f", usedGB))GB used, \(String(format: "%.1f", availableGB))GB available")
        }
    }
    
    func reportBatchComplete() {
        let elapsed = Date().timeIntervalSince(startTime)
        let pagesPerSecond = elapsed > 0 ? Double(processedPages) / elapsed : 0
        
        print("\n✅ Batch processing complete!")
        print("   Total: \(processedPages) pages processed in \(formatDuration(elapsed))")
        print("   Results: ✓ \(successfulPages) successful, ✗ \(failedPages) failed")
        if pagesPerSecond > 0 {
            print("   Average speed: \(String(format: "%.1f", pagesPerSecond)) pages/sec")
        }
    }
    
    func reportInterrupted() {
        print("\n⚠️  Processing interrupted!")
        print("   Completed: \(processedPages)/\(totalPages) pages")
        print("   Results: ✓ \(successfulPages) successful, ✗ \(failedPages) failed")
    }
    
    private func formatDuration(_ seconds: TimeInterval) -> String {
        let minutes = Int(seconds) / 60
        let secs = Int(seconds) % 60
        if minutes > 0 {
            return "\(minutes)m \(secs)s"
        } else {
            return "\(secs)s"
        }
    }
    
    // Progress info for external consumption
    func getCurrentProgress() -> ProgressInfo {
        let elapsed = Date().timeIntervalSince(startTime)
        let pagesPerSecond = elapsed > 0 ? Double(processedPages) / elapsed : 0
        let estimatedTotal = pagesPerSecond > 0 ? Double(totalPages) / pagesPerSecond : 0
        let estimatedRemaining = max(0, estimatedTotal - elapsed)
        
        return ProgressInfo(
            completed: processedPages,
            total: totalPages,
            speed: pagesPerSecond > 0 ? pagesPerSecond : nil,
            estimatedTimeRemaining: estimatedRemaining > 0 ? estimatedRemaining : nil,
            currentOperation: nil
        )
    }
}
</file>

<file path="main.swift">
import Foundation
import CoreGraphics
import PDFKit
import Dispatch

// MARK: - Main Entry Point

// Helper function for logging is defined in MemoryManager.swift

// Global references for signal handling compatibility
var shouldTerminate: Bool { return SignalHandler.shared.isTerminated }
func installSignalHandlers() { SignalHandler.shared.installSignalHandlers() }
func registerCleanupHandler(_ handler: @escaping () -> Void) { SignalHandler.shared.registerCleanupHandler(handler) }
func checkInterruption() throws { try SignalHandler.shared.checkInterruption() }
func performCleanup() { ResourceManager.shared.cleanupAllResources() }

func main() async -> Int32 {
    let options = ArgumentParser.parseArguments()
    
    if options.showHelp {
        OutputFormatter.printHelp()
        return 0
    }
    
    if options.showVersion {
        OutputFormatter.printVersion()
        return 0
    }
    
    // Install signal handlers for graceful shutdown
    installSignalHandlers()
    
    guard let inputFile = options.inputFile else {
        print("Error: Input PDF file required")
        print("Use --help for usage information")
        return 2
    }
    
    // Validate input arguments
    do {
        try ArgumentParser.validateArguments(options)
        
        // Additional validation with InputValidator
        try InputValidator.validateQuality(options.quality)
        try InputValidator.validateScale(options.effectiveScale)
        
        if inputFile != "-" {
            _ = try InputValidator.validateFilePath(inputFile, allowCreate: false)
        }
        
        if let outputPath = options.outputPath, outputPath != "-" {
            _ = try InputValidator.validateFilePath(outputPath, allowCreate: true)
        }
        
        if let outputFile = options.outputFile, outputFile != "-" {
            _ = try InputValidator.validateFilePath(outputFile, allowCreate: true)
        }
        
        if let directory = options.directory {
            _ = try InputValidator.validateOutputDirectory(directory)
        }
        
        if let pattern = options.namingPattern {
            try InputValidator.validateNamingPattern(pattern)
        }
        
    } catch let error as PDF22PNGError {
        ErrorReporter.reportError(error, context: "Input validation failed")
        return Int32(error.rawValue)
    } catch {
        print("Error: Input validation failed - \(error.localizedDescription)")
        return 2
    }
    
    logMessage(options.verbose, "Starting pdf22png processing")
    
    // Check initial memory status
    MemoryManager.shared.logMemoryStatus(verbose: options.verbose)
    
    // Register cleanup handler for this session
    registerCleanupHandler {
        logMessage(options.verbose, "Cleaning up resources on exit")
    }
    
    // Load PDF document
    guard let pdfData = PDFProcessor.shared.readPDFData(inputFile, verbose: options.verbose) else {
        print("Error: Failed to read PDF data")
        return 4
    }
    
    guard let pdfDocument = PDFProcessor.shared.createPDFDocument(from: pdfData) else {
        print("Error: Invalid PDF document")
        return 7
    }
    
    if pdfDocument.isEncrypted {
        print("Error: PDF document is encrypted")
        return 8
    }
    
    let pageCount = PDFProcessor.shared.getPageCount(pdfDocument)
    if pageCount == 0 {
        print("Error: PDF document has no pages")
        return 9
    }
    
    // Validate PDF complexity limits
    guard pageCount <= InputValidator.maxTotalPages else {
        print("Error: PDF has too many pages (\(pageCount)). Maximum allowed: \(InputValidator.maxTotalPages)")
        return Int32(PDF22PNGError.invalidArgs.rawValue)
    }
    
    logMessage(options.verbose, "PDF loaded: \(pageCount) pages")
    
    // Validate page ranges now that we know the total count
    if !options.isBatchMode {
        do {
            if let pageNum = Int(options.page) {
                try InputValidator.validatePageNumber(pageNum, totalPages: pageCount)
            } else {
                try InputValidator.validatePageRange(options.page, totalPages: pageCount)
            }
        } catch let error as PDF22PNGError {
            ErrorReporter.reportError(error, context: "Page validation failed")
            return Int32(error.rawValue)
        } catch {
            print("Error: Page validation failed - \(error.localizedDescription)")
            return 10
        }
    }
    
    // Process PDF
    let success: Bool
    do {
        if options.isBatchMode {
            success = try await processBatchMode(options: options, pdfDocument: pdfDocument)
        } else {
            success = try processSinglePage(options: options, pdfDocument: pdfDocument)
        }
    } catch let error as PDF22PNGError {
        ErrorReporter.reportError(error, context: "Processing failed")
        return Int32(error.rawValue)
    } catch {
        print("Error: Processing failed - \(error.localizedDescription)")
        return 1
    }
    
    // Final cleanup
    performCleanup()
    
    return success ? 0 : 1
}

// MARK: - Processing Functions

func processSinglePage(options: ProcessingOptions, pdfDocument: PDFDocument) throws -> Bool {
    let pageNumber = Int(options.page) ?? 1
    
    try checkInterruption()
    
    logMessage(options.verbose, "Processing single page: \(pageNumber)")
    
    guard let pdfPage = PDFProcessor.shared.extractPage(pdfDocument, pageNumber: pageNumber) else {
        throw PDF22PNGError.pageNotFound
    }
    
    guard let scaleSpec = ScaleParser.parseScaleSpecification(options.effectiveScale) else {
        throw PDF22PNGError.invalidScale
    }
    
    let pageRect = pdfPage.bounds(for: .mediaBox)
    let scaleFactor = ImageRenderer.shared.calculateScaleFactor(spec: scaleSpec, pageRect: pageRect)
    
    logMessage(options.verbose, "Calculated scale factor: \(scaleFactor)")
    
    // Check memory requirements
    let memoryRequired = MemoryManager.shared.estimateMemoryRequirement(
        pageRect: pageRect, 
        scaleFactor: scaleFactor, 
        transparentBackground: options.transparent
    )
    
    if !MemoryManager.shared.canAllocateMemory(memoryRequired, verbose: options.verbose) {
        print("Warning: Insufficient memory for processing this page at current scale.")
    }
    
    try MemoryManager.shared.checkMemoryPressureDuringBatch(verbose: options.verbose)
    
    let renderOptions = ImageRenderer.RenderOptions(
        scaleFactor: scaleFactor,
        transparentBackground: options.transparent,
        quality: options.quality,
        verbose: options.verbose,
        dryRun: options.dryRun,
        forceOverwrite: options.forceOverwrite
    )
    
    guard let image = ImageRenderer.shared.renderPageToImage(page: pdfPage, options: renderOptions) else {
        throw PDF22PNGError.renderFailed
    }
    
    try checkInterruption()
    
    if options.isStdoutMode {
        if options.dryRun {
            print("[DRY-RUN] Would write \(image.width)x\(image.height) PNG to stdout")
            return true
        } else {
            return ImageRenderer.shared.writeImageToStdout(image: image, options: renderOptions)
        }
    } else if let outputPath = options.outputPath ?? options.outputFile {
        return ImageRenderer.shared.writeImageToFile(image: image, path: outputPath, options: renderOptions)
    } else {
        throw PDF22PNGError.invalidArgs
    }
}

func processBatchMode(options: ProcessingOptions, pdfDocument: PDFDocument) async throws -> Bool {
    let totalPages = PDFProcessor.shared.getPageCount(pdfDocument)
    let outputDir = options.effectiveOutputDirectory
    
    logMessage(options.verbose, "Processing in batch mode. Output directory: \(outputDir)")
    
    let inputBasename = (options.inputFile != nil && options.inputFile != "-") ? 
        URL(fileURLWithPath: options.inputFile!).deletingPathExtension().lastPathComponent : "output"
    let prefix = options.outputPath ?? inputBasename
    
    guard let scaleSpec = ScaleParser.parseScaleSpecification(options.effectiveScale) else {
        throw PDF22PNGError.invalidScale
    }
    
    guard let firstPage = PDFProcessor.shared.extractPage(pdfDocument, pageNumber: 1) else {
        throw PDF22PNGError.renderFailed
    }
    
    let pageRect = firstPage.bounds(for: .mediaBox)
    let scaleFactor = ImageRenderer.shared.calculateScaleFactor(spec: scaleSpec, pageRect: pageRect)
    
    let batchOptions = BatchProcessor.BatchOptions(
        totalPages: totalPages,
        outputDirectory: outputDir,
        prefix: prefix,
        scaleFactor: scaleFactor,
        transparent: options.transparent,
        quality: options.quality,
        verbose: options.verbose,
        dryRun: options.dryRun,
        forceOverwrite: options.forceOverwrite
    )
    
    let result = try await BatchProcessor.shared.processBatch(document: pdfDocument, options: batchOptions)
    return result.successfulPages > 0
}

// Entry point
let semaphore = DispatchSemaphore(value: 0)
var exitCode: Int32 = 0

Task {
    exitCode = await main()
    semaphore.signal()
}

semaphore.wait()
exit(exitCode)
</file>

<file path="Makefile">
PRODUCT_NAME = pdf22png
SWIFT = swiftc
BUILDDIR = build
SWIFT_FILES = $(shell find . -name "*.swift" | grep -v test-framework.swift)

.PHONY: all build clean test install format docs help

all: build

build:
	@echo "Building modular Swift version..."
	@mkdir -p $(BUILDDIR)
	@$(SWIFT) -O -o $(BUILDDIR)/$(PRODUCT_NAME) $(SWIFT_FILES)
	@echo "✅ Modular Swift build complete!"

# Try SPM build first, fallback to swiftc if SPM fails
build-spm:
	@echo "Attempting Swift Package Manager build..."
	@swift build -c release 2>/dev/null || $(MAKE) build
	@echo "Build complete!"

clean:
	@echo "Cleaning build artifacts..."
	@rm -rf $(BUILDDIR) .build $(PRODUCT_NAME)
	@echo "✅ Clean complete!"

test: build
	@echo "Testing modular Swift implementation..."
	@../Tests/test-framework.swift
	@echo "✅ Tests complete!"

install: build
	@echo "Installing pdf22png..."
	@cp $(BUILDDIR)/$(PRODUCT_NAME) /usr/local/bin/
	@echo "✅ Installed to /usr/local/bin/$(PRODUCT_NAME)"

format:
	@if command -v swift-format >/dev/null 2>&1; then \
		echo "Formatting Swift code..."; \
		swift-format format --recursive . --in-place; \
		echo "✅ Formatting complete!"; \
	else \
		echo "⚠️  swift-format not found. Install with: brew install swift-format"; \
	fi

docs:
	@if command -v swift >/dev/null 2>&1; then \
		echo "Generating documentation..."; \
		swift package generate-documentation 2>/dev/null || echo "⚠️  Documentation generation requires SPM structure"; \
	else \
		echo "⚠️  Swift not found in PATH"; \
	fi

help:
	@echo "pdf22png Makefile Commands:"
	@echo "  build      - Build the application with all modules"
	@echo "  build-spm  - Build with Swift Package Manager (fallback to swiftc)"
	@echo "  clean      - Remove build artifacts"
	@echo "  test       - Run tests"
	@echo "  install    - Install to /usr/local/bin"
	@echo "  format     - Format Swift code (requires swift-format)"
	@echo "  docs       - Generate documentation (requires SPM)"
	@echo "  help       - Show this help message"
</file>

</files>
</file>

<file path="src/main.swift">
import Foundation
import CoreGraphics
import PDFKit
import Dispatch

// MARK: - Main Entry Point

// Helper function for logging is defined in MemoryManager.swift

// Global references for signal handling compatibility
var shouldTerminate: Bool { return SignalHandler.shared.isTerminated }
func installSignalHandlers() { SignalHandler.shared.installSignalHandlers() }
func registerCleanupHandler(_ handler: @escaping () -> Void) { SignalHandler.shared.registerCleanupHandler(handler) }
func checkInterruption() throws { try SignalHandler.shared.checkInterruption() }
func performCleanup() { ResourceManager.shared.cleanupAllResources() }

func main() async -> Int32 {
    let options = ArgumentParser.parseArguments()
    
    if options.showHelp {
        OutputFormatter.printHelp()
        return 0
    }
    
    if options.showVersion {
        OutputFormatter.printVersion()
        return 0
    }
    
    // Install signal handlers for graceful shutdown
    installSignalHandlers()
    
    guard let inputFile = options.inputFile else {
        print("Error: Input PDF file required")
        print("Use --help for usage information")
        return 2
    }
    
    // Validate input arguments
    do {
        try ArgumentParser.validateArguments(options)
        
        // Additional validation with InputValidator
        try InputValidator.validateQuality(options.quality)
        try InputValidator.validateScale(options.effectiveScale)
        
        if inputFile != "-" {
            _ = try InputValidator.validateFilePath(inputFile, allowCreate: false)
        }
        
        if let outputPath = options.outputPath, outputPath != "-" {
            _ = try InputValidator.validateFilePath(outputPath, allowCreate: true)
        }
        
        if let outputFile = options.outputFile, outputFile != "-" {
            _ = try InputValidator.validateFilePath(outputFile, allowCreate: true)
        }
        
        if let directory = options.directory {
            _ = try InputValidator.validateOutputDirectory(directory)
        }
        
        if let pattern = options.namingPattern {
            try InputValidator.validateNamingPattern(pattern)
        }
        
    } catch let error as PDF22PNGError {
        ErrorReporter.reportError(error, context: "Input validation failed")
        return Int32(error.rawValue)
    } catch {
        print("Error: Input validation failed - \(error.localizedDescription)")
        return 2
    }
    
    logMessage(options.verbose, "Starting pdf22png processing")
    
    // Check initial memory status
    MemoryManager.shared.logMemoryStatus(verbose: options.verbose)
    
    // Register cleanup handler for this session
    registerCleanupHandler {
        logMessage(options.verbose, "Cleaning up resources on exit")
    }
    
    // Load PDF document
    guard let pdfData = PDFProcessor.shared.readPDFData(inputFile, verbose: options.verbose) else {
        print("Error: Failed to read PDF data")
        return 4
    }
    
    guard let pdfDocument = PDFProcessor.shared.createPDFDocument(from: pdfData) else {
        print("Error: Invalid PDF document")
        return 7
    }
    
    if pdfDocument.isEncrypted {
        print("Error: PDF document is encrypted")
        return 8
    }
    
    let pageCount = PDFProcessor.shared.getPageCount(pdfDocument)
    if pageCount == 0 {
        print("Error: PDF document has no pages")
        return 9
    }
    
    // Validate PDF complexity limits
    guard pageCount <= InputValidator.maxTotalPages else {
        print("Error: PDF has too many pages (\(pageCount)). Maximum allowed: \(InputValidator.maxTotalPages)")
        return Int32(PDF22PNGError.invalidArgs.rawValue)
    }
    
    logMessage(options.verbose, "PDF loaded: \(pageCount) pages")
    
    // Validate page ranges now that we know the total count
    if !options.isBatchMode {
        do {
            if let pageNum = Int(options.page) {
                try InputValidator.validatePageNumber(pageNum, totalPages: pageCount)
            } else {
                try InputValidator.validatePageRange(options.page, totalPages: pageCount)
            }
        } catch let error as PDF22PNGError {
            ErrorReporter.reportError(error, context: "Page validation failed")
            return Int32(error.rawValue)
        } catch {
            print("Error: Page validation failed - \(error.localizedDescription)")
            return 10
        }
    }
    
    // Process PDF
    let success: Bool
    do {
        if options.isBatchMode {
            success = try await processBatchMode(options: options, pdfDocument: pdfDocument)
        } else {
            success = try processSinglePage(options: options, pdfDocument: pdfDocument)
        }
    } catch let error as PDF22PNGError {
        ErrorReporter.reportError(error, context: "Processing failed")
        return Int32(error.rawValue)
    } catch {
        print("Error: Processing failed - \(error.localizedDescription)")
        return 1
    }
    
    // Final cleanup
    performCleanup()
    
    return success ? 0 : 1
}

// MARK: - Processing Functions

func processSinglePage(options: ProcessingOptions, pdfDocument: PDFDocument) throws -> Bool {
    let pageNumber = Int(options.page) ?? 1
    
    try checkInterruption()
    
    logMessage(options.verbose, "Processing single page: \(pageNumber)")
    
    guard let pdfPage = PDFProcessor.shared.extractPage(pdfDocument, pageNumber: pageNumber) else {
        throw PDF22PNGError.pageNotFound
    }
    
    guard let scaleSpec = ScaleParser.parseScaleSpecification(options.effectiveScale) else {
        throw PDF22PNGError.invalidScale
    }
    
    let pageRect = pdfPage.bounds(for: .mediaBox)
    let scaleFactor = ImageRenderer.shared.calculateScaleFactor(spec: scaleSpec, pageRect: pageRect)
    
    logMessage(options.verbose, "Calculated scale factor: \(scaleFactor)")
    
    // Check memory requirements
    let memoryRequired = MemoryManager.shared.estimateMemoryRequirement(
        pageRect: pageRect, 
        scaleFactor: scaleFactor, 
        transparentBackground: options.transparent
    )
    
    if !MemoryManager.shared.canAllocateMemory(memoryRequired, verbose: options.verbose) {
        print("Warning: Insufficient memory for processing this page at current scale.")
    }
    
    try MemoryManager.shared.checkMemoryPressureDuringBatch(verbose: options.verbose)
    
    let renderOptions = ImageRenderer.RenderOptions(
        scaleFactor: scaleFactor,
        transparentBackground: options.transparent,
        quality: options.quality,
        verbose: options.verbose,
        dryRun: options.dryRun,
        forceOverwrite: options.forceOverwrite
    )
    
    guard let image = ImageRenderer.shared.renderPageToImage(page: pdfPage, options: renderOptions) else {
        throw PDF22PNGError.renderFailed
    }
    
    try checkInterruption()
    
    if options.isStdoutMode {
        if options.dryRun {
            print("[DRY-RUN] Would write \(image.width)x\(image.height) PNG to stdout")
            return true
        } else {
            return ImageRenderer.shared.writeImageToStdout(image: image, options: renderOptions)
        }
    } else if let outputPath = options.outputPath ?? options.outputFile {
        return ImageRenderer.shared.writeImageToFile(image: image, path: outputPath, options: renderOptions)
    } else {
        throw PDF22PNGError.invalidArgs
    }
}

func processBatchMode(options: ProcessingOptions, pdfDocument: PDFDocument) async throws -> Bool {
    let totalPages = PDFProcessor.shared.getPageCount(pdfDocument)
    let outputDir = options.effectiveOutputDirectory
    
    logMessage(options.verbose, "Processing in batch mode. Output directory: \(outputDir)")
    
    let inputBasename = (options.inputFile != nil && options.inputFile != "-") ? 
        URL(fileURLWithPath: options.inputFile!).deletingPathExtension().lastPathComponent : "output"
    let prefix = options.outputPath ?? inputBasename
    
    guard let scaleSpec = ScaleParser.parseScaleSpecification(options.effectiveScale) else {
        throw PDF22PNGError.invalidScale
    }
    
    guard let firstPage = PDFProcessor.shared.extractPage(pdfDocument, pageNumber: 1) else {
        throw PDF22PNGError.renderFailed
    }
    
    let pageRect = firstPage.bounds(for: .mediaBox)
    let scaleFactor = ImageRenderer.shared.calculateScaleFactor(spec: scaleSpec, pageRect: pageRect)
    
    let batchOptions = BatchProcessor.BatchOptions(
        totalPages: totalPages,
        outputDirectory: outputDir,
        prefix: prefix,
        scaleFactor: scaleFactor,
        transparent: options.transparent,
        quality: options.quality,
        verbose: options.verbose,
        dryRun: options.dryRun,
        forceOverwrite: options.forceOverwrite
    )
    
    let result = try await BatchProcessor.shared.processBatch(document: pdfDocument, options: batchOptions)
    return result.successfulPages > 0
}

// Entry point
let semaphore = DispatchSemaphore(value: 0)
var exitCode: Int32 = 0

Task {
    exitCode = await main()
    semaphore.signal()
}

semaphore.wait()
exit(exitCode)
</file>

<file path="src/Makefile">
PRODUCT_NAME = pdf22png
SWIFT = swiftc
BUILDDIR = build
SWIFT_FILES = $(shell find . -name "*.swift" | grep -v test-framework.swift)

.PHONY: all build clean test install format docs help

all: build

build:
	@echo "Building modular Swift version..."
	@mkdir -p $(BUILDDIR)
	@$(SWIFT) -O -o $(BUILDDIR)/$(PRODUCT_NAME) $(SWIFT_FILES)
	@echo "✅ Modular Swift build complete!"

# Try SPM build first, fallback to swiftc if SPM fails
build-spm:
	@echo "Attempting Swift Package Manager build..."
	@swift build -c release 2>/dev/null || $(MAKE) build
	@echo "Build complete!"

clean:
	@echo "Cleaning build artifacts..."
	@rm -rf $(BUILDDIR) .build $(PRODUCT_NAME)
	@echo "✅ Clean complete!"

test: build
	@echo "Testing modular Swift implementation..."
	@../Tests/test-framework.swift
	@echo "✅ Tests complete!"

install: build
	@echo "Installing pdf22png..."
	@cp $(BUILDDIR)/$(PRODUCT_NAME) /usr/local/bin/
	@echo "✅ Installed to /usr/local/bin/$(PRODUCT_NAME)"

format:
	@if command -v swift-format >/dev/null 2>&1; then \
		echo "Formatting Swift code..."; \
		swift-format format --recursive . --in-place; \
		echo "✅ Formatting complete!"; \
	else \
		echo "⚠️  swift-format not found. Install with: brew install swift-format"; \
	fi

docs:
	@if command -v swift >/dev/null 2>&1; then \
		echo "Generating documentation..."; \
		swift package generate-documentation 2>/dev/null || echo "⚠️  Documentation generation requires SPM structure"; \
	else \
		echo "⚠️  Swift not found in PATH"; \
	fi

help:
	@echo "pdf22png Makefile Commands:"
	@echo "  build      - Build the application with all modules"
	@echo "  build-spm  - Build with Swift Package Manager (fallback to swiftc)"
	@echo "  clean      - Remove build artifacts"
	@echo "  test       - Run tests"
	@echo "  install    - Install to /usr/local/bin"
	@echo "  format     - Format Swift code (requires swift-format)"
	@echo "  docs       - Generate documentation (requires SPM)"
	@echo "  help       - Show this help message"
</file>

<file path=".gitignore">
# macOS
.DS_Store
.AppleDouble
.LSOverride
._*
.Spotlight-V100
.Trashes

# Xcode
*.xcworkspace
xcuserdata/
*.xcscmblueprint
*.xccheckout
DerivedData/
*.moved-aside
*.pbxuser
!default.pbxuser
*.mode1v3
!default.mode1v3
*.mode2v3
!default.mode2v3
*.perspectivev3
!default.perspectivev3

# Build products
build/
*.o
*.a
*.dylib
pdf22png
*.dSYM/

# CMake
CMakeCache.txt
CMakeFiles/
cmake_install.cmake
Makefile.cmake

# Testing
test-results/
coverage/
*.gcov
*.gcda
*.gcno

# IDEs
.vscode/
.idea/
*.swp
*.swo
*~
.cursorindexingignore

# Distribution
dist/
*.tar.gz
*.zip
*.dmg

# Documentation
docs/_build/
*.pdf
</file>

<file path="CLAUDE.md">
# pdf22png

A high-performance command-line tool for converting PDF documents to PNG images on macOS, leveraging native Core Graphics and Quartz frameworks for optimal quality and speed.

## Features

- **Single & Batch Conversion**: Convert individual pages or entire PDF documents
- **Flexible Scaling Options**: 
  - Resolution control (DPI)
  - Percentage scaling
  - Fixed dimensions (width/height fitting)
  - Scale factors
- **Advanced Options**:
  - Transparent background support
  - PNG compression quality control
  - Verbose logging for debugging
- **I/O Flexibility**:
  - Read from files or stdin
  - Write to files, stdout, or batch output directories
  - Customizable output naming patterns
- **Native Performance**: Built with Objective-C using macOS native frameworks
- **Universal Binary**: Supports both Intel and Apple Silicon Macs

## Installation

### Using Homebrew (Recommended)

```bash
brew tap twardoch/homebrew-pdf22png
brew install pdf22png
```

### Building from Source

Requirements:
- macOS 10.15 or later
- Xcode Command Line Tools

```bash
git clone https://github.com/twardoch/pdf22png.git
cd pdf22png
make
sudo make install
```

To build a universal binary for both Intel and Apple Silicon:

```bash
make universal
```

## Usage

### Basic Syntax

```bash
pdf22png [OPTIONS] <input.pdf> [output.png]
```

### Quick Examples

Convert first page of a PDF:
```bash
pdf22png input.pdf output.png
```

Convert a specific page:
```bash
pdf22png -p 5 document.pdf page5.png
```

Convert all pages to individual PNGs:
```bash
pdf22png -a document.pdf
# Creates: document-001.png, document-002.png, etc.
```

Convert at 300 DPI resolution:
```bash
pdf22png -r 300 input.pdf high-res.png
```

Scale to 50% size:
```bash
pdf22png -s 50% input.pdf half-size.png
```

### Options

| Option | Long Form | Description | Default |
|--------|-----------|-------------|---------|
| `-p <n>` | `--page` | Convert specific page number | 1 |
| `-a` | `--all` | Convert all pages | disabled |
| `-r <dpi>` | `--resolution` | Set output DPI (e.g., 300) | 144 |
| `-s <spec>` | `--scale` | Scale specification (see below) | 100% |
| `-t` | `--transparent` | Preserve transparency | disabled |
| `-q <0-9>` | `--quality` | PNG compression quality | 6 |
| `-o <path>` | `--output` | Output file/prefix or `-` for stdout | - |
| `-d <dir>` | `--directory` | Output directory for batch mode | . |
| `-v` | `--verbose` | Enable verbose logging | disabled |
| `-h` | `--help` | Show help message | - |

### Scale Specifications

The `-s/--scale` option accepts various formats:

- **Percentage**: `150%` (1.5x scale)
- **Factor**: `2.0` (2x scale)
- **Fixed width**: `800x` (800px wide, height auto)
- **Fixed height**: `x600` (600px high, width auto)
- **Fit within**: `800x600` (fit within 800x600 box)

### Advanced Examples

Convert with transparent background at 300 DPI:
```bash
pdf22png -t -r 300 input.pdf transparent-300dpi.png
```

Batch convert all pages to a specific directory:
```bash
pdf22png -d ./output_images -o myprefix document.pdf
# Creates: ./output_images/myprefix-001.png, etc.
```

Pipe operations:
```bash
# From stdin to stdout
cat document.pdf | pdf22png - - > output.png

# Process and pipe to ImageMagick
pdf22png -r 300 input.pdf - | convert - -resize 50% final.jpg
```

## Architecture

pdf22png is built using:
- **Objective-C** with ARC (Automatic Reference Counting)
- **Core Graphics** for PDF rendering
- **Quartz** framework for image processing
- **ImageIO** for PNG output
- Native macOS APIs for optimal performance

The codebase is organized into:
- `src/pdf22png.m` - Main program logic and argument parsing
- `src/utils.m` - Utility functions for scaling, rendering, and I/O
- `tests/` - XCTest-based unit tests

## Performance

pdf22png is optimized for performance:
- Parallel processing for batch conversions using Grand Central Dispatch
- Efficient memory management with autoreleasepool usage
- Native Core Graphics rendering for best quality
- Minimal dependencies (only macOS system frameworks)


# main-overview

## Development Guidelines

- Only modify code directly relevant to the specific request. Avoid changing unrelated functionality.
- Never replace code with placeholders like `# ... rest of the processing ...`. Always include complete code.
- Break problems into smaller steps. Think through each step separately before implementing.
- Always provide a complete PLAN with REASONING based on evidence from code and logs before making changes.
- Explain your OBSERVATIONS clearly, then provide REASONING to identify the exact issue. Add console logs when needed to gather more information.


pdf22png implements specialized PDF to PNG conversion logic leveraging macOS native frameworks. The core business functionality is organized around:

## Core Conversion Engine
The primary conversion logic resides in `src/pdf22png.m`, handling:
- PDF page rendering with customizable scaling
- Transparent background preservation 
- Quality-controlled PNG output generation
- Batch processing with parallel execution

## Scale Specification System
Located in `src/utils.m`, implements specialized scaling algorithms:
- Percentage-based scaling (e.g. "150%")
- Fixed dimension specifications (e.g. "800x600")
- DPI-based resolution control
- Aspect ratio preservation logic

## Output Management
Implements flexible output handling:
- Custom naming pattern generation for batch conversions
- Directory organization for multi-page outputs
- Stream-based processing for pipeline integration
- Transparent vs opaque background handling

## Platform Integration
Native integration with macOS frameworks:
- Core Graphics PDF parsing and rendering
- Quartz image processing pipeline
- Universal binary support for Intel/ARM
- System-level optimization for performance

## Processing Modes
Supports multiple operational modes:
- Single page conversion
- Full document batch processing
- Stream-based pipeline processing
- Interactive command-line interface

The business logic focuses on providing professional-grade PDF to PNG conversion with emphasis on flexibility, quality control, and integration capabilities for automated workflows.

—— When you’re done with a round of updates, update CHANGELOG.md with the changes, remove done things from TODO.md, identify new things that need to be done and add them to TODO.md. Then build the app or run ./release.sh and then continue updates.
</file>

<file path="Package.swift">
// swift-tools-version: 5.9
// The swift-tools-version declares the minimum version of Swift required to build this package.

import PackageDescription

let package = Package(
    name: "pdf22png",
    platforms: [
        .macOS(.v12)
    ],
    products: [
        .executable(
            name: "pdf22png",
            targets: ["pdf22png"]
        )
    ],
    targets: [
        .executableTarget(
            name: "pdf22png",
            dependencies: [],
            path: "src",
            exclude: [
                "test-framework.swift",
                "Makefile"
            ]
        ),
        .testTarget(
            name: "pdf22pngTests",
            dependencies: ["pdf22png"],
            path: "Tests"
        )
    ],
    swiftLanguageVersions: [.v5]
)
</file>

<file path=".github/workflows/release.yml">
name: Build and Release

on:
  push:
    tags:
      - 'v*'

jobs:
  build-and-release:
    runs-on: macos-latest
    
    strategy:
      matrix:
        include:
          - name: "macOS Universal"
            arch: "universal"
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: Setup Xcode
      uses: maxim-lobanov/setup-xcode@v1
      with:
        xcode-version: latest-stable
    
    - name: Get version from tag
      id: version
      run: |
        VERSION=${GITHUB_REF#refs/tags/v}
        echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
        echo "Building version $VERSION"
    
    - name: Build Universal Binary
      run: |
        make clean
        make universal
        
    - name: Run Tests
      run: |
        if [ -f "tests/test_pdf22png.m" ]; then
          make test
        fi
    
    - name: Create distribution directory
      run: |
        mkdir -p dist/pdf22png
        cp build/pdf22png dist/pdf22png/
        cp README.md dist/pdf22png/
        cp LICENSE dist/pdf22png/
        cp build.sh dist/pdf22png/
        chmod +x dist/pdf22png/build.sh
        
    - name: Create pkg installer
      run: |
        # Create component package
        pkgbuild --root dist/pdf22png \
                 --identifier com.twardoch.pdf22png \
                 --version ${{ steps.version.outputs.VERSION }} \
                 --install-location /usr/local/bin \
                 pdf22png-component.pkg
        
        # Create distribution XML
        cat > distribution.xml << EOF
        <?xml version="1.0" encoding="utf-8"?>
        <installer-gui-script minSpecVersion="2.0">
            <title>pdf22png ${{ steps.version.outputs.VERSION }}</title>
            <pkg-ref id="com.twardoch.pdf22png">
                <bundle-version/>
            </pkg-ref>
            <options customize="never" require-scripts="false" hostArchitectures="x86_64,arm64"/>
            <domains enable_localSystem="true"/>
            <choices-outline>
                <line choice="default">
                    <line choice="com.twardoch.pdf22png"/>
                </line>
            </choices-outline>
            <choice id="default"/>
            <choice id="com.twardoch.pdf22png" visible="false" customLocation="/">
                <pkg-ref id="com.twardoch.pdf22png"/>
            </choice>
            <pkg-ref id="com.twardoch.pdf22png" version="${{ steps.version.outputs.VERSION }}" onConclusion="none">pdf22png-component.pkg</pkg-ref>
        </installer-gui-script>
        EOF
        
        # Build final installer package
        productbuild --distribution distribution.xml \
                     --package-path . \
                     --version ${{ steps.version.outputs.VERSION }} \
                     pdf22png-${{ steps.version.outputs.VERSION }}-universal.pkg
    
    - name: Create DMG
      run: |
        mkdir -p dmg-contents
        cp build/pdf22png dmg-contents/
        cp README.md dmg-contents/
        cp LICENSE dmg-contents/
        cp build.sh dmg-contents/
        chmod +x dmg-contents/build.sh
        
        # Create a simple install script
        cat > dmg-contents/install.sh << 'EOF'
        #!/bin/bash
        echo "Installing pdf22png to /usr/local/bin..."
        sudo cp pdf22png /usr/local/bin/
        sudo chmod +x /usr/local/bin/pdf22png
        echo "Installation complete!"
        EOF
        chmod +x dmg-contents/install.sh
        
        # Create DMG
        hdiutil create -volname "pdf22png ${{ steps.version.outputs.VERSION }}" \
                       -srcfolder dmg-contents \
                       -ov -format UDZO \
                       pdf22png-${{ steps.version.outputs.VERSION }}-universal.dmg
    
    - name: Prepare binary for release
      run: |
        cp build/pdf22png pdf22png-${{ steps.version.outputs.VERSION }}-universal
    
    - name: Generate checksums
      run: |
        shasum -a 256 pdf22png-${{ steps.version.outputs.VERSION }}-universal.pkg > checksums.txt
        shasum -a 256 pdf22png-${{ steps.version.outputs.VERSION }}-universal.dmg >> checksums.txt
        shasum -a 256 pdf22png-${{ steps.version.outputs.VERSION }}-universal >> checksums.txt
    
    - name: Create Release
      uses: softprops/action-gh-release@v1
      with:
        tag_name: ${{ github.ref }}
        name: pdf22png v${{ steps.version.outputs.VERSION }}
        body: |
          # pdf22png v${{ steps.version.outputs.VERSION }}
          
          High-performance PDF to PNG converter for macOS.
          
          ## Installation
          
          ### Option 1: Homebrew
          ```bash
          brew tap twardoch/homebrew-pdf22png
          brew install pdf22png
          ```
          
          ### Option 2: Package Installer
          Download and run `pdf22png-${{ steps.version.outputs.VERSION }}-universal.pkg`
          
          ### Option 3: Manual Installation
          Download `pdf22png-${{ steps.version.outputs.VERSION }}-universal.dmg`, mount it, and run:
          ```bash
          sudo cp /Volumes/pdf22png*/pdf22png /usr/local/bin/
          ```
          
          ### Option 4: Build from Source
          Clone the repository and use the included build script:
          ```bash
          git clone https://github.com/twardoch/pdf22png.git
          cd pdf22png
          ./build.sh -u -i  # Build and install universal binary
          ```
          
          ## What's New
          See [CHANGELOG.md](https://github.com/twardoch/pdf22png/blob/main/CHANGELOG.md) for details.
          
          ## Checksums
          See `checksums.txt` for SHA-256 checksums of all artifacts.
        draft: false
        prerelease: false
        files: |
          pdf22png-${{ steps.version.outputs.VERSION }}-universal.pkg
          pdf22png-${{ steps.version.outputs.VERSION }}-universal.dmg
          pdf22png-${{ steps.version.outputs.VERSION }}-universal
          checksums.txt
    
    - name: Update Homebrew formula
      run: |
        echo "Homebrew formula update would typically happen here"
        echo "This usually involves updating the formula in the tap repository"
</file>

<file path="PLAN.md">
# PDF22PNG Advanced Streamlining Plan - Phase 4+

## Executive Summary

Phases 2-3 have been successfully completed, achieving a **dramatic transformation** from a complex multi-implementation project to a streamlined, modular Swift application. The codebase has been reduced from 124,900+ characters to 67,435 characters (46% reduction) while adding comprehensive testing infrastructure.

## Current Achievement Analysis

### ✅ **Completed Phases (Phases 1-3)**

**Phase 1: Implementation Consolidation** ✅ COMPLETE
- Archived 3 implementations to single Swift standalone
- Eliminated 30,270+ lines of legacy Objective-C code
- Simplified build system from 3 parallel systems to 1

**Phase 2: Complete Code Modularization** ✅ COMPLETE  
- Transformed 1,382-line monolithic main.swift to 264-line focused entry point
- Created 14 specialized modules in clean architecture
- 81% reduction in main.swift complexity

**Phase 3: Infrastructure Modernization** ✅ COMPLETE
- Eliminated main_old.swift (48,941 bytes - largest technical debt)
- Created Package.swift and modern build system
- Established comprehensive testing infrastructure (6 test suites)
- Achieved **46% total codebase reduction** (124,900 → 67,435 characters)

### 📊 **Current State Excellence**
- **16 total source files** (perfectly manageable)
- **67,435 characters** (down from 124,900+ - 46% reduction)
- **14,590 tokens** (highly optimized)
- **No security issues** detected
- **Well-balanced module distribution** (largest file only 13.7% of codebase)

## Phase 4: Production Excellence & Advanced Features

### 4.1 Complete Testing Infrastructure (Week 1)

**4.1.1 Finish Core Module Tests**
```swift
// Tests/CoreTests/BatchProcessorTests.swift - NEEDED
final class BatchProcessorTests: XCTestCase {
    func testBatchProcessingWithMemoryConstraints() async throws
    func testConcurrentPageProcessing() async throws  
    func testBatchResultValidation() async throws
    func testErrorHandlingInBatch() async throws
}

// Tests/CoreTests/ResourceManagerTests.swift - NEW
final class ResourceManagerTests: XCTestCase {
    func testTempFileManagement() throws
    func testResourceCleanup() throws
    func testSecureFileCreation() throws
}

// Tests/CoreTests/SignalHandlerTests.swift - NEW  
final class SignalHandlerTests: XCTestCase {
    func testGracefulShutdown() throws
    func testCleanupHandlerRegistration() throws
    func testInterruptionDetection() throws
}
```

**4.1.2 Complete CLI & Utilities Tests**
```swift
// Tests/CLITests/OutputFormatterTests.swift - NEEDED
final class OutputFormatterTests: XCTestCase {
    func testHelpFormatting() throws
    func testErrorFormatting() throws
    func testProgressFormatting() throws
}

// Tests/UtilitiesTests/ProgressReporterTests.swift - NEEDED  
final class ProgressReporterTests: XCTestCase {
    func testProgressTracking() throws
    func testBatchReporting() throws
    func testMemoryStatusReporting() throws
}
```

**4.1.3 Integration & Performance Tests**
```swift
// Tests/IntegrationTests/EndToEndTests.swift - NEW
final class EndToEndTests: XCTestCase {
    func testSinglePageConversion() async throws
    func testBatchConversion() async throws  
    func testMemoryConstrainedProcessing() async throws
    func testCLIArgumentHandling() throws
}

// Tests/PerformanceTests/BenchmarkTests.swift - NEW
final class BenchmarkTests: XCTestCase {
    func testConversionSpeed() throws
    func testMemoryUsage() throws
    func testStartupTime() throws
    func testConcurrentProcessing() async throws
}
```

### 4.2 Documentation Modernization (Week 2)

**4.2.1 API Documentation with DocC**
Add comprehensive documentation to all public APIs:
```swift
/// High-performance PDF to PNG conversion engine
/// 
/// `PDFProcessor` provides memory-efficient PDF processing with built-in
/// validation, error handling, and progress tracking.
/// 
/// ## Usage
/// 
/// ```swift
/// let processor = PDFProcessor.shared
/// guard let data = processor.readPDFData("document.pdf", verbose: true) else {
///     throw PDF22PNGError.fileRead
/// }
/// let document = processor.createPDFDocument(from: data)
/// ```
/// 
/// ## Memory Management
/// 
/// The processor automatically manages memory pressure and optimizes batch
/// operations based on available system resources.
public class PDFProcessor {
    /// Loads PDF data from file path or stdin with validation
    /// - Parameter path: File path or nil for stdin
    /// - Parameter verbose: Enable detailed logging
    /// - Returns: PDF data or nil if loading failed
    /// - Throws: `PDF22PNGError.fileRead` if file cannot be read
    public func readPDFData(_ path: String?, verbose: Bool) -> Data?
```

**4.2.2 Architecture Documentation**
```markdown
// docs/ARCHITECTURE.md
# PDF22PNG Architecture Guide

## System Overview

pdf22png follows a clean modular architecture optimized for performance and maintainability:

```
┌─────────────────────────────────────────────────────────┐
│                        main.swift                       │
│                    (Entry Point - 264 lines)           │
└─────────────────────┬───────────────────────────────────┘
                      │
    ┌─────────────────┼─────────────────┐
    │                 │                 │
┌───▼───┐        ┌────▼────┐       ┌────▼────┐
│  CLI  │        │  Core   │       │Utilities│
│   ┌───┤        │   ┌─────┤       │   ┌─────┤
│   │AP │        │   │PDF  │       │   │Prog │
│   │OF │        │   │IMG  │       │   │Inp  │
│   └───┤        │   │Batch│       │   └─────┤
└───────┘        │   │Mem  │       └─────────┘
                 │   │Res  │
                 │   │Sig  │
                 │   └─────┤
                 └─────────┘
                      │
                 ┌────▼────┐
                 │ Models  │
                 │   ┌─────┤
                 │   │Opts │
                 │   │Scale│
                 │   │Errs │
                 │   │Res  │
                 │   └─────┤
                 └─────────┘
```

## Module Responsibilities

### Core/ - Business Logic Engine
- **PDFProcessor**: PDF loading, validation, page extraction
- **ImageRenderer**: High-performance rendering with multiple strategies  
- **BatchProcessor**: Memory-aware batch processing with concurrency
- **MemoryManager**: Real-time memory monitoring and optimization
- **ResourceManager**: Secure temporary file and resource management
- **SignalHandler**: Graceful shutdown and cleanup coordination

### Models/ - Data Structures
- **ProcessingOptions**: Unified command-line options with computed properties
- **ScaleSpecification**: Type-safe scaling with enum-based validation
- **Errors**: Comprehensive error handling with contextual troubleshooting
- **Results**: Processing results and performance metrics

### CLI/ - User Interface
- **ArgumentParser**: Robust argument parsing with validation
- **OutputFormatter**: Professional formatting for help, errors, and progress

### Utilities/ - Support Systems  
- **ProgressReporter**: Real-time progress tracking with memory monitoring
- **InputValidator**: Security-focused input validation and sanitization

## Data Flow Architecture

1. **Input Processing**: CLI parses and validates arguments
2. **Resource Planning**: MemoryManager estimates requirements and optimizes batch sizes
3. **PDF Processing**: PDFProcessor loads and validates documents
4. **Rendering Pipeline**: ImageRenderer converts pages with optimal strategies
5. **Batch Coordination**: BatchProcessor manages concurrent operations
6. **Progress Tracking**: ProgressReporter provides real-time feedback
7. **Output Generation**: Results are written with proper error handling
8. **Cleanup**: ResourceManager and SignalHandler ensure clean shutdown

## Performance Strategy

### Memory Management
- **Adaptive Batch Sizing**: Dynamic adjustment based on available memory
- **Pressure Detection**: Real-time monitoring with automatic optimization
- **Resource Pooling**: Context reuse for improved efficiency
- **Cleanup Coordination**: Automatic resource management

### Concurrency Model
- **Swift Concurrency**: async/await for batch processing
- **Memory-Aware Limits**: Concurrency adjusted based on memory pressure
- **Graceful Degradation**: Automatic fallback under resource constraints
```

**4.2.3 Development Guide**
```markdown  
// docs/DEVELOPMENT.md
# Development Guide

## Quick Start

```bash
# Clone and build
git clone <repo>
cd pdf22png
make build

# Run tests
make test

# Install locally  
make install
```

## Project Structure

```
pdf22png/
├── src/                    # Source code
│   ├── main.swift         # Entry point (264 lines)
│   ├── Core/              # Business logic (6 modules)
│   ├── Models/            # Data structures (4 modules)  
│   ├── CLI/               # User interface (2 modules)
│   └── Utilities/         # Support systems (2 modules)
├── Tests/                 # Test suite
│   ├── CoreTests/         # Core module tests
│   ├── CLITests/          # CLI tests
│   ├── UtilitiesTests/    # Utilities tests
│   ├── IntegrationTests/  # End-to-end tests
│   └── PerformanceTests/  # Performance benchmarks
├── docs/                  # Documentation
└── Package.swift          # Swift Package Manager
```

## Building & Testing

### Standard Build
```bash
make build          # Build with swiftc
make build-spm      # Build with SPM (fallback to swiftc)
make clean          # Clean build artifacts
```

### Testing
```bash  
make test           # Run test suite
swift test          # SPM testing (if available)
```

### Code Quality
```bash
make format         # Format code with swift-format
make lint           # Lint with SwiftLint (when configured)
```

## Contributing

### Code Style
- Follow Swift API Design Guidelines
- Use descriptive variable and function names  
- Maximum 100 characters per line
- Document public APIs with DocC
- Write tests for new functionality

### Testing Requirements
- Unit tests for all public APIs
- Integration tests for CLI functionality
- Performance tests for processing operations
- 90%+ test coverage target

### Performance Considerations
- Memory-efficient algorithms for large PDFs
- Batch processing optimization
- Proper error handling and cleanup
- Graceful degradation under resource constraints
```

### 4.3 Advanced Performance Features (Week 3)

**4.3.1 Memory Pool Enhancement**
```swift
// Core/MemoryPool.swift - NEW ADVANCED FEATURE
actor MemoryPool {
    private var contextPools: [ContextSize: [CGContext]] = [:]
    private let maxPoolSize = 10
    private let maxMemoryUsage: UInt64 = 500 * 1024 * 1024 // 500MB
    private var currentMemoryUsage: UInt64 = 0
    private let creationTime: [ObjectIdentifier: Date] = [:]
    
    func getContext(size: ContextSize) async -> CGContext? {
        // Get reusable context from pool or create new one
        if let pool = contextPools[size], !pool.isEmpty {
            let context = pool.removeLast()
            return context
        }
        
        // Create new context if under memory limit
        guard currentMemoryUsage + size.memoryRequirement <= maxMemoryUsage else {
            await cleanupOldContexts()
            return nil
        }
        
        return createContext(size: size)
    }
    
    func returnContext(_ context: CGContext, size: ContextSize) async {
        guard contextPools[size]?.count ?? 0 < maxPoolSize else {
            // Pool is full, discard context
            return
        }
        
        contextPools[size, default: []].append(context)
        creationTime[ObjectIdentifier(context)] = Date()
    }
    
    private func cleanupOldContexts() async {
        let cutoffTime = Date().addingTimeInterval(-60) // 60 seconds
        
        for (size, pool) in contextPools {
            let validContexts = pool.filter { context in
                guard let creationTime = creationTime[ObjectIdentifier(context)] else { return false }
                return creationTime > cutoffTime
            }
            contextPools[size] = validContexts
        }
    }
}

struct ContextSize: Hashable {
    let width: Int
    let height: Int
    
    var memoryRequirement: UInt64 {
        return UInt64(width * height * 4) // 4 bytes per pixel
    }
}
```

**4.3.2 Smart Rendering Pipeline**
```swift
// Core/SmartRenderer.swift - NEW ADVANCED FEATURE
class SmartRenderer {
    enum PageComplexity {
        case simple        // Mostly text, few graphics
        case moderate      // Mixed content
        case complex       // Heavy graphics, images
        case veryComplex   // Complex vector graphics, patterns
    }
    
    enum RenderStrategy {
        case fast          // Lower quality, faster processing
        case balanced      // Good quality/speed balance
        case highQuality   // Maximum quality, slower
        case adaptive      // Adjust based on content
    }
    
    private var renderingCache: [String: RenderStrategy] = [:]
    
    func analyzePageContent(_ page: PDFPage) -> PageComplexity {
        let pageRect = page.bounds(for: .mediaBox)
        let area = pageRect.width * pageRect.height
        
        // Heuristic analysis based on page characteristics
        // This would analyze text density, image count, vector complexity
        
        // For now, use page size as a simple heuristic
        switch area {
        case 0..<100000:
            return .simple
        case 100000..<500000:
            return .moderate  
        case 500000..<1000000:
            return .complex
        default:
            return .veryComplex
        }
    }
    
    func selectOptimalStrategy(
        _ complexity: PageComplexity,
        scaleFactor: CGFloat,
        memoryPressure: Bool
    ) -> RenderStrategy {
        
        if memoryPressure {
            return .fast
        }
        
        switch complexity {
        case .simple:
            return scaleFactor > 2.0 ? .balanced : .fast
        case .moderate:
            return .balanced
        case .complex:
            return scaleFactor > 1.5 ? .highQuality : .balanced
        case .veryComplex:
            return .highQuality
        }
    }
    
    func cacheRenderingDecision(_ pageId: String, strategy: RenderStrategy) {
        renderingCache[pageId] = strategy
    }
    
    func getCachedStrategy(_ pageId: String) -> RenderStrategy? {
        return renderingCache[pageId]
    }
}
```

### 4.4 Quality & Automation Tools (Week 4)

**4.4.1 SwiftLint Configuration**
```yaml
# .swiftlint.yml - NEW
disabled_rules:
  - trailing_whitespace
  - todo
opt_in_rules:
  - empty_count
  - force_unwrapping
  - implicit_return
  - sorted_imports
  - vertical_parameter_alignment_on_call

line_length: 
  warning: 100
  error: 120

file_length:
  warning: 400
  error: 500

function_body_length:
  warning: 50
  error: 100

type_body_length:
  warning: 200
  error: 300

excluded:
  - archive/
  - .build/
  - Tests/

custom_rules:
  no_print:
    name: "No Print Statements"
    regex: '\bprint\('
    message: "Use logMessage instead of print"
    severity: warning
```

**4.4.2 Pre-commit Hooks**
```bash
#!/bin/sh
# .git/hooks/pre-commit - NEW
set -e

echo "🔍 Running pre-commit checks..."

# Format code
if command -v swift-format >/dev/null 2>&1; then
    echo "📝 Formatting Swift code..."
    swift-format format --recursive src/ --in-place
else
    echo "⚠️ swift-format not found"
fi

# Lint code
if command -v swiftlint >/dev/null 2>&1; then
    echo "🔍 Linting Swift code..."
    swiftlint lint --strict
else
    echo "⚠️ SwiftLint not found"
fi

# Build project
echo "🔨 Building project..."
make build

# Run tests
echo "🧪 Running tests..."
make test

echo "✅ All pre-commit checks passed!"
```

**4.4.3 Release Automation**
```bash
#!/bin/bash
# scripts/release.sh - NEW
set -e

VERSION=$1
if [ -z "$VERSION" ]; then
    echo "Usage: $0 <version>"
    echo "Example: $0 2.1.0"
    exit 1
fi

echo "🚀 Starting release process for version $VERSION..."

# Validate version format
if ! [[ $VERSION =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
    echo "❌ Invalid version format. Use semantic versioning (e.g., 2.1.0)"
    exit 1
fi

# Update version in files
echo "📝 Updating version strings..."
sed -i '' "s/version = \".*\"/version = \"$VERSION\"/" Package.swift
sed -i '' "s/2\.0\.0-standalone/$VERSION/" src/CLI/OutputFormatter.swift

# Build and test
echo "🔨 Building and testing..."
make clean
make build
make test

# Run performance benchmarks
echo "📊 Running performance benchmarks..."
# This would run performance tests and compare with baseline

# Create git tag
echo "🏷️ Creating git tag..."
git add -A
git commit -m "Release version $VERSION" || echo "No changes to commit"
git tag "v$VERSION"

# Build universal binary
echo "🔧 Building universal binary..."
make universal

# Generate release notes
echo "📋 Generating release notes..."
cat > "release-notes-$VERSION.md" << EOF
# pdf22png v$VERSION

## What's New
- Enhanced performance and stability
- Improved memory management
- Additional testing coverage

## Installation
\`\`\`bash
brew tap twardoch/homebrew-pdf22png
brew install pdf22png
\`\`\`

## Changes
$(git log $(git describe --tags --abbrev=0 HEAD^)..HEAD --pretty=format:"- %s")

## Performance
- Memory usage optimized
- Processing speed maintained or improved
- Build time: $(date)
EOF

echo "✅ Release $VERSION ready!"
echo "📋 Release notes: release-notes-$VERSION.md"
echo "🏷️ Git tag: v$VERSION"
echo ""
echo "Next steps:"
echo "1. Review release notes"
echo "2. Push tag: git push origin v$VERSION"
echo "3. Create GitHub release"
echo "4. Update Homebrew formula"
```

## Phase 5: Final Polish & Production Release (Week 5)

### 5.1 Performance Validation & Benchmarking

**5.1.1 Comprehensive Benchmark Suite**
```swift
// Tests/PerformanceTests/ComprehensiveBenchmarks.swift
import XCTest

final class ComprehensiveBenchmarks: XCTestCase {
    
    func testProcessingSpeedRegression() throws {
        // Benchmark against baseline performance
        let baseline: TimeInterval = 2.0 // seconds for test PDF
        
        measure {
            // Process standard test PDF
        }
        
        // Ensure no significant regression (within 10%)
    }
    
    func testMemoryUsageProfile() throws {
        // Monitor memory usage during processing
        let memoryBaseline: UInt64 = 100 * 1024 * 1024 // 100MB
        
        // Process PDF and monitor memory
        // Ensure memory stays within expected bounds
    }
    
    func testConcurrentProcessingScaling() async throws {
        // Test scaling with multiple concurrent operations
        // Verify performance scales appropriately
    }
    
    func testStartupPerformance() throws {
        // Measure application startup time
        // Ensure fast startup (< 100ms)
    }
}
```

### 5.2 Final Documentation Polish

**5.2.1 README.md Enhancement**
Update README with new architecture highlights and performance metrics.

**5.2.2 API Documentation Completion**
Ensure 100% DocC coverage for all public APIs.

### 5.3 Release Preparation

**5.3.1 Version 2.1.0 Release**
- Update all version strings
- Generate comprehensive release notes
- Test universal binary builds
- Validate all functionality

## Implementation Timeline

### Week 1: Testing Completion
- Day 1-2: Complete Core module tests (BatchProcessor, ResourceManager, SignalHandler)
- Day 3-4: Finish CLI and Utilities tests (OutputFormatter, ProgressReporter)
- Day 5: Create Integration and Performance test suites

### Week 2: Documentation Excellence  
- Day 1-2: Add comprehensive DocC documentation to all modules
- Day 3-4: Create Architecture and Development guides
- Day 5: Update all existing documentation

### Week 3: Advanced Features
- Day 1-2: Implement MemoryPool with context reuse
- Day 3-4: Create SmartRenderer with content analysis
- Day 5: Performance optimization and validation

### Week 4: Quality & Automation
- Day 1-2: Set up SwiftLint, pre-commit hooks
- Day 3-4: Create release automation scripts
- Day 5: Code quality validation and cleanup

### Week 5: Production Release
- Day 1-2: Comprehensive performance testing
- Day 3-4: Final documentation polish
- Day 5: Version 2.1.0 release and validation

## Success Metrics

### Code Quality Excellence
- **Test Coverage**: 95%+ across all modules
- **Documentation**: 100% public API coverage
- **Performance**: No regressions, 10%+ improvement where possible
- **Security**: Zero issues in automated scans

### Developer Experience
- **Build Time**: < 5 seconds for incremental builds
- **Test Suite**: < 30 seconds for complete run
- **Setup**: One-command development environment
- **Automation**: Fully automated release process

### Production Readiness
- **Reliability**: Zero regressions in functionality
- **Performance**: Consistent or improved speed
- **Memory**: Optimized usage with smart pooling
- **Scalability**: Efficient concurrent processing

This plan transforms the already excellent modular architecture into a production-ready, enterprise-grade application with comprehensive testing, documentation, advanced performance features, and full automation.
</file>

<file path="README.md">
# pdf22png

[![Version](https://img.shields.io/github/v/release/twardoch/pdf22png?label=version)](https://github.com/twardoch/pdf22png/releases/latest)
[![License](https://img.shields.io/badge/license-MIT-blue.svg)](LICENSE)
[![Platform](https://img.shields.io/badge/platform-macOS-lightgrey.svg)](https://www.apple.com/macos/)

A high-performance command-line tool for converting PDF documents to PNG images on macOS, leveraging native Core Graphics and Quartz frameworks for optimal quality and speed. Available in both Swift and Objective-C implementations with identical functionality.

## Features

- **Single & Batch Conversion**: Convert individual pages or entire PDF documents
- **Flexible Scaling Options**: 
  - Resolution control (DPI)
  - Percentage scaling
  - Fixed dimensions (width/height fitting)
  - Scale factors
- **Advanced Options**:
  - Page range selection (e.g., `1-5,10,15-20`)
  - Text extraction and OCR for smart naming
  - Dry-run mode for operation preview
  - File overwrite protection with prompts
  - Transparent background support
  - PNG compression quality control
  - Enhanced error messages with troubleshooting hints
  - Verbose logging for debugging
- **I/O Flexibility**:
  - Read from files or stdin
  - Write to files, stdout, or batch output directories
  - Customizable output naming patterns
- **Native Performance**: Available in both Swift and Objective-C implementations
- **Universal Binary**: Supports both Intel and Apple Silicon Macs
- **Dual Implementation**: Choose between modern Swift or classic Objective-C versions

## Installation

### Using Homebrew (Recommended)

```bash
brew tap twardoch/homebrew-pdf22png
brew install pdf22png
```

### Building from Source

Requirements:
- macOS 10.15 or later
- Xcode Command Line Tools

```bash
git clone https://github.com/twardoch/pdf22png.git
cd pdf22png
./build.sh
```

The build script provides several options:
```bash
./build.sh --help  # Show all options
./build.sh -t swift  # Build Swift version only
./build.sh -t objc   # Build Objective-C version only
./build.sh -u        # Build universal binary
./build.sh -i        # Install after building
./build.sh -c        # Clean before building
```

You can combine options:
```bash
# Build and install universal binaries for both implementations
./build.sh -u -i

# Clean, build and install Swift version only
./build.sh -c -t swift -i
```

### Choosing Between Implementations

Both Swift and Objective-C versions provide identical functionality. The Swift version is the default and recommended for most users:

- **Swift version**: Modern implementation using Swift Concurrency for better performance in batch operations
- **Objective-C version**: Classic implementation using Grand Central Dispatch, provided for compatibility

## Usage

### Basic Syntax

```bash
pdf22png [OPTIONS] <input.pdf> [output.png]
```

### Quick Examples

Convert first page of a PDF:
```bash
pdf22png input.pdf output.png
```

Convert a specific page:
```bash
pdf22png -p 5 document.pdf page5.png
```

Convert all pages to individual PNGs:
```bash
pdf22png -a document.pdf
# Creates: document-001.png, document-002.png, etc.
```

Convert at 300 DPI resolution:
```bash
pdf22png -r 300 input.pdf high-res.png
```

Scale to 50% size:
```bash
pdf22png -s 50% input.pdf half-size.png
```

### Options

| Option | Long Form | Description | Default |
|--------|-----------|-------------|---------|
| `-p <n>` | `--page` | Convert specific page number or range | 1 |
| `-a` | `--all` | Convert all pages | disabled |
| `-r <dpi>` | `--resolution` | Set output DPI (e.g., 300) | 144 |
| `-s <spec>` | `--scale` | Scale specification (see below) | 100% |
| `-t` | `--transparent` | Preserve transparency | disabled |
| `-q <0-9>` | `--quality` | PNG compression quality | 6 |
| `-o <path>` | `--output` | Output file/prefix or `-` for stdout | - |
| `-d <dir>` | `--directory` | Output directory for batch mode | . |
| `-n` | `--name` | Include extracted text in filenames | disabled |
| `-P <pattern>` | `--pattern` | Custom naming pattern for batch mode | - |
| `-D` | `--dry-run` | Preview operations without writing files | disabled |
| `-f` | `--force` | Force overwrite existing files without prompting | disabled |
| `-v` | `--verbose` | Enable verbose logging | disabled |
| `-h` | `--help` | Show help message | - |

### Scale Specifications

The `-s/--scale` option accepts various formats:

- **Percentage**: `150%` (1.5x scale)
- **Factor**: `2.0` (2x scale)
- **Fixed width**: `800x` (800px wide, height auto)
- **Fixed height**: `x600` (600px high, width auto)
- **Fit within**: `800x600` (fit within 800x600 box)

### Page Ranges

The `-p/--page` option supports flexible page selection:

- **Single page**: `-p 5`
- **Range**: `-p 5-10`
- **Multiple selections**: `-p 1,3,5-10,15`
- **Mix and match**: `-p 1-3,7,10-15`

### Custom Naming Patterns

Use `-P/--pattern` with placeholders for batch conversions:

- `{basename}` or `{name}` - Input filename without extension
- `{page}` - Page number with automatic padding
- `{page:03d}` - Page number with custom padding (e.g., 001, 002)
- `{text}` - Extracted text from page (requires -n flag)
- `{date}` - Current date in YYYYMMDD format
- `{time}` - Current time in HHMMSS format
- `{total}` - Total page count

Example: `pdf22png -P '{basename}_p{page:04d}_of_{total}' doc.pdf`
Creates: `doc_p0001_of_10.png`, `doc_p0002_of_10.png`, etc.

### Advanced Examples

Convert with transparent background at 300 DPI:
```bash
pdf22png -t -r 300 input.pdf transparent-300dpi.png
```

Batch convert all pages to a specific directory:
```bash
pdf22png -d ./output_images -o myprefix document.pdf
# Creates: ./output_images/myprefix-001.png, etc.
```

Convert specific page ranges:
```bash
pdf22png -p 1-3,5,10-15 document.pdf
# Converts pages 1, 2, 3, 5, 10, 11, 12, 13, 14, 15
```

Use custom naming pattern with extracted text:
```bash
pdf22png -a -n -P '{basename}-{page:03d}--{text}' document.pdf
# Creates: document-001--introduction.png, document-002--chapter-one.png, etc.
```

Preview operations with dry-run mode:
```bash
pdf22png -a -D -P 'page_{page}_of_{total}' document.pdf
# Shows what files would be created without actually writing them
```

Force overwrite existing files without prompting:
```bash
pdf22png -f -a document.pdf
# Overwrites existing files without asking
```

Pipe operations:
```bash
# From stdin to stdout
cat document.pdf | pdf22png - - > output.png

# Process and pipe to ImageMagick
pdf22png -r 300 input.pdf - | convert - -resize 50% final.jpg
```

## Architecture

pdf22png is available in two implementations:

### Swift Implementation (Default)
- **Swift 5.7+** with modern language features
- **Swift Argument Parser** for command-line interface
- **Swift Concurrency** (async/await, TaskGroup) for parallel processing
- **Core Graphics** for PDF rendering
- **Vision** framework for OCR capabilities
- **ImageIO** for PNG output

Swift codebase organization:
- `Package.swift` - Swift Package Manager manifest
- `Sources/pdf22png/main.swift` - Main program entry point and CLI
- `Sources/pdf22png/Models.swift` - Core data structures
- `Sources/pdf22png/Utilities.swift` - Utility functions and helpers
- `Tests/pdf22pngTests/` - XCTest-based unit tests

### Objective-C Implementation
- **Objective-C** with ARC (Automatic Reference Counting)
- **getopt_long** for command-line parsing
- **Grand Central Dispatch** for parallel processing
- **Core Graphics** for PDF rendering
- **Vision** framework for OCR capabilities
- **ImageIO** for PNG output

Objective-C codebase organization:
- `src/pdf22png.m` - Main program logic and argument parsing
- `src/utils.m` - Utility functions for scaling, rendering, and I/O
- `src/errors.h` - Error codes and handling
- `tests/` - Custom test runner with unit tests

## Performance

pdf22png is optimized for performance:
- Parallel processing for batch conversions (Swift Concurrency or GCD)
- Efficient memory management with automatic reference counting
- Native Core Graphics rendering for best quality
- Built-in error recovery for robust batch processing
- Context-aware text extraction with OCR fallback
- Minimal dependencies (only macOS system frameworks)

## Contributing

Contributions are welcome! Please feel free to submit issues, feature requests, or pull requests.

### Development

To build from source:
```bash
make
```

To run tests:
```bash
make test
```

### Releasing

To create a new release:
```bash
# Automatic versioning (increments minor version)
./release.sh

# Specify version explicitly
./release.sh --v 2.1.0
```

This will:
1. Build the universal binary
2. Run tests
3. Create and push a git tag
4. Trigger GitHub Actions to build and publish release artifacts

See [TODO.md](TODO.md) for planned features and improvements.

## License

pdf22png is released under the MIT License. See [LICENSE](LICENSE) for details.

## Author

- Created by [Adam Twardoch](https://github.com/twardoch)
- Developed using Anthropic software

## See Also

- [Usage Guide](docs/USAGE.md) - Detailed usage instructions
- [Examples](docs/EXAMPLES.md) - More usage examples
- [API Documentation](docs/API.md) - Function reference
- [Changelog](CHANGELOG.md) - Version history
</file>

<file path="Makefile">
# pdf22png - Streamlined Swift Build System

PRODUCT_NAME = pdf22png
VERSION = $(shell git describe --tags --always --dirty)
PREFIX ?= /usr/local

.PHONY: all clean install uninstall test universal release fmt lint

all: build

# Build targets
build:
	@echo "Building $(PRODUCT_NAME)..."
	@$(MAKE) -C src build

release:
	@echo "Building $(PRODUCT_NAME) release: $(VERSION)"
	@$(MAKE) -C src release

universal:
	@echo "Building universal binary..."
	@$(MAKE) -C src universal

# Test targets
test:
	@echo "Running tests..."
	@$(MAKE) -C src test

# Install targets
install: build install-man
	@echo "Installing $(PRODUCT_NAME)..."
	@$(MAKE) -C src install PREFIX=$(PREFIX)

install-man:
	@echo "Installing man page..."
	@mkdir -p $(PREFIX)/share/man/man1
	@cp docs/pdf22png.1 $(PREFIX)/share/man/man1/
	@echo "Man page installed. Use 'man pdf22png' to view."

uninstall:
	@echo "Uninstalling $(PRODUCT_NAME)..."
	@$(MAKE) -C src uninstall PREFIX=$(PREFIX)
	@rm -f $(PREFIX)/share/man/man1/pdf22png.1
	@echo "Man page removed."

# Clean targets
clean:
	@echo "Cleaning build..."
	@$(MAKE) -C src clean

# Code quality targets
fmt:
	@echo "Formatting code..."
	@$(MAKE) -C src fmt

lint:
	@echo "Linting code..."
	@$(MAKE) -C src lint

# Show build information
info:
	@echo "Product: $(PRODUCT_NAME)"
	@echo "Version: $(VERSION)"
	@echo "Prefix: $(PREFIX)"
	@echo "Swift version: $(shell swift --version | head -n1)"
</file>

<file path="TODO.md">
# PDF22PNG Phase 4+ Advanced Streamlining TODO

## Current Status: Phases 1-3 ✅ COMPLETE
- **46% Codebase Reduction**: 124,900+ → 67,435 characters
- **Modular Architecture**: 16 source files, 264-line main.swift
- **Testing Foundation**: 6 comprehensive unit test suites established
- **Build System**: Modern Makefile with SPM support

## Phase 4: Production Excellence & Advanced Features

### Week 1: Complete Testing Infrastructure
- [ ] Create Tests/CoreTests/BatchProcessorTests.swift
- [ ] Create Tests/CoreTests/ResourceManagerTests.swift  
- [ ] Create Tests/CoreTests/SignalHandlerTests.swift
- [ ] Create Tests/CLITests/OutputFormatterTests.swift
- [ ] Create Tests/UtilitiesTests/ProgressReporterTests.swift
- [ ] Create Tests/IntegrationTests/EndToEndTests.swift
- [ ] Create Tests/PerformanceTests/BenchmarkTests.swift
- [ ] Achieve 90%+ test coverage across all modules

### Week 2: Documentation Modernization
- [ ] Add DocC documentation to Core/PDFProcessor.swift
- [ ] Add DocC documentation to Core/ImageRenderer.swift
- [ ] Add DocC documentation to Core/BatchProcessor.swift
- [ ] Add DocC documentation to Core/MemoryManager.swift
- [ ] Add DocC documentation to Core/ResourceManager.swift
- [ ] Add DocC documentation to Core/SignalHandler.swift
- [ ] Add DocC documentation to CLI modules
- [ ] Add DocC documentation to Utilities modules
- [ ] Create docs/ARCHITECTURE.md
- [ ] Create docs/DEVELOPMENT.md
- [ ] Update README.md with new architecture highlights

### Week 3: Advanced Performance Features
- [ ] Create Core/MemoryPool.swift with actor-based context pooling
- [ ] Create Core/SmartRenderer.swift for content analysis
- [ ] Implement ContextSize struct for memory management
- [ ] Add rendering strategy caching
- [ ] Integrate SmartRenderer with ImageRenderer
- [ ] Performance validation and optimization
- [ ] Memory usage profiling and optimization

### Week 4: Quality & Automation Tools
- [ ] Create .swiftlint.yml configuration
- [ ] Set up SwiftLint integration in Makefile
- [ ] Create .git/hooks/pre-commit for automated checks
- [ ] Create scripts/release.sh for automated releases
- [ ] Add code formatting validation
- [ ] Set up continuous integration improvements
- [ ] Add automated code quality reporting

### Week 5: Production Release Preparation
- [ ] Run comprehensive performance benchmarks
- [ ] Validate memory usage improvements
- [ ] Test processing speed maintenance
- [ ] Verify startup time optimizations
- [ ] Complete API documentation coverage (100%)
- [ ] Update version to 2.1.0 across all files
- [ ] Generate comprehensive release notes
- [ ] Test universal binary builds
- [ ] Validate all platforms and functionality

## Phase 5: Advanced Features (Future Enhancement)

### Async I/O Operations
- [ ] Create Utilities/AsyncFileOperations.swift
- [ ] Implement concurrent image writing with backpressure
- [ ] Add non-blocking PDF reading capabilities
- [ ] Optimize file I/O performance

### Enhanced Memory Management
- [ ] Context pooling with size-based allocation
- [ ] Advanced memory pressure detection
- [ ] Intelligent garbage collection triggers
- [ ] Memory leak detection and prevention

### Smart Processing Pipeline  
- [ ] Page content analysis for optimal rendering
- [ ] Automatic quality adjustment based on content
- [ ] Caching of rendering decisions
- [ ] Performance-based strategy selection

## Success Criteria Validation

### Code Quality Metrics
- [ ] 95%+ test coverage across all modules
- [ ] 100% public API documentation coverage
- [ ] Zero SwiftLint warnings or errors
- [ ] All modules under 500 lines (currently achieved)
- [ ] Security scan with zero issues

### Performance Metrics
- [ ] Build time under 5 seconds for incremental builds
- [ ] Test suite completes in under 30 seconds
- [ ] Memory usage optimized with smart pooling
- [ ] Processing speed maintained or improved
- [ ] Startup time under 100ms

### Developer Experience
- [ ] One-command setup for new developers
- [ ] Automated formatting and linting
- [ ] Comprehensive development documentation
- [ ] Automated release process
- [ ] Clear contribution guidelines

### Production Readiness
- [ ] Zero regressions in existing functionality
- [ ] All command-line options work identically
- [ ] Error messages remain helpful and actionable
- [ ] Performance maintained or improved
- [ ] Universal binary support validated

## Current Priority: Week 1 - Testing Infrastructure

Focus on completing the comprehensive test suite to establish production-grade quality assurance before moving to advanced features. The current architecture provides an excellent foundation for rapid development of remaining components.
</file>

<file path="CHANGELOG.md">
# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

### Changed
- **Major Codebase Streamlining Initiative**: Complete architectural consolidation and modernization
  - **Phase 1: Implementation Consolidation (Complete)**: 
    - Archived Objective-C implementation to `archive/objc/` (preserving 30,270 lines of legacy code)
    - Archived Swift SPM implementation to `archive/swift-spm/` (avoiding dependency complexity)
    - Consolidated on single Swift standalone implementation for maximum maintainability
    - Reduced build system complexity from 3 parallel systems to 1 focused system
    - Removed redundant build scripts (build.sh, release.sh) and simplified CI/CD workflows
    - Updated GitHub Actions to target single implementation with corrected artifact paths
  - **Phase 2: Complete Code Modularization (✅ COMPLETED)**: Successfully transformed 1,382-line monolithic main.swift
    - **Modular Architecture Achieved**: Reduced main.swift from 1,382 lines to 267 lines (81% reduction)
    - **14 Focused Modules Created**: Split monolithic code into maintainable, single-responsibility modules
    - **Core/ directory (6 modules)**: Business logic and system management
      - MemoryManager.swift (126 lines) - memory monitoring and optimization
      - PDFProcessor.swift (32 lines) - PDF loading, validation, and page extraction
      - ImageRenderer.swift (109 lines) - page rendering and PNG output with quality control
      - BatchProcessor.swift (134 lines) - memory-optimized batch processing with async support
      - ResourceManager.swift (68 lines) - secure temporary file and resource management
      - SignalHandler.swift (70 lines) - graceful shutdown and cleanup handling
    - **Models/ directory (4 modules)**: Data structures and type definitions
      - ProcessingOptions.swift (35 lines) - unified command-line options with computed properties
      - ScaleSpecification.swift (43 lines) - modern enum-based scaling with parsing
      - Errors.swift (116 lines) - comprehensive error handling with contextual troubleshooting
      - Results.swift (73 lines) - processing results and batch statistics
    - **CLI/ directory (2 modules)**: User interface and formatting
      - ArgumentParser.swift (102 lines) - robust argument parsing and validation
      - OutputFormatter.swift (142 lines) - help, version, progress, and error formatting
    - **Utilities/ directory (2 modules)**: Support functionality
      - ProgressReporter.swift (124 lines) - detailed progress tracking with memory monitoring
      - InputValidator.swift (113 lines) - security-focused input validation and sanitization
    - **Swift Concurrency Integration**: Added async/await support for batch processing
    - **Build System Compatibility**: All modules compile together seamlessly
    - **100% Feature Parity**: All original functionality preserved and tested
    - **Phase 2 Verification**: Successful compilation and runtime testing of modularized architecture
      - Help command: ✅ Working (`./pdf22png --help`)
      - Version command: ✅ Working (`./pdf22png --version`)
      - All 14 modules successfully integrated and compiling
      - Maintained backward compatibility with all command-line options
      - Preserved all error handling and troubleshooting capabilities
  - **Phase 3: Build System & Infrastructure Modernization (✅ STARTED)**: Foundation for production-ready development
    - **Technical Debt Elimination**: Removed src/main_old.swift (48,941 bytes - 40.6% of codebase)
    - **Swift Package Manager Integration**: Created Package.swift for modern Swift development
    - **Enhanced Build System**: Updated Makefile with comprehensive targets (build, clean, test, install, format, docs)
    - **Testing Infrastructure Foundation**: 
      - Created Tests/ directory structure with CoreTests/, CLITests/, UtilitiesTests/, IntegrationTests/, PerformanceTests/
      - Moved test-framework.swift to proper Tests/ location
      - Created comprehensive unit test suites:
        - PDFProcessorTests.swift - PDF loading, validation, and page extraction tests
        - ImageRendererTests.swift - Rendering, scaling, and image output tests  
        - MemoryManagerTests.swift - Memory monitoring, pressure detection, and batch sizing tests
        - ArgumentParserTests.swift - CLI argument parsing and validation tests
        - InputValidatorTests.swift - Security-focused input validation and sanitization tests
    - **Developer Experience Improvements**: Added make targets for formatting, documentation, and automation
    - **Build Verification**: All modules continue to compile and function correctly with modular architecture
    - **Codebase Statistics**: 
      - Source files: 15 Swift modules (264-line main.swift + 14 focused modules)
      - Test files: 6 comprehensive unit test suites covering core functionality
      - Code reduction: Eliminated 48,941 bytes of legacy code (40.6% of total codebase)
      - Architecture: Clean separation with Core/, Models/, CLI/, Utilities/, Tests/ structure
    - **Fresh Codebase Analysis**: Latest repomix analysis shows optimized state
      - Total files: 16 source files (67,435 characters, 14,590 tokens)
      - Largest file: main.swift at 9,184 chars (13.7% of codebase) - down from previous 48,941 chars
      - Well-distributed module sizes: No single module dominates the codebase
      - Security: ✅ No suspicious files detected in automated security scan
  - **Documentation Consolidation**: Streamlined from 15+ documentation files
    - Removed outdated files: AGENTS.md, IMPLEMENTATION_STATUS.md, PROGRESS.md, CMakeLists.txt
    - Consolidated BUILD.md and MIGRATION.md content into main documentation
    - Maintained essential documentation: README.md, API.md, USAGE.md, EXAMPLES.md
    - Preserved professional man page (pdf22png.1) for Unix compatibility

### Added
- **Performance Optimizations (Phase 1.2)**: Significant performance improvements for batch operations
  - **Adaptive Batch Sizing**: Dynamic adjustment of concurrent operations based on available memory
    - Monitors system memory pressure and adjusts batch size accordingly
    - Reduces batch size under memory pressure (50%, 70%, 85% thresholds)
    - Increases batch size when system resources are available
    - Adapts based on success rate and processing time metrics
    - Real-time chunk size adjustment during batch processing
  - **Fast Rendering Paths**: Optimized rendering for common scenarios
    - Automatic detection of thumbnail (≤500x500) and preview (≤1000x1000) scenarios
    - Reduced quality settings for small images where high quality isn't needed
    - 5-bit color depth for thumbnails vs 8-bit for standard rendering
    - Configurable antialiasing and interpolation quality per scenario
    - Automatic fallback to standard rendering if fast path fails
  - **Memory Pooling**: Bitmap context reuse for batch operations
    - Reuses CGContext objects across multiple page renders
    - Reduces memory allocation overhead in batch processing
    - Automatic cleanup of unused contexts after 60 seconds
    - Pool statistics tracking (total contexts, in-use, memory usage)
    - Maximum pool size and memory limits (10 contexts, 500MB default)
    - Thread-safe implementation with proper locking

### Changed
- **Batch Processing Loop**: Refactored to support dynamic chunk sizing
  - Replaced fixed chunk iteration with adaptive while loop
  - Added performance metrics tracking per chunk
  - Improved resource constraint handling with retry logic
  - Enhanced progress reporting with chunk-level statistics

### Fixed
- **Swift Package Manager Build Issue**: Resolved SWBBuildService.framework dependency error
  - Modified Swift Makefile to fall back to Objective-C implementation when SPM fails
  - Updated build script with explanatory comments about the fallback behavior
  - Maintained full build functionality while avoiding SPM compatibility issues
  - All build targets (`./build.sh`, `make swift`, `make all`) now work successfully

### Added (Phase 2: Production Readiness)
- **Comprehensive Man Page**: Created professional Unix manual page (pdf22png.1)
  - Complete documentation of all command-line options
  - Detailed examples for common use cases
  - Memory management and signal handling documentation
  - Exit status codes and environment variables
  - Limitations and known issues
  - Installation support in Makefile

- **Enhanced Progress Reporting for Batch Operations**: Professional progress tracking system
  - Real-time progress bar with percentage completion
  - Speed metrics (pages per second)
  - Time elapsed and estimated time remaining
  - Per-page status indicators (✓ success, ✗ failure)
  - Memory usage monitoring in verbose mode
  - Chunk processing status for large batches
  - Graceful interruption reporting
  - Final summary with processing statistics

### Added
- **Standalone Swift Implementation**: Created production-ready Swift version without SPM dependencies
  - Implemented complete command-line parser without ArgumentParser dependency
  - Full feature parity with advanced Objective-C implementation
  - Comprehensive error handling with PDF22PNGError enum
  - Support for all command-line options and functionality
  - Built with native Swift frameworks: Foundation, CoreGraphics, Quartz, PDFKit
  - Universal binary support for both Intel and Apple Silicon
  - Resolves the strategic decision to consolidate on Swift implementation

### Changed
- **Build System Enhancement**: Updated Swift build system to use standalone implementation
  - Swift Makefile now builds standalone version instead of falling back to Objective-C
  - Maintains full Swift build functionality without external dependencies
  - Preserves all existing build targets and workflows

### Enhanced (Phase 1: Foundation Stabilization Complete)
- **Production-Ready Memory Management System**: Comprehensive memory monitoring and optimization
  - Real-time system memory tracking with pressure detection
  - Memory requirement estimation for PDF processing operations
  - Adaptive batch sizing based on available system resources
  - Memory pressure warnings and automatic optimization
  - Resource exhaustion prevention with graceful degradation

- **Advanced Signal Handling & Resource Cleanup**: Robust interruption handling
  - Graceful shutdown on SIGINT, SIGTERM, and SIGHUP signals
  - Automatic resource cleanup with registered cleanup handlers
  - Secure temporary file management with automatic cleanup
  - Thread-safe resource tracking and management
  - Timeout protection for cleanup operations

- **Comprehensive Input Validation & Security**: Enterprise-grade input sanitization
  - Path traversal attack prevention with normalized path validation
  - File size and complexity limits to prevent resource exhaustion
  - Command injection protection through input sanitization
  - Null byte and control character filtering
  - Maximum path length and pattern validation
  - PDF complexity analysis and automatic scale factor adjustment

- **Enhanced Error Handling & User Experience**: Professional troubleshooting system
  - Detailed error messages with context-aware troubleshooting hints
  - Specific guidance for common error scenarios
  - Recovery suggestions for file access, memory, and format issues
  - Professional error codes with comprehensive descriptions
  - User-friendly error reporting with actionable solutions

- **Comprehensive Integration Testing Framework**: Production-quality test suite
  - 12 comprehensive integration tests with 100% pass rate
  - End-to-end CLI testing with real PDF processing
  - Memory monitoring and resource management validation
  - Error handling and edge case coverage
  - Automated test reporting with performance metrics
  - Integrated into build system for continuous validation

### Added
- **Unified Build Script**: New `build.sh` script for simplified building and installation
  - Single command to build both Swift and Objective-C versions
  - Support for universal binary builds
  - Clean build option
  - Installation support
  - Colored output and improved error handling
  - Comprehensive help with usage examples

- **Dual Implementation Support**: Both Objective-C and Swift versions now coexist
  - Swift implementation with full feature parity to Objective-C version
  - Swift version uses modern language features:
    - `swift-argument-parser` for CLI parsing
    - Swift Concurrency (`async/await`, `TaskGroup`) for batch processing
    - Native Swift error handling with typed errors
    - Value types and automatic memory management
  - Makefile updated to support building either or both versions:
    - `make` or `make swift` - builds Swift version (default)
    - `make objc` - builds Objective-C version
    - `make install-swift` - installs Swift version
    - `make install-objc` - installs Objective-C version
  - Both versions share identical command-line interface and behavior
  - Comprehensive test suite for Swift implementation

### Changed
- Build system restructured to support dual implementations
  - Default target now builds Swift version
  - Universal binary support for both implementations
  - Separate test targets for each version
- Project structure organized for Swift Package Manager:
  - `Sources/pdf22png/` - Swift implementation
  - `src/` - Objective-C implementation (preserved)
  - `Tests/pdf22pngTests/` - Swift tests
- Updated README to document both implementations and build options

### Documentation
- Created comprehensive migration guide (`docs/MIGRATION.md`) for transitioning between implementations
- Added detailed build guide (`docs/BUILD.md`) covering both Swift and Objective-C builds
- Updated API documentation (`docs/API.md`) to cover both implementations
- Enhanced README with dual implementation information and version selection guidance
- Added implementation status document (`IMPLEMENTATION_STATUS.md`) summarizing project completion

### Testing
- Verified Objective-C implementation with full test suite (9/9 tests passing)
- Created comprehensive Swift test suite covering all core functionality
- Added test scripts for validation of both implementations
- Confirmed feature parity through testing

### Added
- File overwrite protection with interactive prompts
  - New `-f/--force` flag to bypass overwrite prompts
  - Interactive confirmation when files would be overwritten
  - Dry-run mode now shows which files would be overwritten
  - Non-interactive mode defaults to not overwriting existing files
- Enhanced error reporting with troubleshooting hints
  - Context-aware error messages provide specific guidance
  - Automatic troubleshooting suggestions based on error type
  - Covers PDF-related, file I/O, memory, scaling, and page range errors
  - Improved user experience with actionable error resolution

### Fixed
- Fixed sign comparison warnings in utils.m (NSInteger vs NSUInteger)
- Replaced XCTest dependency with custom test runner for better compatibility
- Improved test coverage with overwrite protection functionality tests

## [1.1.0] - 2025-06-22

### Added
- Automated release script (`release.sh`) with semantic versioning support
  - Automatic version detection from git tags
  - Minor version auto-increment capability
  - Build verification before tagging
  - Colored output for better readability
- Complete GitHub Actions workflow for automated releases with:
  - Universal binary builds for Intel and Apple Silicon
  - PKG installer generation with proper macOS installer structure
  - DMG disk image creation with install script
  - Automated SHA-256 checksum generation
  - GitHub release creation with all artifacts
- New `-n/--name` flag for including extracted text in output filenames
  - Extracts text directly from PDF pages using Core Graphics
  - Falls back to OCR using Vision framework when no text is found
  - Generates slugified filenames like `prefix-001--extracted-text.png`
  - Maximum 30 characters for text suffix, properly truncated at word boundaries
  - Only available in batch mode for performance reasons
- Page range selection with `-p/--page` option supporting complex ranges
  - Single pages: `-p 5`
  - Ranges: `-p 5-10`
  - Comma-separated lists: `-p 1,3,5-10,15`
  - Works in both single page and batch modes
  - Validates ranges against total page count
- Dry-run mode with `-D/--dry-run` flag
  - Preview all operations without writing any files
  - Shows what files would be created with their dimensions
  - Estimates file sizes based on image dimensions
  - Works with all output modes (file, stdout, batch)
  - Useful for testing command options before actual conversion
- Custom naming patterns with `-P/--pattern` option for batch mode
  - `{basename}` or `{name}` - Input filename without extension
  - `{page}` - Page number with automatic padding
  - `{page:03d}` - Page number with custom padding (e.g., 001, 002)
  - `{text}` - Extracted text from page (requires -n flag)
  - `{date}` - Current date in YYYYMMDD format
  - `{time}` - Current time in HHMMSS format
  - `{total}` - Total page count
  - Example: `'{basename}_p{page:04d}_of_{total}'` → `document_p0001_of_10.png`

### Fixed
- Updated GitHub Actions workflow to use modern actions (replaced deprecated create-release@v1 with softprops/action-gh-release@v1)
- Fixed binary path references throughout release workflow
- Corrected build paths in distribution packaging
- Added @autoreleasepool blocks in renderPDFPageToImage() and batch processing loops to prevent memory buildup
- Fixed memory leaks in error paths by ensuring proper cleanup of Core Graphics resources
- Fixed unused variables warnings (scaleXSet, scaleYSet) in calculateScaleFactor()
- Added PDF validation to check for encrypted PDFs and empty documents before processing
- Created unified error handling system with dedicated errors.h header and standardized error codes
- Implemented partial batch recovery - failed pages are now skipped instead of stopping entire batch
- Added graceful shutdown with signal handlers (SIGINT, SIGTERM) for batch operations
- Added progress reporting for batch operations (shows every 10 pages processed)

### Changed
- Reorganized project structure for better maintainability:
  - Build output now goes to `build/` directory instead of project root
  - Updated Makefile to use dedicated build directory with proper dependencies
  - Modified universal build script to output to `build/` directory
  - Updated all scripts and workflows to reference new build location
- Improved build system with explicit directory creation
- Enhanced clean target to properly remove all build artifacts

### Removed
- Removed old monolithic `pdf22png.m` from root directory (superseded by modular version in `src/`)

### Documentation
- Created comprehensive improvement plan in TODO.md with:
  - Critical stability and memory management fixes
  - High-priority user experience enhancements
  - Performance optimization opportunities
  - Testing infrastructure requirements
  - Code modernization roadmap
  - Security hardening recommendations
  - Phased implementation strategy

## [1.0.0] - 2024-06-23

### Added
- Initial project structure for `pdf22png`.
- Core functionality to convert PDF pages to PNG images.
- Support for:
    - Specific page selection (`-p`).
    - Batch conversion of all pages (`-a`, `-d`).
    - Various scaling methods (`-s`): percentage, factor, width/height fitting.
    - Resolution setting in DPI (`-r`).
    - Transparent backgrounds (`-t`).
    - PNG quality hint (`-q`).
    - Input from file or stdin.
    - Output to file or stdout (single page mode).
    - Customizable output directory and filename prefix for batch mode.
    - Verbose logging (`-v`).
    - Help message (`-h`).
- Makefile for building, testing, installing, and cleaning.
- Basic unit tests for utility functions using XCTest.
- GitHub Actions workflows for CI (build & test) and Releases.
- Homebrew formula template.
- Documentation: README, USAGE, EXAMPLES, API, CHANGELOG, TODO.
- `.gitignore`, `.editorconfig` (to be created).
</file>

</files>
