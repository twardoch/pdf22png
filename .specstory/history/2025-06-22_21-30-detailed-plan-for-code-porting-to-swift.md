<!-- Generated by SpecStory -->

# Detailed plan for code porting to Swift (2025-06-22 23:30:57)

_**User**_

into "TODO.md" write a very detailed and specific plan on how to    │
│   port the entire code to Swift, but for now we want to keep the      │
│   ObjC implementation. The plan should include speed benchmarks that  │
│   will compare both implementations 

---

_**Assistant**_



---

Read file: TODO.md

---



---

```diff
  - **Phase 6**: Custom test runner (replaced XCTest dependency)
  - **Phase 6**: Basic unit tests for utility functions
+ 
+ ### Phase 13: Swift Porting Strategy  
+ **Goal**: Gradually migrate the ObjC codebase to pure Swift while guaranteeing that the existing Objective-C implementation remains the canonical, production-ready path until feature- and performance-parity is proven.
+ 
+ #### 13.1 Architectural Blueprint  
+ - [ ] Produce a high-level mapping between current ObjC modules and their future Swift equivalents (CLI, PDFCore, RenderCore, IO, Utils).  
+ - [ ] Decide on packaging model: Swift Package Manager monorepo with multiple products (`pdf22pngCLI`, `CorePDF22PNG`).  
+ - [ ] Create an `ObjCCompatibility` target that exposes current public APIs via `@objc` to keep integration surface stable.  
+ 
+ #### 13.2 Build & CI Dual-Lane  
+ - [ ] Update Makefile to build two artefacts: `pdf22png_objc` (default) and `pdf22png_swift` (experimental).  
+ - [ ] Extend GitHub Actions matrix to run `make swift` on macOS-latest (Intel+ARM runners).  
+ - [ ] Add Swift-Lint and Swift-Format steps to match existing style gates.  
+ 
+ #### 13.3 Incremental Module-by-Module Port  
+ Port order is chosen to minimise risk. Each sub-task must pass unit tests and performance gate before merging.  
+ 1. Utils (string parsing, scale calculation).  
+ 2. CLI argument parsing (replace custom parser with `swift-argument-parser`).  
+ 3. Image output handling (PNG encoding via ImageIO).  
+ 4. Rendering pipeline (CoreGraphics layer).  
+ 5. Batch processing & GCD queues (migrate to Swift Concurrency).  
+ 
+ #### 13.4 Bridging Layer  
+ - [ ] Introduce Bridging Header `pdf22png-Bridging-Header.h`.  
+ - [ ] Keep ObjC classes accessible from Swift while the port is incomplete (`NS_SWIFT_NAME`).  
+ - [ ] Add thin Swift wrappers that forward to ObjC implementation when native Swift is not yet ready.  
+ 
+ #### 13.5 Verification Matrix  
+ Every migration PR must:  
+ - [ ] Add/extend XCTest cases for new Swift code.  
+ - [ ] Prove feature parity via golden-image visual regression tests.  
+ - [ ] Pass speed benchmarks (see 13.6).  
+ 
+ #### 13.6 Performance Benchmarking Plan  
+ Establish repeatable micro- & macro-benchmarks to compare ObjC vs Swift.  
+ 
+ Benchmark harness:  
+ ```bash
+ # once
+ brew install hyperfine graphicsmagick
+ 
+ # run
+ hyperfine --warmup 3 '\
+   ./pdf22png_objc -a -r 144 samples/10p.pdf -d /tmp/out_objc' '\
+   ./pdf22png_swift -a -r 144 samples/10p.pdf -d /tmp/out_swift'
+ ```
+ 
+ Datasets (checked into `benchmarks/`):  
+ | Alias | Pages | Size | Features | Type |  
+ |-------|------:|------|----------|------|  
+ | small | 10    | 1 MB | vector   | brochure |  
+ | medium| 120   | 12 MB| mixed    | novel |  
+ | large | 800   | 95 MB| images   | catalogue |
+ 
+ Metrics recorded:  
+ - Wall-clock time (mean ± stddev, 10 runs)  
+ - Pages per second & MB/s throughput  
+ - Peak RSS memory (via `/usr/bin/time -l`)  
+ - Energy impact (Xcode Instruments)  
+ 
+ Success criteria:  
+ - Swift build must be within **±5 %** execution time and **±10 %** memory of ObjC before sign-off.  
+ - After full port, Swift must outperform ObjC by **≥15 %** or justify regressions in changelog.  
+ 
+ #### 13.7 Roll-out & Deprecation  
+ - [ ] Tag first Swift-parity release `v2.0.0-beta1`.  
+ - [ ] Ship dual binaries for two minor versions.  
+ - [ ] Announce ObjC deprecation; remove ObjC build code by `v3.0`.  
+ 
+ ---
  
  ## Development Guidelines
```

---

I've added a comprehensive “Phase 13: Swift Porting Strategy” section to `TODO.md`.  
This details a step-by-step migration plan, dual-lane build/CI setup, module-by-module port order, bridging approach, a rigorous verification matrix, and a full performance-benchmarking protocol to compare Objective-C and Swift builds.

---

