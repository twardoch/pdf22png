This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
CLI/
  ArgumentParser.swift
  OutputFormatter.swift
Core/
  BatchProcessor.swift
  ImageRenderer.swift
  MemoryManager.swift
  PDFProcessor.swift
  ResourceManager.swift
  SignalHandler.swift
Models/
  Errors.swift
  ProcessingOptions.swift
  Results.swift
  ScaleSpecification.swift
Utilities/
  InputValidator.swift
  ProgressReporter.swift
main_old.swift
main.swift
Makefile
test-framework.swift
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="CLI/ArgumentParser.swift">
import Foundation

// MARK: - Command Line Argument Parser

struct ArgumentParser {
    static func parseArguments() -> ProcessingOptions {
        var options = ProcessingOptions()
        let args = Array(CommandLine.arguments.dropFirst())
        var i = 0
        
        while i < args.count {
            let arg = args[i]
            
            switch arg {
            case "-h", "--help":
                options.showHelp = true
                return options
                
            case "--version":
                options.showVersion = true
                return options
                
            case "-p", "--page":
                guard i + 1 < args.count else {
                    print("Error: --page requires a value")
                    exit(2)
                }
                options.page = args[i + 1]
                i += 1
                
            case "-a", "--all":
                options.allPages = true
                
            case "-r", "--resolution":
                guard i + 1 < args.count else {
                    print("Error: --resolution requires a value")
                    exit(2)
                }
                options.resolution = args[i + 1]
                i += 1
                
            case "-s", "--scale":
                guard i + 1 < args.count else {
                    print("Error: --scale requires a value")
                    exit(2)
                }
                options.scale = args[i + 1]
                i += 1
                
            case "-t", "--transparent":
                options.transparent = true
                
            case "-q", "--quality":
                guard i + 1 < args.count else {
                    print("Error: --quality requires a value")
                    exit(2)
                }
                guard let quality = Int(args[i + 1]), quality >= 0 && quality <= 9 else {
                    print("Error: quality must be between 0 and 9")
                    exit(2)
                }
                options.quality = quality
                i += 1
                
            case "-o", "--output":
                guard i + 1 < args.count else {
                    print("Error: --output requires a value")
                    exit(2)
                }
                options.outputPath = args[i + 1]
                i += 1
                
            case "-d", "--directory":
                guard i + 1 < args.count else {
                    print("Error: --directory requires a value")
                    exit(2)
                }
                options.directory = args[i + 1]
                i += 1
                
            case "-v", "--verbose":
                options.verbose = true
                
            case "-n", "--name":
                options.includeText = true
                
            case "-P", "--pattern":
                guard i + 1 < args.count else {
                    print("Error: --pattern requires a value")
                    exit(2)
                }
                options.namingPattern = args[i + 1]
                i += 1
                
            case "-D", "--dry-run":
                options.dryRun = true
                
            case "-f", "--force":
                options.forceOverwrite = true
                
            default:
                if arg.hasPrefix("-") {
                    print("Error: Unknown option: \(arg)")
                    print("Use --help for usage information")
                    exit(2)
                } else {
                    // Positional arguments
                    if options.inputFile == nil {
                        options.inputFile = arg
                    } else if options.outputFile == nil {
                        options.outputFile = arg
                    } else {
                        print("Error: Too many arguments")
                        exit(2)
                    }
                }
            }
            i += 1
        }
        
        return options
    }
    
    static func validateArguments(_ options: ProcessingOptions) throws {
        // Input validation
        if options.inputFile == nil && !options.isStdinMode {
            throw PDF22PNGError.noInput
        }
        
        // Output validation for single page mode
        if !options.isBatchMode && options.outputFile == nil && options.outputPath == nil {
            throw PDF22PNGError.invalidArgs
        }
        
        // Scale validation
        if ScaleParser.parseScaleSpecification(options.effectiveScale) == nil {
            throw PDF22PNGError.invalidScale
        }
        
        // Quality validation (already handled in parsing)
        if options.quality < 0 || options.quality > 9 {
            throw PDF22PNGError.invalidArgs
        }
    }
}
</file>

<file path="CLI/OutputFormatter.swift">
import Foundation

// MARK: - Output Formatter

struct OutputFormatter {
    static func printHelp() {
        print("""
Usage: pdf22png [OPTIONS] <input.pdf> [output.png]
Converts PDF documents to PNG images.

Options:
  -p, --page <spec>       Page(s) to convert. Single page, range, or comma-separated.
                          Examples: 1 | 1-5 | 1,3,5-10 (default: 1)
                          In batch mode, only specified pages are converted.
  -a, --all               Convert all pages. If -d is not given, uses input filename as prefix.
                          Output files named <prefix>-<page_num>.png.
  -r, --resolution <dpi>  Set output DPI (e.g., 150dpi). Overrides -s if both used with numbers.
  -s, --scale <spec>      Scaling specification (default: 100% or 1.0).
                            NNN%: percentage (e.g., 150%)
                            N.N:  scale factor (e.g., 1.5)
                            WxH:  fit to WxH pixels (e.g., 800x600)
                            Wx:   fit to width W pixels (e.g., 1024x)
                            xH:   fit to height H pixels (e.g., x768)
  -t, --transparent       Preserve transparency (default: white background).
  -q, --quality <n>       PNG compression quality (0-9, default: 6). Currently informational.
  -o, --output <path>     Output PNG file or prefix for batch mode.
                          If '-', output to stdout (single page mode only).
  -d, --directory <dir>   Output directory for batch mode (converts all pages).
                          If used, -o specifies filename prefix inside this directory.
  -v, --verbose           Verbose output.
  -n, --name              Include extracted text in output filename (batch mode only).
  -P, --pattern <pat>     Custom naming pattern for batch mode. Placeholders:
                          {basename} - Input filename without extension
                          {page} - Page number (auto-padded)
                          {page:03d} - Page with custom padding
                          {text} - Extracted text (requires -n)
                          {date} - Current date (YYYYMMDD)
                          {time} - Current time (HHMMSS)
                          {total} - Total page count
                          Example: '{basename}_p{page:04d}_of_{total}'
  -D, --dry-run           Preview operations without writing files.
  -f, --force             Force overwrite existing files without prompting.
  -h, --help              Show this help message and exit.
  --version               Show version information and exit.

Arguments:
  <input.pdf>             Input PDF file. If '-', reads from stdin.
  [output.png]            Output PNG file. Required if not using -o or -d.
                          If input is stdin and output is not specified, output goes to stdout.
                          In batch mode (-a or -d), this is used as a prefix if -o is not set.

Examples:
  pdf22png document.pdf page1.png              # Convert first page
  pdf22png -p 5 document.pdf page5.png         # Convert page 5
  pdf22png -a document.pdf                     # Convert all pages (document-001.png, ...)
  pdf22png -r 300 document.pdf hi-res.png      # High resolution
  pdf22png -s 150% document.pdf large.png      # 1.5x scale
  pdf22png -d output/ document.pdf             # All pages to output/ directory
  pdf22png -t document.pdf transparent.png     # Preserve transparency
  cat document.pdf | pdf22png - output.png     # From stdin
""")
    }
    
    static func printVersion() {
        let version = "2.0.0-standalone"
        print("pdf22png \(version)")
        print("Swift standalone implementation")
    }
    
    static func formatError(_ error: PDF22PNGError, context: String? = nil) -> String {
        var output = "❌ Error: \(error.errorDescription ?? "Unknown error")"
        
        if let ctx = context {
            output += "\n📍 Context: \(ctx)"
        }
        
        if let suggestion = error.recoverySuggestion {
            output += "\n💡 Help: \(suggestion)"
        }
        
        return output
    }
    
    static func formatProgress(_ progress: ProgressInfo) -> String {
        let percentage = Int((Double(progress.completed) / Double(progress.total)) * 100)
        let progressBar = createProgressBar(percentage: percentage)
        
        var output = "\r\(progressBar) \(percentage)% (\(progress.completed)/\(progress.total))"
        
        if let speed = progress.speed {
            output += " - \(String(format: "%.1f", speed)) pages/sec"
        }
        
        if let eta = progress.estimatedTimeRemaining {
            output += " - ETA: \(formatDuration(eta))"
        }
        
        return output
    }
    
    static func formatResults(_ results: ProcessingResults) -> String {
        var output = "\n✅ Processing complete!\n"
        output += "   Total: \(results.totalPages) pages"
        
        if results.processingTime > 0 {
            output += " in \(formatDuration(results.processingTime))"
        }
        
        output += "\n   Results: ✓ \(results.successfulPages) successful"
        
        if results.failedPages > 0 {
            output += ", ✗ \(results.failedPages) failed"
        }
        
        if results.pagesPerSecond > 0 {
            output += "\n   Average speed: \(String(format: "%.1f", results.pagesPerSecond)) pages/sec"
        }
        
        return output
    }
    
    private static func createProgressBar(percentage: Int, width: Int = 20) -> String {
        let filled = Int(Double(percentage) / 100.0 * Double(width))
        let empty = width - filled
        return "[" + String(repeating: "█", count: filled) + String(repeating: "░", count: empty) + "]"
    }
    
    private static func formatDuration(_ seconds: TimeInterval) -> String {
        let minutes = Int(seconds) / 60
        let secs = Int(seconds) % 60
        if minutes > 0 {
            return "\(minutes)m \(secs)s"
        } else {
            return "\(secs)s"
        }
    }
}

// MARK: - Progress Info

struct ProgressInfo {
    let completed: Int
    let total: Int
    let speed: Double?
    let estimatedTimeRemaining: TimeInterval?
    let currentOperation: String?
}
</file>

<file path="Core/BatchProcessor.swift">
import Foundation
import CoreGraphics
import PDFKit

// MARK: - Batch Processing

class BatchProcessor {
    static let shared = BatchProcessor()
    private init() {}
    
    struct BatchOptions {
        let totalPages: Int
        let outputDirectory: String
        let prefix: String
        let scaleFactor: CGFloat
        let transparent: Bool
        let quality: Int
        let verbose: Bool
        let dryRun: Bool
        let forceOverwrite: Bool
    }
    
    struct BatchResult {
        let totalPages: Int
        let successfulPages: Int
        let failedPages: Int
        let interrupted: Bool
    }
    
    func processBatch(document: PDFDocument, options: BatchOptions) async throws -> BatchResult {
        let totalPages = options.totalPages
        
        // Create output directory
        if !options.dryRun {
            do {
                try FileManager.default.createDirectory(atPath: options.outputDirectory, withIntermediateDirectories: true, attributes: nil)
            } catch {
                throw PDF22PNGError.outputDir
            }
        }
        
        // Calculate optimal batch size based on memory
        guard let firstPage = document.page(at: 0) else {
            throw PDF22PNGError.renderFailed
        }
        
        let pageRect = firstPage.bounds(for: .mediaBox)
        let optimalBatchSize = MemoryManager.shared.calculateOptimalBatchSize(
            totalPages: totalPages,
            pageRect: pageRect,
            scaleFactor: options.scaleFactor,
            verbose: options.verbose
        )
        
        // Initialize progress reporter
        let progressReporter = ProgressReporter(totalPages: totalPages, verbose: options.verbose)
        
        if !options.dryRun {
            print("🚀 Starting batch conversion of \(totalPages) pages...")
            if options.verbose {
                print("   Output directory: \(options.outputDirectory)")
                print("   Output prefix: \(options.prefix)")
                print("   Batch size: \(optimalBatchSize) pages/chunk")
            }
        }
        
        // Process pages in memory-optimized chunks
        let chunks = stride(from: 1, through: totalPages, by: optimalBatchSize).map { start in
            Array(start..<min(start + optimalBatchSize, totalPages + 1))
        }
        
        var successfulPages = 0
        var failedPages = 0
        var interrupted = false
        
        for (chunkIndex, chunk) in chunks.enumerated() {
            // Check for interruption before each chunk
            do {
                try checkInterruption()
            } catch {
                interrupted = true
                break
            }
            
            // Check memory pressure before each chunk
            do {
                try MemoryManager.shared.checkMemoryPressureDuringBatch(verbose: options.verbose)
            } catch {
                // Continue processing even under memory pressure
            }
            
            progressReporter.reportChunkStart(chunkNumber: chunkIndex + 1, totalChunks: chunks.count, pagesInChunk: chunk.count)
            
            for pageNum in chunk {
                // Check for interruption for each page
                do {
                    try checkInterruption()
                } catch {
                    interrupted = true
                    break
                }
                
                progressReporter.reportPageStart(pageNumber: pageNum)
                
                guard let pdfPage = document.page(at: pageNum - 1) else {
                    progressReporter.reportPageComplete(pageNumber: pageNum, success: false)
                    failedPages += 1
                    continue
                }
                
                let renderOptions = ImageRenderer.RenderOptions(
                    scaleFactor: options.scaleFactor,
                    transparentBackground: options.transparent,
                    quality: options.quality,
                    verbose: options.verbose,
                    dryRun: options.dryRun,
                    forceOverwrite: options.forceOverwrite
                )
                
                guard let image = ImageRenderer.shared.renderPageToImage(page: pdfPage, options: renderOptions) else {
                    progressReporter.reportPageComplete(pageNumber: pageNum, success: false)
                    failedPages += 1
                    continue
                }
                
                let filename = String(format: "%@-%03d.png", options.prefix, pageNum)
                let outputPath = (options.outputDirectory as NSString).appendingPathComponent(filename)
                
                if options.dryRun {
                    print("[DRY-RUN] Would create: \(filename) (\(image.width)x\(image.height) pixels)")
                    progressReporter.reportPageComplete(pageNumber: pageNum, success: true, outputFile: filename)
                    successfulPages += 1
                } else {
                    let success = ImageRenderer.shared.writeImageToFile(image: image, path: outputPath, options: renderOptions)
                    progressReporter.reportPageComplete(pageNumber: pageNum, success: success, outputFile: success ? filename : nil)
                    if success {
                        successfulPages += 1
                    } else {
                        failedPages += 1
                    }
                }
            }
            
            // Log memory status after each chunk in verbose mode
            if options.verbose && chunks.count > 1 {
                MemoryManager.shared.logMemoryStatus(verbose: true)
            }
            
            if interrupted {
                progressReporter.reportInterrupted()
                break
            }
        }
        
        // Final status report
        if options.dryRun && !interrupted {
            print("\n[DRY-RUN] Would convert \(totalPages) pages to PNG files")
        } else if !interrupted {
            progressReporter.reportBatchComplete()
        }
        
        return BatchResult(
            totalPages: totalPages,
            successfulPages: successfulPages,
            failedPages: failedPages,
            interrupted: interrupted
        )
    }
    
    func calculateOptimalConcurrency(pages: Int, memoryRequirement: UInt64) -> Int {
        let memInfo = MemoryManager.shared.getSystemMemoryInfo()
        let availableMemory = memInfo.available / 2 // Use only half of available memory
        let maxConcurrentPages = max(1, Int(availableMemory / memoryRequirement))
        return min(pages, maxConcurrentPages)
    }
}
</file>

<file path="Core/ImageRenderer.swift">
import Foundation
import CoreGraphics
import PDFKit
import UniformTypeIdentifiers

// MARK: - Image Rendering

class ImageRenderer {
    static let shared = ImageRenderer()
    private init() {}
    
    struct RenderOptions {
        let scaleFactor: CGFloat
        let transparentBackground: Bool
        let quality: Int
        let verbose: Bool
        let dryRun: Bool
        let forceOverwrite: Bool
    }
    
    func renderPageToImage(page: PDFPage, options: RenderOptions) -> CGImage? {
        let pageRect = page.bounds(for: .mediaBox)
        let scaledWidth = Int(pageRect.width * options.scaleFactor)
        let scaledHeight = Int(pageRect.height * options.scaleFactor)
        
        logMessage(options.verbose, "Rendering page at \(scaledWidth)x\(scaledHeight) (scale: \(options.scaleFactor))")
        
        let colorSpace = CGColorSpaceCreateDeviceRGB()
        let bitmapInfo: CGBitmapInfo = options.transparentBackground ? 
            [.byteOrder32Big, CGBitmapInfo(rawValue: CGImageAlphaInfo.premultipliedLast.rawValue)] :
            [.byteOrder32Big, CGBitmapInfo(rawValue: CGImageAlphaInfo.noneSkipLast.rawValue)]
        
        guard let context = CGContext(
            data: nil,
            width: scaledWidth,
            height: scaledHeight,
            bitsPerComponent: 8,
            bytesPerRow: 0,
            space: colorSpace,
            bitmapInfo: bitmapInfo.rawValue
        ) else {
            return nil
        }
        
        context.scaleBy(x: options.scaleFactor, y: options.scaleFactor)
        
        if !options.transparentBackground {
            context.setFillColor(CGColor.white)
            context.fill(CGRect(x: 0, y: 0, width: pageRect.width, height: pageRect.height))
        }
        
        page.draw(with: .mediaBox, to: context)
        
        return context.makeImage()
    }
    
    func writeImageToFile(image: CGImage, path: String, options: RenderOptions) -> Bool {
        if options.dryRun {
            let width = image.width
            let height = image.height
            print("[DRY-RUN] Would write \(width)x\(height) PNG to: \(path)")
            return true
        }
        
        // Check if file exists and handle overwrite
        if FileManager.default.fileExists(atPath: path) && !options.forceOverwrite {
            print("File \(path) already exists. Use --force to overwrite.")
            return false
        }
        
        let url = URL(fileURLWithPath: path)
        guard let destination = CGImageDestinationCreateWithURL(url as CFURL, UTType.png.identifier as CFString, 1, nil) else {
            return false
        }
        
        let compressionOptions: [CFString: Any] = [
            kCGImageDestinationLossyCompressionQuality: CGFloat(options.quality) / 9.0
        ]
        
        CGImageDestinationAddImage(destination, image, compressionOptions as CFDictionary)
        let success = CGImageDestinationFinalize(destination)
        
        if success {
            logMessage(options.verbose, "Successfully wrote PNG to: \(path)")
        }
        
        return success
    }
    
    func writeImageToStdout(image: CGImage, options: RenderOptions) -> Bool {
        logMessage(options.verbose, "Writing PNG to stdout")
        
        let data = NSMutableData()
        guard let destination = CGImageDestinationCreateWithData(data, UTType.png.identifier as CFString, 1, nil) else {
            return false
        }
        
        let compressionOptions: [CFString: Any] = [
            kCGImageDestinationLossyCompressionQuality: CGFloat(options.quality) / 9.0
        ]
        
        CGImageDestinationAddImage(destination, image, compressionOptions as CFDictionary)
        guard CGImageDestinationFinalize(destination) else {
            return false
        }
        
        let stdout = FileHandle.standardOutput
        stdout.write(data as Data)
        return true
    }
    
    func calculateScaleFactor(spec: ScaleSpecification, pageRect: CGRect) -> CGFloat {
        switch spec {
        case .percentage(let percent):
            return percent / 100.0
        case .factor(let factor):
            return factor
        case .resolution(let dpi):
            return dpi / 72.0  // 72 DPI is the default PDF resolution
        case .width(let width):
            return width / pageRect.width
        case .height(let height):
            return height / pageRect.height
        case .fit(let width, let height):
            let scaleX = width / pageRect.width
            let scaleY = height / pageRect.height
            return min(scaleX, scaleY)
        }
    }
}
</file>

<file path="Core/MemoryManager.swift">
import Foundation
import Darwin.Mach

// MARK: - Memory Management System

class MemoryManager {
    static let shared = MemoryManager()
    private init() {}
    
    // System memory thresholds (in bytes)
    private let lowMemoryThreshold: UInt64 = 512 * 1024 * 1024    // 512MB
    private let criticalMemoryThreshold: UInt64 = 256 * 1024 * 1024 // 256MB
    private let maxMemoryUsage: UInt64 = 2 * 1024 * 1024 * 1024    // 2GB
    
    func getSystemMemoryInfo() -> (total: UInt64, available: UInt64, used: UInt64) {
        var size = MemoryLayout<vm_size_t>.size
        var physicalMemory: vm_size_t = 0
        sysctlbyname("hw.memsize", &physicalMemory, &size, nil, 0)
        
        var info = mach_task_basic_info()
        var count = mach_msg_type_number_t(MemoryLayout<mach_task_basic_info>.size)/4
        
        let kr = withUnsafeMutablePointer(to: &info) {
            $0.withMemoryRebound(to: integer_t.self, capacity: 1) {
                task_info(mach_task_self_, task_flavor_t(MACH_TASK_BASIC_INFO), $0, &count)
            }
        }
        
        let used = UInt64(kr == KERN_SUCCESS ? info.resident_size : 0)
        let total = UInt64(physicalMemory)
        let available = total > used ? total - used : 0
        
        return (total: total, available: available, used: used)
    }
    
    func isMemoryPressureHigh() -> Bool {
        let memInfo = getSystemMemoryInfo()
        return memInfo.available < lowMemoryThreshold
    }
    
    func isMemoryPressureCritical() -> Bool {
        let memInfo = getSystemMemoryInfo()
        return memInfo.available < criticalMemoryThreshold
    }
    
    func estimateMemoryRequirement(pageRect: CGRect, scaleFactor: CGFloat, transparentBackground: Bool) -> UInt64 {
        let scaledWidth = pageRect.width * scaleFactor
        let scaledHeight = pageRect.height * scaleFactor
        let pixelCount = scaledWidth * scaledHeight
        
        // 4 bytes per pixel (RGBA), plus overhead
        let baseMemory = UInt64(pixelCount * 4)
        
        // Add overhead for Core Graphics contexts and intermediate buffers
        let overhead = baseMemory / 4
        
        // Transparent backgrounds require more memory
        let transparencyMultiplier: CGFloat = transparentBackground ? 1.5 : 1.0
        
        return UInt64(CGFloat(baseMemory + overhead) * transparencyMultiplier)
    }
    
    func canAllocateMemory(_ requiredMemory: UInt64, verbose: Bool) -> Bool {
        let memInfo = getSystemMemoryInfo()
        let canAllocate = memInfo.available > requiredMemory + criticalMemoryThreshold
        
        if verbose {
            let availableMB = memInfo.available / (1024 * 1024)
            let requiredMB = requiredMemory / (1024 * 1024)
            logMessage(true, "Memory check: Available \(availableMB)MB, Required \(requiredMB)MB")
        }
        
        return canAllocate
    }
    
    func calculateOptimalBatchSize(totalPages: Int, pageRect: CGRect, scaleFactor: CGFloat, verbose: Bool) -> Int {
        let memoryPerPage = estimateMemoryRequirement(pageRect: pageRect, scaleFactor: scaleFactor, transparentBackground: false)
        let memInfo = getSystemMemoryInfo()
        let availableForBatch = memInfo.available / 2 // Use only half of available memory
        
        let optimalBatchSize = max(1, min(totalPages, Int(availableForBatch / memoryPerPage)))
        
        if verbose {
            let batchMemoryMB = (UInt64(optimalBatchSize) * memoryPerPage) / (1024 * 1024)
            logMessage(true, "Optimal batch size: \(optimalBatchSize) pages (\(batchMemoryMB)MB estimated)")
        }
        
        return optimalBatchSize
    }
    
    func logMemoryStatus(verbose: Bool) {
        if !verbose { return }
        
        let memInfo = getSystemMemoryInfo()
        let totalGB = Double(memInfo.total) / (1024 * 1024 * 1024)
        let availableMB = memInfo.available / (1024 * 1024)
        let usedMB = memInfo.used / (1024 * 1024)
        
        logMessage(true, String(format: "Memory status: %.1fGB total, %lluMB used, %lluMB available", 
                              totalGB, usedMB, availableMB))
        
        if isMemoryPressureCritical() {
            print("⚠️  Critical memory pressure detected!")
        } else if isMemoryPressureHigh() {
            print("⚠️  High memory pressure detected")
        }
    }
    
    func checkMemoryPressureDuringBatch(verbose: Bool) throws {
        if isMemoryPressureCritical() {
            throw PDF22PNGError.memory
        }
        
        if isMemoryPressureHigh() && verbose {
            print("⚠️  High memory pressure - consider reducing batch size")
        }
    }
}

// Helper function for logging (to be defined elsewhere)
func logMessage(_ verbose: Bool, _ message: String) {
    if verbose {
        fputs("[\(DateFormatter.logFormat.string(from: Date()))] \(message)\n", stderr)
    }
}

extension DateFormatter {
    static let logFormat: DateFormatter = {
        let formatter = DateFormatter()
        formatter.dateFormat = "yyyy-MM-dd HH:mm:ss"
        return formatter
    }()
}
</file>

<file path="Core/PDFProcessor.swift">
import Foundation
import CoreGraphics
import PDFKit
import UniformTypeIdentifiers

// MARK: - PDF Processing

class PDFProcessor {
    static let shared = PDFProcessor()
    private init() {}
    
    func readPDFData(_ inputPath: String?, verbose: Bool) -> Data? {
        if let path = inputPath, path != "-" {
            logMessage(verbose, "Reading PDF from file: \(path)")
            return FileManager.default.contents(atPath: path)
        } else {
            logMessage(verbose, "Reading PDF from stdin")
            let stdin = FileHandle.standardInput
            return stdin.readDataToEndOfFile()
        }
    }
    
    func createPDFDocument(from data: Data) -> PDFDocument? {
        return PDFDocument(data: data)
    }
    
    func validatePDF(_ document: PDFDocument) -> Bool {
        return document.pageCount > 0
    }
    
    func getPageCount(_ document: PDFDocument) -> Int {
        return document.pageCount
    }
    
    func extractPage(_ document: PDFDocument, pageNumber: Int) -> PDFPage? {
        guard pageNumber > 0 && pageNumber <= document.pageCount else {
            return nil
        }
        return document.page(at: pageNumber - 1) // Convert to 0-based index
    }
}
</file>

<file path="Core/ResourceManager.swift">
import Foundation

// MARK: - Resource Management System

class ResourceManager {
    static let shared = ResourceManager()
    private init() {}
    
    private var tempFiles: Set<String> = []
    private var fileHandles: Set<ObjectIdentifier> = []
    private let resourceQueue = DispatchQueue(label: "resource.management", qos: .utility)
    
    func registerTempFile(_ path: String) {
        resourceQueue.sync {
            _ = tempFiles.insert(path)
        }
    }
    
    func unregisterTempFile(_ path: String) {
        resourceQueue.sync {
            _ = tempFiles.remove(path)
        }
    }
    
    func registerFileHandle(_ handle: FileHandle) {
        resourceQueue.sync {
            _ = fileHandles.insert(ObjectIdentifier(handle))
        }
    }
    
    func unregisterFileHandle(_ handle: FileHandle) {
        resourceQueue.sync {
            _ = fileHandles.remove(ObjectIdentifier(handle))
        }
    }
    
    func cleanupAllResources() {
        resourceQueue.sync {
            // Clean up temporary files
            for tempFile in tempFiles {
                do {
                    if FileManager.default.fileExists(atPath: tempFile) {
                        try FileManager.default.removeItem(atPath: tempFile)
                    }
                } catch {
                    // Ignore cleanup errors
                }
            }
            tempFiles.removeAll()
            
            // Clear file handle tracking
            fileHandles.removeAll()
        }
    }
    
    func createSecureTempFile(prefix: String = "pdf22png", suffix: String = ".tmp") -> String? {
        let tempDir = NSTemporaryDirectory()
        let tempFileName = "\(prefix)_\(UUID().uuidString)\(suffix)"
        let tempPath = (tempDir as NSString).appendingPathComponent(tempFileName)
        
        // Create the file with secure permissions (600)
        let success = FileManager.default.createFile(atPath: tempPath, contents: nil, attributes: [
            .posixPermissions: 0o600
        ])
        
        if success {
            registerTempFile(tempPath)
            return tempPath
        }
        
        return nil
    }
}
</file>

<file path="Core/SignalHandler.swift">
import Foundation

// MARK: - Enhanced Signal Handling

class SignalHandler {
    static let shared = SignalHandler()
    private init() {}
    
    private var shouldTerminate = false
    private var cleanupHandlers: [() -> Void] = []
    private let signalQueue = DispatchQueue(label: "signal.handling", qos: .utility)
    
    var isTerminated: Bool {
        return shouldTerminate
    }
    
    func installSignalHandlers() {
        // Handle SIGINT (Ctrl+C)
        signal(SIGINT) { _ in
            SignalHandler.shared.handleGracefulShutdown(signal: "SIGINT")
        }
        
        // Handle SIGTERM (termination request)
        signal(SIGTERM) { _ in
            SignalHandler.shared.handleGracefulShutdown(signal: "SIGTERM")
        }
        
        // Handle SIGHUP (hangup)
        signal(SIGHUP) { _ in
            SignalHandler.shared.handleGracefulShutdown(signal: "SIGHUP")
        }
    }
    
    private func handleGracefulShutdown(signal: String) {
        shouldTerminate = true
        
        fputs("\n📡 Received \(signal), initiating graceful shutdown...\n", stderr)
        fflush(stderr)
        
        // Perform cleanup on a separate queue to avoid deadlocks
        signalQueue.async {
            self.performCleanup()
            
            // Give a brief moment for current operations to finish
            usleep(100_000) // 100ms
            
            fputs("✅ Cleanup complete. Exiting.\n", stderr)
            fflush(stderr)
            exit(1)
        }
    }
    
    private func performCleanup() {
        // Execute registered cleanup handlers
        for handler in cleanupHandlers {
            handler()
        }
        cleanupHandlers.removeAll()
        
        // Clean up resources
        ResourceManager.shared.cleanupAllResources()
    }
    
    func registerCleanupHandler(_ handler: @escaping () -> Void) {
        cleanupHandlers.append(handler)
    }
    
    func checkInterruption() throws {
        if shouldTerminate {
            throw PDF22PNGError.signalInterruption
        }
    }
}
</file>

<file path="Models/Errors.swift">
import Foundation

// MARK: - Error Types

enum PDF22PNGError: Int, Error, LocalizedError {
    case success = 0
    case generalError = 1
    case invalidArgs = 2
    case fileNotFound = 3
    case fileRead = 4
    case fileWrite = 5
    case noInput = 6
    case invalidPDF = 7
    case encryptedPDF = 8
    case emptyPDF = 9
    case pageNotFound = 10
    case renderFailed = 11
    case memory = 12
    case outputDir = 13
    case invalidScale = 14
    case batchFailed = 15
    case signalInterruption = 16
    
    var errorDescription: String? {
        switch self {
        case .success: return "Success"
        case .generalError: return "General error occurred"
        case .invalidArgs: return "Invalid command line arguments"
        case .fileNotFound: return "Input file not found"
        case .fileRead: return "Failed to read input file"
        case .fileWrite: return "Failed to write output file"
        case .noInput: return "No input data received"
        case .invalidPDF: return "Invalid PDF document"
        case .encryptedPDF: return "PDF document is encrypted"
        case .emptyPDF: return "PDF document has no pages"
        case .pageNotFound: return "Requested page does not exist"
        case .renderFailed: return "Failed to render PDF page"
        case .memory: return "Memory allocation failed"
        case .outputDir: return "Failed to create output directory"
        case .invalidScale: return "Invalid scale specification"
        case .batchFailed: return "Batch processing failed"
        case .signalInterruption: return "Operation interrupted by system signal"
        }
    }
    
    var recoverySuggestion: String? {
        switch self {
        case .invalidArgs:
            return "Check command syntax with --help flag. Verify all arguments are correct and use absolute paths."
        case .fileNotFound, .fileRead:
            return "Verify the file path is correct, the file exists, and you have read permissions."
        case .fileWrite:
            return "Check available disk space and write permissions to the output directory."
        case .invalidScale:
            return "Use valid formats: 150%, 2.0, 800x600, or 300dpi."
        case .pageNotFound:
            return "PDF pages start at 1. Use --verbose to see total page count."
        case .memory:
            return "Close other applications, use smaller scale factor, or process fewer pages at once."
        case .encryptedPDF:
            return "Remove password protection using Preview or qpdf command-line tool."
        default:
            return "Run with --verbose flag for detailed information. Check --help for usage examples."
        }
    }
}

struct ErrorReporter {
    static func reportError(_ error: PDF22PNGError, context: String? = nil) {
        print("❌ Error: \(error.errorDescription ?? "Unknown error")")
        
        if let ctx = context {
            print("📍 Context: \(ctx)")
        }
        
        if let suggestion = error.recoverySuggestion {
            print("\n💡 Help: \(suggestion)")
        }
        
        // Provide specific troubleshooting based on error type
        switch error {
        case .invalidArgs:
            print("\n💡 Input Validation Help:")
            print("   • Check command syntax with --help flag")
            print("   • Verify all arguments are correct")
            print("   • Use absolute paths to avoid confusion")
            
        case .fileNotFound:
            print("\n💡 File Access Help:")
            print("   • Verify the file path is correct and the file exists")
            print("   • Use absolute paths to avoid confusion")
            print("   • Check file permissions with 'ls -la'")
            
        case .fileRead:
            print("\n💡 File Access Help:")
            print("   • Check file permissions with 'ls -la'")
            print("   • Ensure you have read access to the file")
            print("   • Verify file is not corrupted")
            
        case .fileWrite:
            print("\n💡 File Write Help:")
            print("   • Check available disk space with 'df -h'")
            print("   • Verify write permissions to output directory")
            print("   • Try a different output location")
            
        case .invalidScale:
            print("\n💡 Scale Format Help:")
            print("   • Valid formats: 150%, 2.0, 800x600, 300dpi")
            print("   • Percentage: append % (e.g., 150%)")
            print("   • Factor: decimal number (e.g., 1.5)")
            print("   • Dimensions: WIDTHxHEIGHT (e.g., 1024x768)")
            
        case .pageNotFound:
            print("\n💡 Page Range Help:")
            print("   • PDF pages start at 1, not 0")
            print("   • Use --verbose to see total page count")
            print("   • Valid formats: 5 (single), 1-10 (range)")
            
        case .memory:
            print("\n💡 Memory Help:")
            print("   • Close other applications to free RAM")
            print("   • Use smaller scale factor: --scale 50%")
            print("   • Process fewer pages at once")
            
        case .encryptedPDF:
            print("\n💡 Encrypted PDF Help:")
            print("   • Remove password protection:")
            print("     - In Preview: File → Export As → PDF (uncheck Encrypt)")
            print("     - Command line: qpdf --decrypt --password=PASSWORD input.pdf output.pdf")
            
        default:
            print("\n💡 General Help:")
            print("   • Run with --verbose flag for detailed information")
            print("   • Check --help for usage examples")
            print("   • Try with a simpler PDF first")
        }
    }
}
</file>

<file path="Models/ProcessingOptions.swift">
import Foundation

// MARK: - Processing Options

struct ProcessingOptions {
    var inputFile: String?
    var outputFile: String?
    var page: String = "1"
    var allPages: Bool = false
    var resolution: String?
    var scale: String = "100%"
    var transparent: Bool = false
    var quality: Int = 6
    var outputPath: String?
    var directory: String?
    var verbose: Bool = false
    var includeText: Bool = false
    var namingPattern: String?
    var dryRun: Bool = false
    var forceOverwrite: Bool = false
    var showHelp: Bool = false
    var showVersion: Bool = false
    
    // Computed properties
    var effectiveScale: String {
        return resolution ?? scale
    }
    
    var effectiveOutputDirectory: String {
        return directory ?? "."
    }
    
    var isBatchMode: Bool {
        return allPages
    }
    
    var isStdoutMode: Bool {
        return outputPath == "-" || outputFile == "-"
    }
    
    var isStdinMode: Bool {
        return inputFile == "-" || inputFile == nil
    }
}
</file>

<file path="Models/Results.swift">
import Foundation

// MARK: - Result Types

struct ProcessingResults {
    let totalPages: Int
    let successfulPages: Int
    let failedPages: Int
    let interrupted: Bool
    let processingTime: TimeInterval
    let outputFiles: [String]
    
    var successRate: Double {
        guard totalPages > 0 else { return 0.0 }
        return Double(successfulPages) / Double(totalPages)
    }
    
    var pagesPerSecond: Double {
        guard processingTime > 0 else { return 0.0 }
        return Double(successfulPages) / processingTime
    }
    
    var isSuccessful: Bool {
        return failedPages == 0 && !interrupted
    }
}

struct PageResult {
    let pageNumber: Int
    let success: Bool
    let outputFile: String?
    let processingTime: TimeInterval
    let errorMessage: String?
    
    init(pageNumber: Int, success: Bool, outputFile: String? = nil, processingTime: TimeInterval = 0, error: Error? = nil) {
        self.pageNumber = pageNumber
        self.success = success
        self.outputFile = outputFile
        self.processingTime = processingTime
        self.errorMessage = error?.localizedDescription
    }
}

struct BatchResult {
    let totalPages: Int
    let successfulPages: Int
    let failedPages: Int
    let interrupted: Bool
    let processingTime: TimeInterval
    let pageResults: [PageResult]
    
    var processingResults: ProcessingResults {
        let outputFiles = pageResults.compactMap { $0.outputFile }
        return ProcessingResults(
            totalPages: totalPages,
            successfulPages: successfulPages,
            failedPages: failedPages,
            interrupted: interrupted,
            processingTime: processingTime,
            outputFiles: outputFiles
        )
    }
    
    init(totalPages: Int, successfulPages: Int, failedPages: Int, interrupted: Bool, processingTime: TimeInterval = 0, pageResults: [PageResult] = []) {
        self.totalPages = totalPages
        self.successfulPages = successfulPages
        self.failedPages = failedPages
        self.interrupted = interrupted
        self.processingTime = processingTime
        self.pageResults = pageResults
    }
}
</file>

<file path="Models/ScaleSpecification.swift">
import Foundation
import CoreGraphics

// MARK: - Scale Specification

enum ScaleSpecification {
    case percentage(CGFloat)
    case factor(CGFloat)
    case resolution(CGFloat)  // DPI
    case width(CGFloat)
    case height(CGFloat)
    case fit(width: CGFloat, height: CGFloat)
}

struct ScaleParser {
    static func parseScaleSpecification(_ scaleStr: String) -> ScaleSpecification? {
        let trimmed = scaleStr.trimmingCharacters(in: .whitespaces)
        
        if trimmed.hasSuffix("%") {
            let percentStr = String(trimmed.dropLast())
            guard let percent = Double(percentStr), percent > 0 else { return nil }
            return .percentage(CGFloat(percent))
        }
        
        if trimmed.hasSuffix("dpi") {
            let dpiStr = String(trimmed.dropLast(3))
            guard let dpi = Double(dpiStr), dpi > 0 else { return nil }
            return .resolution(CGFloat(dpi))
        }
        
        if trimmed.contains("x") {
            let parts = trimmed.components(separatedBy: "x")
            guard parts.count == 2 else { return nil }
            
            let widthStr = parts[0]
            let heightStr = parts[1]
            
            if !widthStr.isEmpty && !heightStr.isEmpty {
                guard let width = Double(widthStr), width > 0,
                      let height = Double(heightStr), height > 0 else { return nil }
                return .fit(width: CGFloat(width), height: CGFloat(height))
            } else if !widthStr.isEmpty {
                guard let width = Double(widthStr), width > 0 else { return nil }
                return .width(CGFloat(width))
            } else if !heightStr.isEmpty {
                guard let height = Double(heightStr), height > 0 else { return nil }
                return .height(CGFloat(height))
            }
            
            return nil
        }
        
        guard let factor = Double(trimmed), factor > 0 else { return nil }
        return .factor(CGFloat(factor))
    }
}
</file>

<file path="Utilities/InputValidator.swift">
import Foundation

// MARK: - Input Validation

class InputValidator {
    static let maxFileSize: UInt64 = 500 * 1024 * 1024 // 500MB
    static let maxPageNumber: Int = 10000
    static let maxTotalPages: Int = 5000
    static let maxPathLength: Int = 1024
    
    static func validateFilePath(_ path: String, allowCreate: Bool = false) throws -> String {
        // Check path length
        guard path.count <= maxPathLength else {
            throw PDF22PNGError.invalidArgs
        }
        
        // Prevent path traversal attacks
        let normalizedPath = (path as NSString).standardizingPath
        guard !normalizedPath.contains("../") && !normalizedPath.contains("..\\") else {
            throw PDF22PNGError.invalidArgs
        }
        
        // Check for null bytes and other dangerous characters
        guard !path.contains("\0") && !path.contains("\n") && !path.contains("\r") else {
            throw PDF22PNGError.invalidArgs
        }
        
        if !allowCreate {
            // For input files, check existence and size
            guard FileManager.default.fileExists(atPath: normalizedPath) else {
                throw PDF22PNGError.fileNotFound
            }
            
            do {
                let attributes = try FileManager.default.attributesOfItem(atPath: normalizedPath)
                if let fileSize = attributes[.size] as? UInt64, fileSize > maxFileSize {
                    throw PDF22PNGError.invalidArgs
                }
            } catch {
                throw PDF22PNGError.fileRead
            }
        }
        
        return normalizedPath
    }
    
    static func validateOutputDirectory(_ path: String) throws -> String {
        let normalizedPath = try validateFilePath(path, allowCreate: true)
        
        // Check if parent directory exists and is writable
        let parentDir = (normalizedPath as NSString).deletingLastPathComponent
        guard FileManager.default.fileExists(atPath: parentDir) else {
            throw PDF22PNGError.outputDir
        }
        
        guard FileManager.default.isWritableFile(atPath: parentDir) else {
            throw PDF22PNGError.fileWrite
        }
        
        return normalizedPath
    }
    
    static func validatePageNumber(_ page: Int, totalPages: Int) throws {
        guard page >= 1 && page <= totalPages else {
            throw PDF22PNGError.pageNotFound
        }
        
        guard page <= maxPageNumber else {
            throw PDF22PNGError.invalidArgs
        }
    }
    
    static func validatePageRange(_ range: String, totalPages: Int) throws {
        // Basic validation of page range format
        let validChars = CharacterSet(charactersIn: "0123456789,-")
        guard range.rangeOfCharacter(from: validChars.inverted) == nil else {
            throw PDF22PNGError.invalidArgs
        }
        
        // Check for reasonable range limits
        let components = range.components(separatedBy: CharacterSet(charactersIn: ",-"))
        for component in components {
            if let pageNum = Int(component.trimmingCharacters(in: .whitespaces)) {
                try validatePageNumber(pageNum, totalPages: totalPages)
            }
        }
    }
    
    static func validateScale(_ scale: String) throws {
        guard scale.count <= 20 else { // Reasonable limit for scale specification
            throw PDF22PNGError.invalidScale
        }
        
        // Check for basic format validity
        let validChars = CharacterSet(charactersIn: "0123456789.%xdpi")
        guard scale.rangeOfCharacter(from: validChars.inverted) == nil else {
            throw PDF22PNGError.invalidScale
        }
    }
    
    static func validateQuality(_ quality: Int) throws {
        guard quality >= 0 && quality <= 9 else {
            throw PDF22PNGError.invalidArgs
        }
    }
    
    static func validateNamingPattern(_ pattern: String) throws {
        guard pattern.count <= 200 else { // Reasonable pattern length
            throw PDF22PNGError.invalidArgs
        }
        
        // Check for potentially dangerous pattern elements
        guard !pattern.contains("../") && !pattern.contains("..\\") && !pattern.contains("\0") else {
            throw PDF22PNGError.invalidArgs
        }
    }
}
</file>

<file path="Utilities/ProgressReporter.swift">
import Foundation

// MARK: - Progress Reporter

class ProgressReporter {
    private let totalPages: Int
    private var startTime: Date
    private var processedPages: Int = 0
    private var successfulPages: Int = 0
    private var failedPages: Int = 0
    private var lastReportTime: Date
    private let reportInterval: TimeInterval = 1.0 // Report at most once per second
    private let verbose: Bool
    
    init(totalPages: Int, verbose: Bool = false) {
        self.totalPages = totalPages
        self.verbose = verbose
        self.startTime = Date()
        self.lastReportTime = Date()
    }
    
    func reportPageStart(pageNumber: Int) {
        if verbose {
            print("Processing page \(pageNumber)/\(totalPages)...")
        }
    }
    
    func reportPageComplete(pageNumber: Int, success: Bool, outputFile: String? = nil) {
        processedPages += 1
        if success {
            successfulPages += 1
            if let outputFile = outputFile, !verbose {
                // For non-verbose mode, show successful outputs
                print("✓ Page \(pageNumber) → \(outputFile)")
            }
        } else {
            failedPages += 1
            print("✗ Page \(pageNumber) failed")
        }
        
        // Report progress if enough time has passed or we're at a milestone
        let now = Date()
        let shouldReportTime = now.timeIntervalSince(lastReportTime) >= reportInterval
        let shouldReportMilestone = processedPages % 10 == 0 || processedPages == totalPages
        
        if shouldReportTime || shouldReportMilestone {
            reportProgress()
            lastReportTime = now
        }
    }
    
    func reportChunkStart(chunkNumber: Int, totalChunks: Int, pagesInChunk: Int) {
        if verbose {
            print("\n📦 Processing chunk \(chunkNumber)/\(totalChunks) (\(pagesInChunk) pages)")
        }
    }
    
    private func reportProgress() {
        let percentage = (processedPages * 100) / totalPages
        let elapsed = Date().timeIntervalSince(startTime)
        let pagesPerSecond = elapsed > 0 ? Double(processedPages) / elapsed : 0
        let estimatedTotal = pagesPerSecond > 0 ? Double(totalPages) / pagesPerSecond : 0
        let estimatedRemaining = max(0, estimatedTotal - elapsed)
        
        var progressBar = "["
        let barWidth = 30
        let filledWidth = (barWidth * processedPages) / totalPages
        progressBar += String(repeating: "■", count: filledWidth)
        progressBar += String(repeating: "□", count: barWidth - filledWidth)
        progressBar += "]"
        
        print("\n📊 Progress: \(progressBar) \(percentage)%")
        print("   Processed: \(processedPages)/\(totalPages) pages (✓ \(successfulPages), ✗ \(failedPages))")
        
        if pagesPerSecond > 0 {
            print("   Speed: \(String(format: "%.1f", pagesPerSecond)) pages/sec")
            print("   Time: \(formatDuration(elapsed)) elapsed, ~\(formatDuration(estimatedRemaining)) remaining")
        }
        
        // Memory status in verbose mode
        if verbose {
            let memInfo = MemoryManager.shared.getSystemMemoryInfo()
            let usedGB = Double(memInfo.used) / (1024 * 1024 * 1024)
            let availableGB = Double(memInfo.available) / (1024 * 1024 * 1024)
            print("   Memory: \(String(format: "%.1f", usedGB))GB used, \(String(format: "%.1f", availableGB))GB available")
        }
    }
    
    func reportBatchComplete() {
        let elapsed = Date().timeIntervalSince(startTime)
        let pagesPerSecond = elapsed > 0 ? Double(processedPages) / elapsed : 0
        
        print("\n✅ Batch processing complete!")
        print("   Total: \(processedPages) pages processed in \(formatDuration(elapsed))")
        print("   Results: ✓ \(successfulPages) successful, ✗ \(failedPages) failed")
        if pagesPerSecond > 0 {
            print("   Average speed: \(String(format: "%.1f", pagesPerSecond)) pages/sec")
        }
    }
    
    func reportInterrupted() {
        print("\n⚠️  Processing interrupted!")
        print("   Completed: \(processedPages)/\(totalPages) pages")
        print("   Results: ✓ \(successfulPages) successful, ✗ \(failedPages) failed")
    }
    
    private func formatDuration(_ seconds: TimeInterval) -> String {
        let minutes = Int(seconds) / 60
        let secs = Int(seconds) % 60
        if minutes > 0 {
            return "\(minutes)m \(secs)s"
        } else {
            return "\(secs)s"
        }
    }
    
    // Progress info for external consumption
    func getCurrentProgress() -> ProgressInfo {
        let elapsed = Date().timeIntervalSince(startTime)
        let pagesPerSecond = elapsed > 0 ? Double(processedPages) / elapsed : 0
        let estimatedTotal = pagesPerSecond > 0 ? Double(totalPages) / pagesPerSecond : 0
        let estimatedRemaining = max(0, estimatedTotal - elapsed)
        
        return ProgressInfo(
            completed: processedPages,
            total: totalPages,
            speed: pagesPerSecond > 0 ? pagesPerSecond : nil,
            estimatedTimeRemaining: estimatedRemaining > 0 ? estimatedRemaining : nil,
            currentOperation: nil
        )
    }
}
</file>

<file path="main_old.swift">
#!/usr/bin/env swift

import Foundation
import CoreGraphics
import Quartz
import ImageIO
import PDFKit
import UniformTypeIdentifiers

// MARK: - Memory Management System

class MemoryManager {
    static let shared = MemoryManager()
    private init() {}
    
    // System memory thresholds (in bytes)
    private let lowMemoryThreshold: UInt64 = 512 * 1024 * 1024    // 512MB
    private let criticalMemoryThreshold: UInt64 = 256 * 1024 * 1024 // 256MB
    private let maxMemoryUsage: UInt64 = 2 * 1024 * 1024 * 1024    // 2GB
    
    func getSystemMemoryInfo() -> (total: UInt64, available: UInt64, used: UInt64) {
        var size = MemoryLayout<vm_size_t>.size
        var physicalMemory: vm_size_t = 0
        sysctlbyname("hw.memsize", &physicalMemory, &size, nil, 0)
        
        var info = mach_task_basic_info()
        var count = mach_msg_type_number_t(MemoryLayout<mach_task_basic_info>.size)/4
        
        let kr = withUnsafeMutablePointer(to: &info) {
            $0.withMemoryRebound(to: integer_t.self, capacity: 1) {
                task_info(mach_task_self_, task_flavor_t(MACH_TASK_BASIC_INFO), $0, &count)
            }
        }
        
        let used = UInt64(kr == KERN_SUCCESS ? info.resident_size : 0)
        let total = UInt64(physicalMemory)
        let available = total > used ? total - used : 0
        
        return (total: total, available: available, used: used)
    }
    
    func isMemoryPressureHigh() -> Bool {
        let memInfo = getSystemMemoryInfo()
        return memInfo.available < lowMemoryThreshold
    }
    
    func isMemoryPressureCritical() -> Bool {
        let memInfo = getSystemMemoryInfo()
        return memInfo.available < criticalMemoryThreshold
    }
    
    func estimateMemoryRequirement(pageRect: CGRect, scaleFactor: CGFloat, transparentBackground: Bool) -> UInt64 {
        let scaledWidth = pageRect.width * scaleFactor
        let scaledHeight = pageRect.height * scaleFactor
        let pixelCount = scaledWidth * scaledHeight
        
        // 4 bytes per pixel (RGBA), plus overhead
        let baseMemory = UInt64(pixelCount * 4)
        
        // Add overhead for Core Graphics contexts and intermediate buffers
        let overhead = baseMemory / 4
        
        // Transparent backgrounds require more memory
        let transparencyMultiplier: CGFloat = transparentBackground ? 1.5 : 1.0
        
        return UInt64(CGFloat(baseMemory + overhead) * transparencyMultiplier)
    }
    
    func canAllocateMemory(_ requiredMemory: UInt64, verbose: Bool) -> Bool {
        let memInfo = getSystemMemoryInfo()
        let canAllocate = memInfo.available > requiredMemory + criticalMemoryThreshold
        
        if verbose {
            let availableMB = memInfo.available / (1024 * 1024)
            let requiredMB = requiredMemory / (1024 * 1024)
            logMessage(true, "Memory check: Available \(availableMB)MB, Required \(requiredMB)MB")
        }
        
        return canAllocate
    }
    
    func calculateOptimalBatchSize(totalPages: Int, pageRect: CGRect, scaleFactor: CGFloat, verbose: Bool) -> Int {
        let memoryPerPage = estimateMemoryRequirement(pageRect: pageRect, scaleFactor: scaleFactor, transparentBackground: false)
        let memInfo = getSystemMemoryInfo()
        let availableForBatch = memInfo.available / 2 // Use only half of available memory
        
        let optimalBatchSize = max(1, min(totalPages, Int(availableForBatch / memoryPerPage)))
        
        if verbose {
            let batchMemoryMB = (UInt64(optimalBatchSize) * memoryPerPage) / (1024 * 1024)
            logMessage(true, "Optimal batch size: \(optimalBatchSize) pages (\(batchMemoryMB)MB estimated)")
        }
        
        return optimalBatchSize
    }
    
    func logMemoryStatus(verbose: Bool) {
        if !verbose { return }
        
        let memInfo = getSystemMemoryInfo()
        let totalGB = Double(memInfo.total) / (1024 * 1024 * 1024)
        let availableMB = memInfo.available / (1024 * 1024)
        let usedMB = memInfo.used / (1024 * 1024)
        
        logMessage(true, String(format: "Memory status: %.1fGB total, %lluMB used, %lluMB available", 
                              totalGB, usedMB, availableMB))
        
        if isMemoryPressureCritical() {
            print("⚠️  Critical memory pressure detected!")
        } else if isMemoryPressureHigh() {
            print("⚠️  High memory pressure detected")
        }
    }
    
    func checkMemoryPressureDuringBatch(verbose: Bool) throws {
        if isMemoryPressureCritical() {
            throw PDF22PNGError.memory
        }
        
        if isMemoryPressureHigh() && verbose {
            print("⚠️  High memory pressure - consider reducing batch size")
        }
    }
}

// MARK: - Resource Management System

class ResourceManager {
    static let shared = ResourceManager()
    private init() {}
    
    private var tempFiles: Set<String> = []
    private var fileHandles: Set<ObjectIdentifier> = []
    private let resourceQueue = DispatchQueue(label: "resource.management", qos: .utility)
    
    func registerTempFile(_ path: String) {
        resourceQueue.sync {
            _ = tempFiles.insert(path)
        }
    }
    
    func unregisterTempFile(_ path: String) {
        resourceQueue.sync {
            _ = tempFiles.remove(path)
        }
    }
    
    func registerFileHandle(_ handle: FileHandle) {
        resourceQueue.sync {
            _ = fileHandles.insert(ObjectIdentifier(handle))
        }
    }
    
    func unregisterFileHandle(_ handle: FileHandle) {
        resourceQueue.sync {
            _ = fileHandles.remove(ObjectIdentifier(handle))
        }
    }
    
    func cleanupAllResources() {
        resourceQueue.sync {
            // Clean up temporary files
            for tempFile in tempFiles {
                do {
                    if FileManager.default.fileExists(atPath: tempFile) {
                        try FileManager.default.removeItem(atPath: tempFile)
                    }
                } catch {
                    // Ignore cleanup errors
                }
            }
            tempFiles.removeAll()
            
            // Clear file handle tracking
            fileHandles.removeAll()
        }
    }
    
    func createSecureTempFile(prefix: String = "pdf22png", suffix: String = ".tmp") -> String? {
        let tempDir = NSTemporaryDirectory()
        let tempFileName = "\(prefix)_\(UUID().uuidString)\(suffix)"
        let tempPath = (tempDir as NSString).appendingPathComponent(tempFileName)
        
        // Create the file with secure permissions (600)
        let success = FileManager.default.createFile(atPath: tempPath, contents: nil, attributes: [
            .posixPermissions: 0o600
        ])
        
        if success {
            registerTempFile(tempPath)
            return tempPath
        }
        
        return nil
    }
}

// MARK: - Input Validation System

class InputValidator {
    static let maxFileSize: UInt64 = 500 * 1024 * 1024 // 500MB
    static let maxPageNumber: Int = 10000
    static let maxTotalPages: Int = 5000
    static let maxPathLength: Int = 1024
    
    static func validateFilePath(_ path: String, allowCreate: Bool = false) throws -> String {
        // Check path length
        guard path.count <= maxPathLength else {
            throw PDF22PNGError.invalidArgs
        }
        
        // Prevent path traversal attacks
        let normalizedPath = (path as NSString).standardizingPath
        guard !normalizedPath.contains("../") && !normalizedPath.contains("..\\") else {
            throw PDF22PNGError.invalidArgs
        }
        
        // Check for null bytes and other dangerous characters
        guard !path.contains("\0") && !path.contains("\n") && !path.contains("\r") else {
            throw PDF22PNGError.invalidArgs
        }
        
        if !allowCreate {
            // For input files, check existence and size
            guard FileManager.default.fileExists(atPath: normalizedPath) else {
                throw PDF22PNGError.fileNotFound
            }
            
            do {
                let attributes = try FileManager.default.attributesOfItem(atPath: normalizedPath)
                if let fileSize = attributes[.size] as? UInt64, fileSize > maxFileSize {
                    throw PDF22PNGError.invalidArgs
                }
            } catch {
                throw PDF22PNGError.fileRead
            }
        }
        
        return normalizedPath
    }
    
    static func validateOutputDirectory(_ path: String) throws -> String {
        let normalizedPath = try validateFilePath(path, allowCreate: true)
        
        // Check if parent directory exists and is writable
        let parentDir = (normalizedPath as NSString).deletingLastPathComponent
        guard FileManager.default.fileExists(atPath: parentDir) else {
            throw PDF22PNGError.outputDir
        }
        
        guard FileManager.default.isWritableFile(atPath: parentDir) else {
            throw PDF22PNGError.fileWrite
        }
        
        return normalizedPath
    }
    
    static func validatePageNumber(_ page: Int, totalPages: Int) throws {
        guard page >= 1 && page <= totalPages else {
            throw PDF22PNGError.pageNotFound
        }
        
        guard page <= maxPageNumber else {
            throw PDF22PNGError.invalidArgs
        }
    }
    
    static func validatePageRange(_ range: String, totalPages: Int) throws {
        // Basic validation of page range format
        let validChars = CharacterSet(charactersIn: "0123456789,-")
        guard range.rangeOfCharacter(from: validChars.inverted) == nil else {
            throw PDF22PNGError.invalidArgs
        }
        
        // Check for reasonable range limits
        let components = range.components(separatedBy: CharacterSet(charactersIn: ",-"))
        for component in components {
            if let pageNum = Int(component.trimmingCharacters(in: .whitespaces)) {
                try validatePageNumber(pageNum, totalPages: totalPages)
            }
        }
    }
    
    static func validateScale(_ scale: String) throws {
        guard scale.count <= 20 else { // Reasonable limit for scale specification
            throw PDF22PNGError.invalidScale
        }
        
        // Check for basic format validity
        let validChars = CharacterSet(charactersIn: "0123456789.%xdpi")
        guard scale.rangeOfCharacter(from: validChars.inverted) == nil else {
            throw PDF22PNGError.invalidScale
        }
    }
    
    static func validateQuality(_ quality: Int) throws {
        guard quality >= 0 && quality <= 9 else {
            throw PDF22PNGError.invalidArgs
        }
    }
    
    static func validateNamingPattern(_ pattern: String) throws {
        guard pattern.count <= 200 else { // Reasonable pattern length
            throw PDF22PNGError.invalidArgs
        }
        
        // Check for potentially dangerous pattern elements
        guard !pattern.contains("../") && !pattern.contains("..\\") && !pattern.contains("\0") else {
            throw PDF22PNGError.invalidArgs
        }
    }
}

// MARK: - Enhanced Signal Handling

var shouldTerminate = false
private var cleanupHandlers: [() -> Void] = []
private let signalQueue = DispatchQueue(label: "signal.handling", qos: .utility)

func installSignalHandlers() {
    // Handle SIGINT (Ctrl+C)
    signal(SIGINT) { _ in
        handleGracefulShutdown(signal: "SIGINT")
    }
    
    // Handle SIGTERM (termination request)
    signal(SIGTERM) { _ in
        handleGracefulShutdown(signal: "SIGTERM")
    }
    
    // Handle SIGHUP (hangup)
    signal(SIGHUP) { _ in
        handleGracefulShutdown(signal: "SIGHUP")
    }
}

private func handleGracefulShutdown(signal: String) {
    shouldTerminate = true
    
    fputs("\n📡 Received \(signal), initiating graceful shutdown...\n", stderr)
    fflush(stderr)
    
    // Perform cleanup on a separate queue to avoid deadlocks
    signalQueue.async {
        performCleanup()
        
        // Give a brief moment for current operations to finish
        usleep(100_000) // 100ms
        
        fputs("✅ Cleanup complete. Exiting.\n", stderr)
        fflush(stderr)
        exit(1)
    }
}

private func performCleanup() {
    // Execute registered cleanup handlers
    for handler in cleanupHandlers {
        handler()
    }
    cleanupHandlers.removeAll()
    
    // Clean up resources
    ResourceManager.shared.cleanupAllResources()
}

func registerCleanupHandler(_ handler: @escaping () -> Void) {
    cleanupHandlers.append(handler)
}

func checkInterruption() throws {
    if shouldTerminate {
        throw PDF22PNGError.signalInterruption
    }
}

// MARK: - Progress Reporter

class ProgressReporter {
    private let totalPages: Int
    private var startTime: Date
    private var processedPages: Int = 0
    private var successfulPages: Int = 0
    private var failedPages: Int = 0
    private var lastReportTime: Date
    private let reportInterval: TimeInterval = 1.0 // Report at most once per second
    private let verbose: Bool
    
    init(totalPages: Int, verbose: Bool = false) {
        self.totalPages = totalPages
        self.verbose = verbose
        self.startTime = Date()
        self.lastReportTime = Date()
    }
    
    func reportPageStart(pageNumber: Int) {
        if verbose {
            print("Processing page \(pageNumber)/\(totalPages)...")
        }
    }
    
    func reportPageComplete(pageNumber: Int, success: Bool, outputFile: String? = nil) {
        processedPages += 1
        if success {
            successfulPages += 1
            if let outputFile = outputFile, !verbose {
                // For non-verbose mode, show successful outputs
                print("✓ Page \(pageNumber) → \(outputFile)")
            }
        } else {
            failedPages += 1
            print("✗ Page \(pageNumber) failed")
        }
        
        // Report progress if enough time has passed or we're at a milestone
        let now = Date()
        let shouldReportTime = now.timeIntervalSince(lastReportTime) >= reportInterval
        let shouldReportMilestone = processedPages % 10 == 0 || processedPages == totalPages
        
        if shouldReportTime || shouldReportMilestone {
            reportProgress()
            lastReportTime = now
        }
    }
    
    func reportChunkStart(chunkNumber: Int, totalChunks: Int, pagesInChunk: Int) {
        if verbose {
            print("\n📦 Processing chunk \(chunkNumber)/\(totalChunks) (\(pagesInChunk) pages)")
        }
    }
    
    private func reportProgress() {
        let percentage = (processedPages * 100) / totalPages
        let elapsed = Date().timeIntervalSince(startTime)
        let pagesPerSecond = elapsed > 0 ? Double(processedPages) / elapsed : 0
        let estimatedTotal = pagesPerSecond > 0 ? Double(totalPages) / pagesPerSecond : 0
        let estimatedRemaining = max(0, estimatedTotal - elapsed)
        
        var progressBar = "["
        let barWidth = 30
        let filledWidth = (barWidth * processedPages) / totalPages
        progressBar += String(repeating: "■", count: filledWidth)
        progressBar += String(repeating: "□", count: barWidth - filledWidth)
        progressBar += "]"
        
        print("\n📊 Progress: \(progressBar) \(percentage)%")
        print("   Processed: \(processedPages)/\(totalPages) pages (✓ \(successfulPages), ✗ \(failedPages))")
        
        if pagesPerSecond > 0 {
            print("   Speed: \(String(format: "%.1f", pagesPerSecond)) pages/sec")
            print("   Time: \(formatDuration(elapsed)) elapsed, ~\(formatDuration(estimatedRemaining)) remaining")
        }
        
        // Memory status in verbose mode
        if verbose {
            let memInfo = MemoryManager.shared.getSystemMemoryInfo()
            let usedGB = Double(memInfo.used) / (1024 * 1024 * 1024)
            let availableGB = Double(memInfo.available) / (1024 * 1024 * 1024)
            print("   Memory: \(String(format: "%.1f", usedGB))GB used, \(String(format: "%.1f", availableGB))GB available")
        }
    }
    
    func reportBatchComplete() {
        let elapsed = Date().timeIntervalSince(startTime)
        let pagesPerSecond = elapsed > 0 ? Double(processedPages) / elapsed : 0
        
        print("\n✅ Batch processing complete!")
        print("   Total: \(processedPages) pages processed in \(formatDuration(elapsed))")
        print("   Results: ✓ \(successfulPages) successful, ✗ \(failedPages) failed")
        if pagesPerSecond > 0 {
            print("   Average speed: \(String(format: "%.1f", pagesPerSecond)) pages/sec")
        }
    }
    
    func reportInterrupted() {
        print("\n⚠️  Processing interrupted!")
        print("   Completed: \(processedPages)/\(totalPages) pages")
        print("   Results: ✓ \(successfulPages) successful, ✗ \(failedPages) failed")
    }
    
    private func formatDuration(_ seconds: TimeInterval) -> String {
        let minutes = Int(seconds) / 60
        let secs = Int(seconds) % 60
        if minutes > 0 {
            return "\(minutes)m \(secs)s"
        } else {
            return "\(secs)s"
        }
    }
}

// MARK: - Command Line Argument Parser

struct CommandLineOptions {
    var inputFile: String?
    var outputFile: String?
    var page: String = "1"
    var allPages: Bool = false
    var resolution: String?
    var scale: String = "100%"
    var transparent: Bool = false
    var quality: Int = 6
    var outputPath: String?
    var directory: String?
    var verbose: Bool = false
    var includeText: Bool = false
    var namingPattern: String?
    var dryRun: Bool = false
    var forceOverwrite: Bool = false
    var showHelp: Bool = false
    var showVersion: Bool = false
}

func printHelp() {
    print("""
Usage: pdf22png [OPTIONS] <input.pdf> [output.png]
Converts PDF documents to PNG images.

Options:
  -p, --page <spec>       Page(s) to convert. Single page, range, or comma-separated.
                          Examples: 1 | 1-5 | 1,3,5-10 (default: 1)
                          In batch mode, only specified pages are converted.
  -a, --all               Convert all pages. If -d is not given, uses input filename as prefix.
                          Output files named <prefix>-<page_num>.png.
  -r, --resolution <dpi>  Set output DPI (e.g., 150dpi). Overrides -s if both used with numbers.
  -s, --scale <spec>      Scaling specification (default: 100% or 1.0).
                            NNN%: percentage (e.g., 150%)
                            N.N:  scale factor (e.g., 1.5)
                            WxH:  fit to WxH pixels (e.g., 800x600)
                            Wx:   fit to width W pixels (e.g., 1024x)
                            xH:   fit to height H pixels (e.g., x768)
  -t, --transparent       Preserve transparency (default: white background).
  -q, --quality <n>       PNG compression quality (0-9, default: 6). Currently informational.
  -o, --output <path>     Output PNG file or prefix for batch mode.
                          If '-', output to stdout (single page mode only).
  -d, --directory <dir>   Output directory for batch mode (converts all pages).
                          If used, -o specifies filename prefix inside this directory.
  -v, --verbose           Verbose output.
  -n, --name              Include extracted text in output filename (batch mode only).
  -P, --pattern <pat>     Custom naming pattern for batch mode. Placeholders:
                          {basename} - Input filename without extension
                          {page} - Page number (auto-padded)
                          {page:03d} - Page with custom padding
                          {text} - Extracted text (requires -n)
                          {date} - Current date (YYYYMMDD)
                          {time} - Current time (HHMMSS)
                          {total} - Total page count
                          Example: '{basename}_p{page:04d}_of_{total}'
  -D, --dry-run           Preview operations without writing files.
  -f, --force             Force overwrite existing files without prompting.
  -h, --help              Show this help message and exit.
  --version               Show version information and exit.

Arguments:
  <input.pdf>             Input PDF file. If '-', reads from stdin.
  [output.png]            Output PNG file. Required if not using -o or -d.
                          If input is stdin and output is not specified, output goes to stdout.
                          In batch mode (-a or -d), this is used as a prefix if -o is not set.

Examples:
  pdf22png document.pdf page1.png              # Convert first page
  pdf22png -p 5 document.pdf page5.png         # Convert page 5
  pdf22png -a document.pdf                     # Convert all pages (document-001.png, ...)
  pdf22png -r 300 document.pdf hi-res.png      # High resolution
  pdf22png -s 150% document.pdf large.png      # 1.5x scale
  pdf22png -d output/ document.pdf             # All pages to output/ directory
  pdf22png -t document.pdf transparent.png     # Preserve transparency
  cat document.pdf | pdf22png - output.png     # From stdin
""")
}

func printVersion() {
    let version = "2.0.0-standalone"
    print("pdf22png \(version)")
    print("Swift standalone implementation")
}

func parseCommandLine() -> CommandLineOptions {
    var options = CommandLineOptions()
    let args = Array(CommandLine.arguments.dropFirst())
    var i = 0
    
    while i < args.count {
        let arg = args[i]
        
        switch arg {
        case "-h", "--help":
            options.showHelp = true
            return options
            
        case "--version":
            options.showVersion = true
            return options
            
        case "-p", "--page":
            guard i + 1 < args.count else {
                print("Error: --page requires a value")
                exit(2)
            }
            options.page = args[i + 1]
            i += 1
            
        case "-a", "--all":
            options.allPages = true
            
        case "-r", "--resolution":
            guard i + 1 < args.count else {
                print("Error: --resolution requires a value")
                exit(2)
            }
            options.resolution = args[i + 1]
            i += 1
            
        case "-s", "--scale":
            guard i + 1 < args.count else {
                print("Error: --scale requires a value")
                exit(2)
            }
            options.scale = args[i + 1]
            i += 1
            
        case "-t", "--transparent":
            options.transparent = true
            
        case "-q", "--quality":
            guard i + 1 < args.count else {
                print("Error: --quality requires a value")
                exit(2)
            }
            guard let quality = Int(args[i + 1]), quality >= 0 && quality <= 9 else {
                print("Error: quality must be between 0 and 9")
                exit(2)
            }
            options.quality = quality
            i += 1
            
        case "-o", "--output":
            guard i + 1 < args.count else {
                print("Error: --output requires a value")
                exit(2)
            }
            options.outputPath = args[i + 1]
            i += 1
            
        case "-d", "--directory":
            guard i + 1 < args.count else {
                print("Error: --directory requires a value")
                exit(2)
            }
            options.directory = args[i + 1]
            i += 1
            
        case "-v", "--verbose":
            options.verbose = true
            
        case "-n", "--name":
            options.includeText = true
            
        case "-P", "--pattern":
            guard i + 1 < args.count else {
                print("Error: --pattern requires a value")
                exit(2)
            }
            options.namingPattern = args[i + 1]
            i += 1
            
        case "-D", "--dry-run":
            options.dryRun = true
            
        case "-f", "--force":
            options.forceOverwrite = true
            
        default:
            if arg.hasPrefix("-") {
                print("Error: Unknown option: \(arg)")
                print("Use --help for usage information")
                exit(2)
            } else {
                // Positional arguments
                if options.inputFile == nil {
                    options.inputFile = arg
                } else if options.outputFile == nil {
                    options.outputFile = arg
                } else {
                    print("Error: Too many arguments")
                    exit(2)
                }
            }
        }
        i += 1
    }
    
    return options
}

// MARK: - Error Handling

enum PDF22PNGError: Int, Error, LocalizedError {
    case success = 0
    case generalError = 1
    case invalidArgs = 2
    case fileNotFound = 3
    case fileRead = 4
    case fileWrite = 5
    case noInput = 6
    case invalidPDF = 7
    case encryptedPDF = 8
    case emptyPDF = 9
    case pageNotFound = 10
    case renderFailed = 11
    case memory = 12
    case outputDir = 13
    case invalidScale = 14
    case batchFailed = 15
    case signalInterruption = 16
    
    var errorDescription: String? {
        switch self {
        case .success: return "Success"
        case .generalError: return "General error occurred"
        case .invalidArgs: return "Invalid command line arguments"
        case .fileNotFound: return "Input file not found"
        case .fileRead: return "Failed to read input file"
        case .fileWrite: return "Failed to write output file"
        case .noInput: return "No input data received"
        case .invalidPDF: return "Invalid PDF document"
        case .encryptedPDF: return "PDF document is encrypted"
        case .emptyPDF: return "PDF document has no pages"
        case .pageNotFound: return "Requested page does not exist"
        case .renderFailed: return "Failed to render PDF page"
        case .memory: return "Memory allocation failed"
        case .outputDir: return "Failed to create output directory"
        case .invalidScale: return "Invalid scale specification"
        case .batchFailed: return "Batch processing failed"
        case .signalInterruption: return "Operation interrupted by system signal"
        }
    }
}

func reportPDF22PNGError(_ error: PDF22PNGError, context: String? = nil) {
    print("❌ Error: \(error.errorDescription ?? "Unknown error")")
    
    if let ctx = context {
        print("📍 Context: \(ctx)")
    }
    
    // Provide specific troubleshooting based on error type
    switch error {
    case .invalidArgs:
        print("\n💡 Input Validation Help:")
        print("   • Check command syntax with --help flag")
        print("   • Verify all arguments are correct")
        print("   • Use absolute paths to avoid confusion")
        
    case .fileNotFound:
        print("\n💡 File Access Help:")
        print("   • Verify the file path is correct and the file exists")
        print("   • Use absolute paths to avoid confusion")
        print("   • Check file permissions with 'ls -la'")
        
    case .fileRead:
        print("\n💡 File Access Help:")
        print("   • Check file permissions with 'ls -la'")
        print("   • Ensure you have read access to the file")
        print("   • Verify file is not corrupted")
        
    case .fileWrite:
        print("\n💡 File Write Help:")
        print("   • Check available disk space with 'df -h'")
        print("   • Verify write permissions to output directory")
        print("   • Try a different output location")
        
    case .invalidScale:
        print("\n💡 Scale Format Help:")
        print("   • Valid formats: 150%, 2.0, 800x600, 300dpi")
        print("   • Percentage: append % (e.g., 150%)")
        print("   • Factor: decimal number (e.g., 1.5)")
        print("   • Dimensions: WIDTHxHEIGHT (e.g., 1024x768)")
        
    case .pageNotFound:
        print("\n💡 Page Range Help:")
        print("   • PDF pages start at 1, not 0")
        print("   • Use --verbose to see total page count")
        print("   • Valid formats: 5 (single), 1-10 (range)")
        
    case .memory:
        print("\n💡 Memory Help:")
        print("   • Close other applications to free RAM")
        print("   • Use smaller scale factor: --scale 50%")
        print("   • Process fewer pages at once")
        
    case .encryptedPDF:
        print("\n💡 Encrypted PDF Help:")
        print("   • Remove password protection:")
        print("     - In Preview: File → Export As → PDF (uncheck Encrypt)")
        print("     - Command line: qpdf --decrypt --password=PASSWORD input.pdf output.pdf")
        
    default:
        print("\n💡 General Help:")
        print("   • Run with --verbose flag for detailed information")
        print("   • Check --help for usage examples")
        print("   • Try with a simpler PDF first")
    }
}

// MARK: - Utility Functions

func logMessage(_ verbose: Bool, _ message: String) {
    if verbose {
        print("LOG: \(message)")
    }
}

// MARK: - Scale Specification

struct ScaleSpecification {
    var scaleFactor: CGFloat = 1.0
    var maxWidth: CGFloat = 0
    var maxHeight: CGFloat = 0
    var dpi: CGFloat = 144
    var isPercentage: Bool = true
    var isDPI: Bool = false
    var hasWidth: Bool = false
    var hasHeight: Bool = false
}

func parseScaleSpecification(_ scaleStr: String) -> ScaleSpecification? {
    var spec = ScaleSpecification()
    let trimmed = scaleStr.trimmingCharacters(in: .whitespaces)
    
    if trimmed.hasSuffix("%") {
        let percentStr = String(trimmed.dropLast())
        guard let percent = Double(percentStr), percent > 0 else { return nil }
        spec.scaleFactor = CGFloat(percent / 100.0)
        spec.isPercentage = true
        return spec
    }
    
    if trimmed.hasSuffix("dpi") {
        let dpiStr = String(trimmed.dropLast(3))
        guard let dpi = Double(dpiStr), dpi > 0 else { return nil }
        spec.dpi = CGFloat(dpi)
        spec.scaleFactor = CGFloat(dpi / 72.0)
        spec.isDPI = true
        return spec
    }
    
    if trimmed.contains("x") {
        let parts = trimmed.components(separatedBy: "x")
        guard parts.count == 2 else { return nil }
        
        let widthStr = parts[0]
        let heightStr = parts[1]
        
        if !widthStr.isEmpty {
            guard let width = Double(widthStr), width > 0 else { return nil }
            spec.maxWidth = CGFloat(width)
            spec.hasWidth = true
        }
        
        if !heightStr.isEmpty {
            guard let height = Double(heightStr), height > 0 else { return nil }
            spec.maxHeight = CGFloat(height)
            spec.hasHeight = true
        }
        
        if !spec.hasWidth && !spec.hasHeight {
            return nil
        }
        
        spec.isPercentage = false
        return spec
    }
    
    guard let factor = Double(trimmed), factor > 0 else { return nil }
    spec.scaleFactor = CGFloat(factor)
    spec.isPercentage = false
    return spec
}

func calculateScaleFactor(scale: ScaleSpecification, pageRect: CGRect) -> CGFloat {
    if scale.hasWidth || scale.hasHeight {
        let pageWidth = pageRect.width
        let pageHeight = pageRect.height
        
        var scaleX: CGFloat = 1.0
        var scaleY: CGFloat = 1.0
        
        if scale.hasWidth {
            scaleX = scale.maxWidth / pageWidth
        }
        
        if scale.hasHeight {
            scaleY = scale.maxHeight / pageHeight
        }
        
        if scale.hasWidth && scale.hasHeight {
            return min(scaleX, scaleY)
        } else {
            return scale.hasWidth ? scaleX : scaleY
        }
    }
    
    return scale.scaleFactor
}

// MARK: - PDF Processing

func readPDFData(_ inputPath: String?, verbose: Bool) -> Data? {
    if let path = inputPath, path != "-" {
        logMessage(verbose, "Reading PDF from file: \(path)")
        return FileManager.default.contents(atPath: path)
    } else {
        logMessage(verbose, "Reading PDF from stdin")
        let stdin = FileHandle.standardInput
        return stdin.readDataToEndOfFile()
    }
}

func createPDFDocument(from data: Data) -> PDFDocument? {
    return PDFDocument(data: data)
}

func renderPDFPageToImage(page: PDFPage, scaleFactor: CGFloat, transparentBackground: Bool, verbose: Bool) -> CGImage? {
    let pageRect = page.bounds(for: .mediaBox)
    let scaledWidth = Int(pageRect.width * scaleFactor)
    let scaledHeight = Int(pageRect.height * scaleFactor)
    
    logMessage(verbose, "Rendering page at \(scaledWidth)x\(scaledHeight) (scale: \(scaleFactor))")
    
    let colorSpace = CGColorSpaceCreateDeviceRGB()
    let bitmapInfo: CGBitmapInfo = transparentBackground ? 
        [.byteOrder32Big, CGBitmapInfo(rawValue: CGImageAlphaInfo.premultipliedLast.rawValue)] :
        [.byteOrder32Big, CGBitmapInfo(rawValue: CGImageAlphaInfo.noneSkipLast.rawValue)]
    
    guard let context = CGContext(
        data: nil,
        width: scaledWidth,
        height: scaledHeight,
        bitsPerComponent: 8,
        bytesPerRow: 0,
        space: colorSpace,
        bitmapInfo: bitmapInfo.rawValue
    ) else {
        return nil
    }
    
    context.scaleBy(x: scaleFactor, y: scaleFactor)
    
    if !transparentBackground {
        context.setFillColor(CGColor.white)
        context.fill(CGRect(x: 0, y: 0, width: pageRect.width, height: pageRect.height))
    }
    
    page.draw(with: .mediaBox, to: context)
    
    return context.makeImage()
}

func writeImageToFile(image: CGImage, path: String, quality: Int, verbose: Bool, dryRun: Bool, forceOverwrite: Bool) -> Bool {
    if dryRun {
        let width = image.width
        let height = image.height
        print("[DRY-RUN] Would write \(width)x\(height) PNG to: \(path)")
        return true
    }
    
    // Check if file exists and handle overwrite
    if FileManager.default.fileExists(atPath: path) && !forceOverwrite {
        print("File \(path) already exists. Use --force to overwrite.")
        return false
    }
    
    let url = URL(fileURLWithPath: path)
    guard let destination = CGImageDestinationCreateWithURL(url as CFURL, UTType.png.identifier as CFString, 1, nil) else {
        return false
    }
    
    let options: [CFString: Any] = [
        kCGImageDestinationLossyCompressionQuality: CGFloat(quality) / 9.0
    ]
    
    CGImageDestinationAddImage(destination, image, options as CFDictionary)
    let success = CGImageDestinationFinalize(destination)
    
    if success {
        logMessage(verbose, "Successfully wrote PNG to: \(path)")
    }
    
    return success
}

func writeImageToStdout(image: CGImage, quality: Int, verbose: Bool) -> Bool {
    logMessage(verbose, "Writing PNG to stdout")
    
    let data = NSMutableData()
    guard let destination = CGImageDestinationCreateWithData(data, UTType.png.identifier as CFString, 1, nil) else {
        return false
    }
    
    let options: [CFString: Any] = [
        kCGImageDestinationLossyCompressionQuality: CGFloat(quality) / 9.0
    ]
    
    CGImageDestinationAddImage(destination, image, options as CFDictionary)
    guard CGImageDestinationFinalize(destination) else {
        return false
    }
    
    let stdout = FileHandle.standardOutput
    stdout.write(data as Data)
    return true
}

// MARK: - Processing Functions

func processSinglePage(options: CommandLineOptions, pdfDocument: PDFDocument) throws -> Bool {
    let pageNumber = Int(options.page) ?? 1
    
    // Check for interruption
    try checkInterruption()
    
    logMessage(options.verbose, "Processing single page: \(pageNumber)")
    
    guard pageNumber >= 1 && pageNumber <= pdfDocument.pageCount else {
        throw PDF22PNGError.pageNotFound
    }
    
    guard let pdfPage = pdfDocument.page(at: pageNumber - 1) else {
        throw PDF22PNGError.renderFailed
    }
    
    guard let scaleSpec = parseScaleSpecification(options.resolution ?? options.scale) else {
        throw PDF22PNGError.invalidScale
    }
    
    let pageRect = pdfPage.bounds(for: .mediaBox)
    let scaleFactor = calculateScaleFactor(scale: scaleSpec, pageRect: pageRect)
    
    logMessage(options.verbose, "Calculated scale factor: \(scaleFactor)")
    
    // Check memory requirements before processing
    let memoryRequired = MemoryManager.shared.estimateMemoryRequirement(
        pageRect: pageRect, 
        scaleFactor: scaleFactor, 
        transparentBackground: options.transparent
    )
    
    if !MemoryManager.shared.canAllocateMemory(memoryRequired, verbose: options.verbose) {
        print("Warning: Insufficient memory for processing this page at current scale. Consider reducing scale factor.")
        // Continue anyway - user may want to try despite the warning
    }
    
    // Check for memory pressure before rendering
    try MemoryManager.shared.checkMemoryPressureDuringBatch(verbose: options.verbose)
    
    guard let image = renderPDFPageToImage(
        page: pdfPage,
        scaleFactor: scaleFactor,
        transparentBackground: options.transparent,
        verbose: options.verbose
    ) else {
        throw PDF22PNGError.renderFailed
    }
    
    // Check for interruption after rendering
    try checkInterruption()
    
    if let outputPath = options.outputPath, outputPath == "-" {
        if options.dryRun {
            print("[DRY-RUN] Would write \(image.width)x\(image.height) PNG to stdout")
            return true
        } else {
            return writeImageToStdout(image: image, quality: options.quality, verbose: options.verbose)
        }
    } else if let outputPath = options.outputPath ?? options.outputFile {
        return writeImageToFile(
            image: image,
            path: outputPath,
            quality: options.quality,
            verbose: options.verbose,
            dryRun: options.dryRun,
            forceOverwrite: options.forceOverwrite
        )
    } else {
        throw PDF22PNGError.invalidArgs
    }
}

func processBatchMode(options: CommandLineOptions, pdfDocument: PDFDocument) throws -> Bool {
    let totalPages = pdfDocument.pageCount
    let outputDir = options.directory ?? "."
    
    logMessage(options.verbose, "Processing in batch mode. Output directory: \(outputDir)")
    
    // Check for interruption
    try checkInterruption()
    
    // Create output directory
    if !options.dryRun {
        do {
            try FileManager.default.createDirectory(atPath: outputDir, withIntermediateDirectories: true, attributes: nil)
        } catch {
            throw PDF22PNGError.outputDir
        }
    }
    
    // Determine output prefix
    let inputBasename = (options.inputFile != nil && options.inputFile != "-") ? 
        URL(fileURLWithPath: options.inputFile!).deletingPathExtension().lastPathComponent : "output"
    let prefix = options.outputPath ?? inputBasename
    
    logMessage(options.verbose, "Using output prefix: \(prefix)")
    
    // Memory-based batch optimization
    guard let firstPage = pdfDocument.page(at: 0) else {
        throw PDF22PNGError.renderFailed
    }
    
    let pageRect = firstPage.bounds(for: .mediaBox)
    guard let scaleSpec = parseScaleSpecification(options.resolution ?? options.scale) else {
        throw PDF22PNGError.invalidScale
    }
    
    let scaleFactor = calculateScaleFactor(scale: scaleSpec, pageRect: pageRect)
    
    // Calculate optimal batch size based on memory
    let optimalBatchSize = MemoryManager.shared.calculateOptimalBatchSize(
        totalPages: totalPages,
        pageRect: pageRect,
        scaleFactor: scaleFactor,
        verbose: options.verbose
    )
    
    // Initialize progress reporter
    let progressReporter = ProgressReporter(totalPages: totalPages, verbose: options.verbose)
    
    if !options.dryRun {
        print("🚀 Starting batch conversion of \(totalPages) pages...")
        if options.verbose {
            print("   Output directory: \(outputDir)")
            print("   Output prefix: \(prefix)")
            print("   Batch size: \(optimalBatchSize) pages/chunk")
        }
    }
    
    // Process pages in memory-optimized chunks
    let chunks = stride(from: 1, through: totalPages, by: optimalBatchSize).map { start in
        Array(start..<min(start + optimalBatchSize, totalPages + 1))
    }
    
    for (chunkIndex, chunk) in chunks.enumerated() {
        // Check for interruption before each chunk
        try checkInterruption()
        
        // Check memory pressure before each chunk
        try MemoryManager.shared.checkMemoryPressureDuringBatch(verbose: options.verbose)
        
        progressReporter.reportChunkStart(chunkNumber: chunkIndex + 1, totalChunks: chunks.count, pagesInChunk: chunk.count)
        
        // Register cleanup for this chunk
        registerCleanupHandler {
            logMessage(options.verbose, "Cleaning up chunk \(chunkIndex + 1) resources...")
        }
        
        for pageNum in chunk {
            // Check for interruption for each page
            try checkInterruption()
            
            progressReporter.reportPageStart(pageNumber: pageNum)
            
            guard let pdfPage = pdfDocument.page(at: pageNum - 1) else {
                progressReporter.reportPageComplete(pageNumber: pageNum, success: false)
                continue
            }
            
            let pageRect = pdfPage.bounds(for: .mediaBox)
            let scaleFactor = calculateScaleFactor(scale: scaleSpec, pageRect: pageRect)
            
            // Check memory before each page in the chunk
            let memoryRequired = MemoryManager.shared.estimateMemoryRequirement(
                pageRect: pageRect,
                scaleFactor: scaleFactor,
                transparentBackground: options.transparent
            )
            
            if !MemoryManager.shared.canAllocateMemory(memoryRequired, verbose: false) {
                logMessage(options.verbose, "Warning: Insufficient memory for page \(pageNum), continuing anyway...")
            }
            
            guard let image = renderPDFPageToImage(
                page: pdfPage,
                scaleFactor: scaleFactor,
                transparentBackground: options.transparent,
                verbose: options.verbose
            ) else {
                progressReporter.reportPageComplete(pageNumber: pageNum, success: false)
                continue
            }
            
            let filename = String(format: "%@-%03d.png", prefix, pageNum)
            let outputPath = (outputDir as NSString).appendingPathComponent(filename)
            
            if options.dryRun {
                print("[DRY-RUN] Would create: \(filename) (\(image.width)x\(image.height) pixels)")
                progressReporter.reportPageComplete(pageNumber: pageNum, success: true, outputFile: filename)
            } else {
                let success = writeImageToFile(
                    image: image,
                    path: outputPath,
                    quality: options.quality,
                    verbose: options.verbose,
                    dryRun: options.dryRun,
                    forceOverwrite: options.forceOverwrite
                )
                progressReporter.reportPageComplete(pageNumber: pageNum, success: success, outputFile: success ? filename : nil)
            }
        }
        
        // Log memory status after each chunk in verbose mode
        if options.verbose && chunks.count > 1 {
            MemoryManager.shared.logMemoryStatus(verbose: true)
        }
        
        // Break if terminated
        if shouldTerminate {
            progressReporter.reportInterrupted()
            break
        }
    }
    
    // Final status report
    if options.dryRun {
        print("\n[DRY-RUN] Would convert \(totalPages) pages to PNG files")
    } else if !shouldTerminate {
        progressReporter.reportBatchComplete()
    }
    
    return true
}

// MARK: - Main Function

func main() -> Int32 {
    let options = parseCommandLine()
    
    if options.showHelp {
        printHelp()
        return 0
    }
    
    if options.showVersion {
        printVersion()
        return 0
    }
    
    // Install signal handlers for graceful shutdown
    installSignalHandlers()
    
    guard let inputFile = options.inputFile else {
        print("Error: Input PDF file required")
        print("Use --help for usage information")
        return 2
    }
    
    // Validate input arguments with comprehensive checks
    do {
        // Validate quality parameter
        try InputValidator.validateQuality(options.quality)
        
        // Validate scale specification
        try InputValidator.validateScale(options.resolution ?? options.scale)
        
        // Validate input file path (if not stdin)
        if inputFile != "-" {
            _ = try InputValidator.validateFilePath(inputFile, allowCreate: false)
        }
        
        // Validate output paths
        if let outputPath = options.outputPath, outputPath != "-" {
            _ = try InputValidator.validateFilePath(outputPath, allowCreate: true)
        }
        
        if let outputFile = options.outputFile, outputFile != "-" {
            _ = try InputValidator.validateFilePath(outputFile, allowCreate: true)
        }
        
        if let directory = options.directory {
            _ = try InputValidator.validateOutputDirectory(directory)
        }
        
        // Validate naming pattern if provided
        if let pattern = options.namingPattern {
            try InputValidator.validateNamingPattern(pattern)
        }
        
    } catch let error as PDF22PNGError {
        reportPDF22PNGError(error, context: "Input validation failed")
        return Int32(error.rawValue)
    } catch {
        print("Error: Input validation failed - \(error.localizedDescription)")
        return 2
    }
    
    logMessage(options.verbose, "Starting pdf22png processing")
    
    // Check initial memory status
    MemoryManager.shared.logMemoryStatus(verbose: options.verbose)
    
    // Register cleanup handler for this session
    registerCleanupHandler {
        logMessage(options.verbose, "Cleaning up resources on exit")
    }
    
    guard let pdfData = readPDFData(inputFile, verbose: options.verbose) else {
        print("Error: Failed to read PDF data")
        return 4
    }
    
    guard let pdfDocument = createPDFDocument(from: pdfData) else {
        print("Error: Invalid PDF document")
        return 7
    }
    
    if pdfDocument.isEncrypted {
        print("Error: PDF document is encrypted")
        return 8
    }
    
    let pageCount = pdfDocument.pageCount
    if pageCount == 0 {
        print("Error: PDF document has no pages")
        return 9
    }
    
    // Validate PDF complexity limits
    guard pageCount <= InputValidator.maxTotalPages else {
        print("Error: PDF has too many pages (\(pageCount)). Maximum allowed: \(InputValidator.maxTotalPages)")
        return Int32(PDF22PNGError.invalidArgs.rawValue)
    }
    
    logMessage(options.verbose, "PDF loaded: \(pageCount) pages")
    
    // Check if we should validate page ranges now that we know the total count
    if !options.allPages {
        do {
            if let pageNum = Int(options.page) {
                try InputValidator.validatePageNumber(pageNum, totalPages: pageCount)
            } else {
                try InputValidator.validatePageRange(options.page, totalPages: pageCount)
            }
        } catch let error as PDF22PNGError {
            reportPDF22PNGError(error, context: "Page validation failed")
            return Int32(error.rawValue)
        } catch {
            print("Error: Page validation failed - \(error.localizedDescription)")
            return 10
        }
    }
    
    let success: Bool
    do {
        if options.allPages || options.directory != nil {
            success = try processBatchMode(options: options, pdfDocument: pdfDocument)
        } else {
            success = try processSinglePage(options: options, pdfDocument: pdfDocument)
        }
    } catch let error as PDF22PNGError {
        reportPDF22PNGError(error, context: "Processing failed")
        return Int32(error.rawValue)
    } catch {
        print("Error: Processing failed - \(error.localizedDescription)")
        return 1
    }
    
    // Final cleanup
    performCleanup()
    
    return success ? 0 : 1
}

// Entry point
exit(main())
</file>

<file path="main.swift">
import Foundation
import CoreGraphics
import PDFKit
import Dispatch

// MARK: - Main Entry Point

// Helper function for logging is defined in MemoryManager.swift

// Global references for signal handling compatibility
var shouldTerminate: Bool { return SignalHandler.shared.isTerminated }
func installSignalHandlers() { SignalHandler.shared.installSignalHandlers() }
func registerCleanupHandler(_ handler: @escaping () -> Void) { SignalHandler.shared.registerCleanupHandler(handler) }
func checkInterruption() throws { try SignalHandler.shared.checkInterruption() }
func performCleanup() { ResourceManager.shared.cleanupAllResources() }

func main() async -> Int32 {
    let options = ArgumentParser.parseArguments()
    
    if options.showHelp {
        OutputFormatter.printHelp()
        return 0
    }
    
    if options.showVersion {
        OutputFormatter.printVersion()
        return 0
    }
    
    // Install signal handlers for graceful shutdown
    installSignalHandlers()
    
    guard let inputFile = options.inputFile else {
        print("Error: Input PDF file required")
        print("Use --help for usage information")
        return 2
    }
    
    // Validate input arguments
    do {
        try ArgumentParser.validateArguments(options)
        
        // Additional validation with InputValidator
        try InputValidator.validateQuality(options.quality)
        try InputValidator.validateScale(options.effectiveScale)
        
        if inputFile != "-" {
            _ = try InputValidator.validateFilePath(inputFile, allowCreate: false)
        }
        
        if let outputPath = options.outputPath, outputPath != "-" {
            _ = try InputValidator.validateFilePath(outputPath, allowCreate: true)
        }
        
        if let outputFile = options.outputFile, outputFile != "-" {
            _ = try InputValidator.validateFilePath(outputFile, allowCreate: true)
        }
        
        if let directory = options.directory {
            _ = try InputValidator.validateOutputDirectory(directory)
        }
        
        if let pattern = options.namingPattern {
            try InputValidator.validateNamingPattern(pattern)
        }
        
    } catch let error as PDF22PNGError {
        ErrorReporter.reportError(error, context: "Input validation failed")
        return Int32(error.rawValue)
    } catch {
        print("Error: Input validation failed - \(error.localizedDescription)")
        return 2
    }
    
    logMessage(options.verbose, "Starting pdf22png processing")
    
    // Check initial memory status
    MemoryManager.shared.logMemoryStatus(verbose: options.verbose)
    
    // Register cleanup handler for this session
    registerCleanupHandler {
        logMessage(options.verbose, "Cleaning up resources on exit")
    }
    
    // Load PDF document
    guard let pdfData = PDFProcessor.shared.readPDFData(inputFile, verbose: options.verbose) else {
        print("Error: Failed to read PDF data")
        return 4
    }
    
    guard let pdfDocument = PDFProcessor.shared.createPDFDocument(from: pdfData) else {
        print("Error: Invalid PDF document")
        return 7
    }
    
    if pdfDocument.isEncrypted {
        print("Error: PDF document is encrypted")
        return 8
    }
    
    let pageCount = PDFProcessor.shared.getPageCount(pdfDocument)
    if pageCount == 0 {
        print("Error: PDF document has no pages")
        return 9
    }
    
    // Validate PDF complexity limits
    guard pageCount <= InputValidator.maxTotalPages else {
        print("Error: PDF has too many pages (\(pageCount)). Maximum allowed: \(InputValidator.maxTotalPages)")
        return Int32(PDF22PNGError.invalidArgs.rawValue)
    }
    
    logMessage(options.verbose, "PDF loaded: \(pageCount) pages")
    
    // Validate page ranges now that we know the total count
    if !options.isBatchMode {
        do {
            if let pageNum = Int(options.page) {
                try InputValidator.validatePageNumber(pageNum, totalPages: pageCount)
            } else {
                try InputValidator.validatePageRange(options.page, totalPages: pageCount)
            }
        } catch let error as PDF22PNGError {
            ErrorReporter.reportError(error, context: "Page validation failed")
            return Int32(error.rawValue)
        } catch {
            print("Error: Page validation failed - \(error.localizedDescription)")
            return 10
        }
    }
    
    // Process PDF
    let success: Bool
    do {
        if options.isBatchMode {
            success = try await processBatchMode(options: options, pdfDocument: pdfDocument)
        } else {
            success = try processSinglePage(options: options, pdfDocument: pdfDocument)
        }
    } catch let error as PDF22PNGError {
        ErrorReporter.reportError(error, context: "Processing failed")
        return Int32(error.rawValue)
    } catch {
        print("Error: Processing failed - \(error.localizedDescription)")
        return 1
    }
    
    // Final cleanup
    performCleanup()
    
    return success ? 0 : 1
}

// MARK: - Processing Functions

func processSinglePage(options: ProcessingOptions, pdfDocument: PDFDocument) throws -> Bool {
    let pageNumber = Int(options.page) ?? 1
    
    try checkInterruption()
    
    logMessage(options.verbose, "Processing single page: \(pageNumber)")
    
    guard let pdfPage = PDFProcessor.shared.extractPage(pdfDocument, pageNumber: pageNumber) else {
        throw PDF22PNGError.pageNotFound
    }
    
    guard let scaleSpec = ScaleParser.parseScaleSpecification(options.effectiveScale) else {
        throw PDF22PNGError.invalidScale
    }
    
    let pageRect = pdfPage.bounds(for: .mediaBox)
    let scaleFactor = ImageRenderer.shared.calculateScaleFactor(spec: scaleSpec, pageRect: pageRect)
    
    logMessage(options.verbose, "Calculated scale factor: \(scaleFactor)")
    
    // Check memory requirements
    let memoryRequired = MemoryManager.shared.estimateMemoryRequirement(
        pageRect: pageRect, 
        scaleFactor: scaleFactor, 
        transparentBackground: options.transparent
    )
    
    if !MemoryManager.shared.canAllocateMemory(memoryRequired, verbose: options.verbose) {
        print("Warning: Insufficient memory for processing this page at current scale.")
    }
    
    try MemoryManager.shared.checkMemoryPressureDuringBatch(verbose: options.verbose)
    
    let renderOptions = ImageRenderer.RenderOptions(
        scaleFactor: scaleFactor,
        transparentBackground: options.transparent,
        quality: options.quality,
        verbose: options.verbose,
        dryRun: options.dryRun,
        forceOverwrite: options.forceOverwrite
    )
    
    guard let image = ImageRenderer.shared.renderPageToImage(page: pdfPage, options: renderOptions) else {
        throw PDF22PNGError.renderFailed
    }
    
    try checkInterruption()
    
    if options.isStdoutMode {
        if options.dryRun {
            print("[DRY-RUN] Would write \(image.width)x\(image.height) PNG to stdout")
            return true
        } else {
            return ImageRenderer.shared.writeImageToStdout(image: image, options: renderOptions)
        }
    } else if let outputPath = options.outputPath ?? options.outputFile {
        return ImageRenderer.shared.writeImageToFile(image: image, path: outputPath, options: renderOptions)
    } else {
        throw PDF22PNGError.invalidArgs
    }
}

func processBatchMode(options: ProcessingOptions, pdfDocument: PDFDocument) async throws -> Bool {
    let totalPages = PDFProcessor.shared.getPageCount(pdfDocument)
    let outputDir = options.effectiveOutputDirectory
    
    logMessage(options.verbose, "Processing in batch mode. Output directory: \(outputDir)")
    
    let inputBasename = (options.inputFile != nil && options.inputFile != "-") ? 
        URL(fileURLWithPath: options.inputFile!).deletingPathExtension().lastPathComponent : "output"
    let prefix = options.outputPath ?? inputBasename
    
    guard let scaleSpec = ScaleParser.parseScaleSpecification(options.effectiveScale) else {
        throw PDF22PNGError.invalidScale
    }
    
    guard let firstPage = PDFProcessor.shared.extractPage(pdfDocument, pageNumber: 1) else {
        throw PDF22PNGError.renderFailed
    }
    
    let pageRect = firstPage.bounds(for: .mediaBox)
    let scaleFactor = ImageRenderer.shared.calculateScaleFactor(spec: scaleSpec, pageRect: pageRect)
    
    let batchOptions = BatchProcessor.BatchOptions(
        totalPages: totalPages,
        outputDirectory: outputDir,
        prefix: prefix,
        scaleFactor: scaleFactor,
        transparent: options.transparent,
        quality: options.quality,
        verbose: options.verbose,
        dryRun: options.dryRun,
        forceOverwrite: options.forceOverwrite
    )
    
    let result = try await BatchProcessor.shared.processBatch(document: pdfDocument, options: batchOptions)
    return result.successfulPages > 0
}

// Entry point
let semaphore = DispatchSemaphore(value: 0)
var exitCode: Int32 = 0

Task {
    exitCode = await main()
    semaphore.signal()
}

semaphore.wait()
exit(exitCode)
</file>

<file path="Makefile">
PRODUCT_NAME = pdf22png
SWIFT = xcrun swiftc
BUILDDIR = build
SOURCE = src/main.swift

.PHONY: all clean test

all: build

build:
	@echo "Building standalone Swift version..."
	@mkdir -p $(BUILDDIR)
	@$(SWIFT) -O -o $(BUILDDIR)/$(PRODUCT_NAME) $(SOURCE)
	@echo "Standalone Swift build complete!"

clean:
	@echo "Cleaning build directory..."
	@rm -rf $(BUILDDIR)
	@echo "Clean complete!"

test: build
	@echo "Testing standalone Swift implementation..."
	@./test-framework.swift
</file>

<file path="test-framework.swift">
#!/usr/bin/env swift

import Foundation

// MARK: - Test Framework

struct TestResult {
    let testName: String
    let passed: Bool
    let message: String
    let duration: TimeInterval
}

class TestFramework {
    private var results: [TestResult] = []
    private let executable: String
    
    init(executable: String) {
        self.executable = executable
    }
    
    func runTest(name: String, test: () throws -> (Bool, String)) {
        print("Running test: \(name)")
        let startTime = Date()
        
        do {
            let (passed, message) = try test()
            let duration = Date().timeIntervalSince(startTime)
            let result = TestResult(testName: name, passed: passed, message: message, duration: duration)
            results.append(result)
            
            let status = passed ? "✅ PASS" : "❌ FAIL"
            print("  \(status): \(message) (\(String(format: "%.3f", duration))s)")
        } catch {
            let duration = Date().timeIntervalSince(startTime)
            let result = TestResult(testName: name, passed: false, message: "Exception: \(error)", duration: duration)
            results.append(result)
            print("  ❌ FAIL: Exception - \(error) (\(String(format: "%.3f", duration))s)")
        }
    }
    
    func runCommand(_ args: [String]) -> (exitCode: Int32, stdout: String, stderr: String) {
        let process = Process()
        process.executableURL = URL(fileURLWithPath: executable)
        process.arguments = args
        
        let stdoutPipe = Pipe()
        let stderrPipe = Pipe()
        process.standardOutput = stdoutPipe
        process.standardError = stderrPipe
        
        do {
            try process.run()
            process.waitUntilExit()
        } catch {
            return (1, "", "Failed to execute: \(error)")
        }
        
        let stdout = String(data: stdoutPipe.fileHandleForReading.readDataToEndOfFile(), encoding: .utf8) ?? ""
        let stderr = String(data: stderrPipe.fileHandleForReading.readDataToEndOfFile(), encoding: .utf8) ?? ""
        
        return (process.terminationStatus, stdout, stderr)
    }
    
    func createTestPDF(path: String, pageCount: Int = 1) -> Bool {
        // Create a minimal PDF for testing
        let pdfContent = """
%PDF-1.4
1 0 obj
<< /Type /Catalog /Pages 2 0 R >>
endobj
2 0 obj
<< /Type /Pages /Count \(pageCount) /Kids [\(pageCount == 1 ? "3 0 R" : (1...pageCount).map { "\($0 + 2) 0 R" }.joined(separator: " "))] >>
endobj
3 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 4 0 R >>
endobj
4 0 obj
<< /Length 44 >>
stream
BT
/F1 12 Tf
100 700 Td
(Test Page) Tj
ET
endstream
endobj
xref
0 5
0000000000 65535 f
0000000009 00000 n
0000000058 00000 n
0000000115 00000 n
0000000207 00000 n
trailer
<< /Size 5 /Root 1 0 R >>
startxref
301
%%EOF
"""
        
        do {
            try pdfContent.write(toFile: path, atomically: true, encoding: .utf8)
            return true
        } catch {
            return false
        }
    }
    
    func printSummary() {
        let totalTests = results.count
        let passedTests = results.filter { $0.passed }.count
        let failedTests = totalTests - passedTests
        let totalDuration = results.reduce(0) { $0 + $1.duration }
        
        print("\n" + String(repeating: "=", count: 60))
        print("TEST SUMMARY")
        print(String(repeating: "=", count: 60))
        print("Total tests: \(totalTests)")
        print("Passed: \(passedTests)")
        print("Failed: \(failedTests)")
        print("Total duration: \(String(format: "%.3f", totalDuration))s")
        print("Success rate: \(String(format: "%.1f", Double(passedTests) / Double(totalTests) * 100))%")
        
        if failedTests > 0 {
            print("\nFAILED TESTS:")
            for result in results where !result.passed {
                print("  • \(result.testName): \(result.message)")
            }
        }
        
        print(String(repeating: "=", count: 60))
    }
}

// MARK: - Test Suite

func runTestSuite() {
    let framework = TestFramework(executable: "./build/pdf22png")
    
    // Test 1: Help output
    framework.runTest(name: "Help Output") {
        let result = framework.runCommand(["--help"])
        let success = result.exitCode == 0 && result.stdout.contains("Usage:")
        return (success, success ? "Help displayed correctly" : "Help command failed")
    }
    
    // Test 2: Version output
    framework.runTest(name: "Version Output") {
        let result = framework.runCommand(["--version"])
        let success = result.exitCode == 0 && result.stdout.contains("pdf22png")
        return (success, success ? "Version displayed correctly" : "Version command failed")
    }
    
    // Test 3: Invalid arguments
    framework.runTest(name: "Invalid Arguments") {
        let result = framework.runCommand(["--invalid-option"])
        let success = result.exitCode != 0
        return (success, success ? "Invalid arguments rejected" : "Should reject invalid arguments")
    }
    
    // Test 4: Missing input file
    framework.runTest(name: "Missing Input File") {
        let result = framework.runCommand([])
        let success = result.exitCode != 0
        return (success, success ? "Missing input file detected" : "Should require input file")
    }
    
    // Test 5: Nonexistent input file
    framework.runTest(name: "Nonexistent Input File") {
        let result = framework.runCommand(["nonexistent.pdf", "output.png"])
        let output = result.stdout + result.stderr
        let success = result.exitCode != 0 && (output.contains("not found") || output.contains("Input file not found"))
        return (success, success ? "Nonexistent file error handled" : "Exit: \(result.exitCode), output: '\(output.prefix(100))'")
    }
    
    // Test 6: Invalid quality parameter
    framework.runTest(name: "Invalid Quality Parameter") {
        let result = framework.runCommand(["--quality", "15", "test.pdf", "output.png"])
        let success = result.exitCode != 0
        return (success, success ? "Invalid quality rejected" : "Should reject invalid quality")
    }
    
    // Test 7: Invalid scale parameter
    framework.runTest(name: "Invalid Scale Parameter") {
        let result = framework.runCommand(["--scale", "invalid", "test.pdf", "output.png"])
        let success = result.exitCode != 0
        return (success, success ? "Invalid scale rejected" : "Should reject invalid scale")
    }
    
    // Test 8: Dry run mode
    framework.runTest(name: "Dry Run Mode") {
        guard framework.createTestPDF(path: "test.pdf") else {
            return (false, "Failed to create test PDF")
        }
        
        defer { try? FileManager.default.removeItem(atPath: "test.pdf") }
        
        let result = framework.runCommand(["--dry-run", "test.pdf", "output.png"])
        let success = result.exitCode == 0 && result.stdout.contains("DRY-RUN")
        
        // Verify no output file was created
        let noOutputFile = !FileManager.default.fileExists(atPath: "output.png")
        
        return (success && noOutputFile, success && noOutputFile ? "Dry run mode works correctly" : "Dry run should not create files")
    }
    
    // Test 9: Single page conversion (if test PDF available)
    framework.runTest(name: "Single Page Conversion") {
        guard framework.createTestPDF(path: "test.pdf") else {
            return (false, "Failed to create test PDF")
        }
        
        defer { 
            try? FileManager.default.removeItem(atPath: "test.pdf")
            try? FileManager.default.removeItem(atPath: "output.png")
        }
        
        let result = framework.runCommand(["test.pdf", "output.png"])
        let success = result.exitCode == 0
        let outputExists = FileManager.default.fileExists(atPath: "output.png")
        
        return (success && outputExists, success && outputExists ? "Single page conversion successful" : "Failed to convert single page")
    }
    
    // Test 10: Batch mode with dry run
    framework.runTest(name: "Batch Mode Dry Run") {
        guard framework.createTestPDF(path: "test.pdf", pageCount: 3) else {
            return (false, "Failed to create test PDF")
        }
        
        defer { try? FileManager.default.removeItem(atPath: "test.pdf") }
        
        let result = framework.runCommand(["--all", "--dry-run", "test.pdf"])
        let success = result.exitCode == 0 && result.stdout.contains("DRY-RUN")
        
        return (success, success ? "Batch dry run mode works" : "Batch dry run failed")
    }
    
    // Test 11: Memory pressure simulation (verbose mode)
    framework.runTest(name: "Memory Monitoring Verbose") {
        guard framework.createTestPDF(path: "test.pdf") else {
            return (false, "Failed to create test PDF")
        }
        
        defer { 
            try? FileManager.default.removeItem(atPath: "test.pdf")
            try? FileManager.default.removeItem(atPath: "output.png")
        }
        
        let result = framework.runCommand(["--verbose", "--dry-run", "test.pdf", "output.png"])
        let success = result.exitCode == 0 && result.stdout.contains("Memory")
        
        return (success, success ? "Memory monitoring active in verbose mode" : "Memory monitoring not working")
    }
    
    // Test 12: Signal handling (timeout test)
    framework.runTest(name: "Signal Handling Ready") {
        // This test just verifies the signal handling code is in place
        // We can't easily test actual signal handling in a unit test
        let result = framework.runCommand(["--help"])
        let success = result.exitCode == 0
        return (success, success ? "Signal handling infrastructure in place" : "Basic functionality required for signal handling")
    }
    
    framework.printSummary()
}

// MARK: - Main Execution

print("PDF22PNG Standalone Swift Implementation Test Suite")
print("Running comprehensive integration tests...")
print("")

runTestSuite()
</file>

</files>
